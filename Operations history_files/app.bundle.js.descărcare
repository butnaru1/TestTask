(function(modules) {
  var parentJsonpFunction = window["webpackJsonp"];
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, chunkId, i = 0, resolves = [], result;
    for (;i < chunkIds.length; i++) {
      chunkId = chunkIds[i];
      if (installedChunks[chunkId]) {
        resolves.push(installedChunks[chunkId][0]);
      }
      installedChunks[chunkId] = 0;
    }
    for (moduleId in moreModules) {
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        modules[moduleId] = moreModules[moduleId];
      }
    }
    if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
    while (resolves.length) {
      resolves.shift()();
    }
  };
  var installedModules = {};
  var installedChunks = {
    1: 0
  };
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__.e = function requireEnsure(chunkId) {
    var installedChunkData = installedChunks[chunkId];
    if (installedChunkData === 0) {
      return new Promise(function(resolve) {
        resolve();
      });
    }
    if (installedChunkData) {
      return installedChunkData[2];
    }
    var promise = new Promise(function(resolve, reject) {
      installedChunkData = installedChunks[chunkId] = [ resolve, reject ];
    });
    installedChunkData[2] = promise;
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.charset = "utf-8";
    script.async = true;
    script.timeout = 12e4;
    if (__webpack_require__.nc) {
      script.setAttribute("nonce", __webpack_require__.nc);
    }
    script.src = __webpack_require__.p + "" + chunkId + ".app.bundle.js";
    var timeout = setTimeout(onScriptComplete, 12e4);
    script.onerror = script.onload = onScriptComplete;
    function onScriptComplete() {
      script.onerror = script.onload = null;
      clearTimeout(timeout);
      var chunk = installedChunks[chunkId];
      if (chunk !== 0) {
        if (chunk) {
          chunk[1](new Error("Loading chunk " + chunkId + " failed."));
        }
        installedChunks[chunkId] = undefined;
      }
    }
    head.appendChild(script);
    return promise;
  };
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.d = function(exports, name, getter) {
    if (!__webpack_require__.o(exports, name)) {
      Object.defineProperty(exports, name, {
        configurable: false,
        enumerable: true,
        get: getter
      });
    }
  };
  __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ? function getDefault() {
      return module["default"];
    } : function getModuleExports() {
      return module;
    };
    __webpack_require__.d(getter, "a", getter);
    return getter;
  };
  __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  __webpack_require__.p = "";
  __webpack_require__.oe = function(err) {
    console.error(err);
    throw err;
  };
  return __webpack_require__(__webpack_require__.s = 21);
})([ function(module, exports, __webpack_require__) {
  (function(global, module) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    (function() {
      var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || this || {};
      var previousUnderscore = root._;
      var ArrayProto = Array.prototype, ObjProto = Object.prototype;
      var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
      var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create;
      var Ctor = function() {};
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
      if (typeof exports != "undefined" && !exports.nodeType) {
        if (typeof module != "undefined" && !module.nodeType && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
      _.VERSION = "1.9.1";
      var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
         case 1:
          return function(value) {
            return func.call(context, value);
          };

         case 3:
          return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };

         case 4:
          return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
        }
        return function() {
          return func.apply(context, arguments);
        };
      };
      var builtinIteratee;
      var cb = function(value, context, argCount) {
        if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
        return _.property(value);
      };
      _.iteratee = builtinIteratee = function(value, context) {
        return cb(value, context, Infinity);
      };
      var restArguments = function(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
          var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0;
          for (;index < length; index++) {
            rest[index] = arguments[index + startIndex];
          }
          switch (startIndex) {
           case 0:
            return func.call(this, rest);

           case 1:
            return func.call(this, arguments[0], rest);

           case 2:
            return func.call(this, arguments[0], arguments[1], rest);
          }
          var args = Array(startIndex + 1);
          for (index = 0; index < startIndex; index++) {
            args[index] = arguments[index];
          }
          args[startIndex] = rest;
          return func.apply(this, args);
        };
      };
      var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor();
        Ctor.prototype = null;
        return result;
      };
      var shallowProperty = function(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      };
      var has = function(obj, path) {
        return obj != null && hasOwnProperty.call(obj, path);
      };
      var deepGet = function(obj, path) {
        var length = path.length;
        for (var i = 0; i < length; i++) {
          if (obj == null) return void 0;
          obj = obj[path[i]];
        }
        return length ? obj : void 0;
      };
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      var getLength = shallowProperty("length");
      var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == "number" && length >= 0 && length <= MAX_ARRAY_INDEX;
      };
      _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee(obj[i], i, obj);
          }
        } else {
          var keys = _.keys(obj);
          for (i = 0, length = keys.length; i < length; i++) {
            iteratee(obj[keys[i]], keys[i], obj);
          }
        }
        return obj;
      };
      _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
      var createReduce = function(dir) {
        var reducer = function(obj, iteratee, memo, initial) {
          var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
          if (!initial) {
            memo = obj[keys ? keys[index] : index];
            index += dir;
          }
          for (;index >= 0 && index < length; index += dir) {
            var currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        };
        return function(obj, iteratee, memo, context) {
          var initial = arguments.length >= 3;
          return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
        };
      };
      _.reduce = _.foldl = _.inject = createReduce(1);
      _.reduceRight = _.foldr = createReduce(-1);
      _.find = _.detect = function(obj, predicate, context) {
        var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
        var key = keyFinder(obj, predicate, context);
        if (key !== void 0 && key !== -1) return obj[key];
      };
      _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      };
      _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
      };
      _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      };
      _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = keys ? keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      };
      _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != "number" || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
      };
      _.invoke = restArguments(function(obj, path, args) {
        var contextPath, func;
        if (_.isFunction(path)) {
          func = path;
        } else if (_.isArray(path)) {
          contextPath = path.slice(0, -1);
          path = path[path.length - 1];
        }
        return _.map(obj, function(context) {
          var method = func;
          if (!method) {
            if (contextPath && contextPath.length) {
              context = deepGet(context, contextPath);
            }
            if (context == null) return void 0;
            method = context[path];
          }
          return method == null ? method : method.apply(context, args);
        });
      });
      _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
      };
      _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
      };
      _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
      };
      _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity, value, computed;
        if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value > result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
              result = v;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
      _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity, value, computed;
        if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) {
          obj = isArrayLike(obj) ? obj : _.values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value < result) {
              result = value;
            }
          }
        } else {
          iteratee = cb(iteratee, context);
          _.each(obj, function(v, index, list) {
            computed = iteratee(v, index, list);
            if (computed < lastComputed || computed === Infinity && result === Infinity) {
              result = v;
              lastComputed = computed;
            }
          });
        }
        return result;
      };
      _.shuffle = function(obj) {
        return _.sample(obj, Infinity);
      };
      _.sample = function(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike(obj)) obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
        var length = getLength(sample);
        n = Math.max(Math.min(n, length), 0);
        var last = length - 1;
        for (var index = 0; index < n; index++) {
          var rand = _.random(index, last);
          var temp = sample[index];
          sample[index] = sample[rand];
          sample[rand] = temp;
        }
        return sample.slice(0, n);
      };
      _.sortBy = function(obj, iteratee, context) {
        var index = 0;
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, key, list) {
          return {
            value: value,
            index: index++,
            criteria: iteratee(value, key, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), "value");
      };
      var group = function(behavior, partition) {
        return function(obj, iteratee, context) {
          var result = partition ? [ [], [] ] : {};
          iteratee = cb(iteratee, context);
          _.each(obj, function(value, index) {
            var key = iteratee(value, index, obj);
            behavior(result, value, key);
          });
          return result;
        };
      };
      _.groupBy = group(function(result, value, key) {
        if (has(result, key)) result[key].push(value); else result[key] = [ value ];
      });
      _.indexBy = group(function(result, value, key) {
        result[key] = value;
      });
      _.countBy = group(function(result, value, key) {
        if (has(result, key)) result[key]++; else result[key] = 1;
      });
      var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (_.isString(obj)) {
          return obj.match(reStrSymbol);
        }
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
      };
      _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
      };
      _.partition = group(function(result, value, pass) {
        result[pass ? 0 : 1].push(value);
      }, true);
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null || array.length < 1) return n == null ? void 0 : [];
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
      };
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      };
      _.last = function(array, n, guard) {
        if (array == null || array.length < 1) return n == null ? void 0 : [];
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
      };
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
      _.compact = function(array) {
        return _.filter(array, Boolean);
      };
      var flatten = function(input, shallow, strict, output) {
        output = output || [];
        var idx = output.length;
        for (var i = 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
            if (shallow) {
              var j = 0, len = value.length;
              while (j < len) output[idx++] = value[j++];
            } else {
              flatten(value, shallow, strict, output);
              idx = output.length;
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      };
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
      };
      _.without = restArguments(function(array, otherArrays) {
        return _.difference(array, otherArrays);
      });
      _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
          context = iteratee;
          iteratee = isSorted;
          isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
          if (isSorted && !iteratee) {
            if (!i || seen !== computed) result.push(value);
            seen = computed;
          } else if (iteratee) {
            if (!_.contains(seen, computed)) {
              seen.push(computed);
              result.push(value);
            }
          } else if (!_.contains(result, value)) {
            result.push(value);
          }
        }
        return result;
      };
      _.union = restArguments(function(arrays) {
        return _.uniq(flatten(arrays, true, true));
      });
      _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (_.contains(result, item)) continue;
          var j;
          for (j = 1; j < argsLength; j++) {
            if (!_.contains(arguments[j], item)) break;
          }
          if (j === argsLength) result.push(item);
        }
        return result;
      };
      _.difference = restArguments(function(array, rest) {
        rest = flatten(rest, true, true);
        return _.filter(array, function(value) {
          return !_.contains(rest, value);
        });
      });
      _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
        for (var index = 0; index < length; index++) {
          result[index] = _.pluck(array, index);
        }
        return result;
      };
      _.zip = restArguments(_.unzip);
      _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
      var createPredicateIndexFinder = function(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (;index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      };
      _.findIndex = createPredicateIndexFinder(1);
      _.findLastIndex = createPredicateIndexFinder(-1);
      _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
      };
      var createIndexFinder = function(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == "number") {
            if (dir > 0) {
              i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex && idx && length) {
            idx = sortedIndex(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice.call(array, i, length), _.isNaN);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      };
      _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
      _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
      _.range = function(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        if (!step) {
          step = stop < start ? -1 : 1;
        }
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
        for (var idx = 0; idx < length; idx++, start += step) {
          range[idx] = start;
        }
        return range;
      };
      _.chunk = function(array, count) {
        if (count == null || count < 1) return [];
        var result = [];
        var i = 0, length = array.length;
        while (i < length) {
          result.push(slice.call(array, i, i += count));
        }
        return result;
      };
      var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
      };
      _.bind = restArguments(function(func, context, args) {
        if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
        var bound = restArguments(function(callArgs) {
          return executeBound(func, bound, context, this, args.concat(callArgs));
        });
        return bound;
      });
      _.partial = restArguments(function(func, boundArgs) {
        var placeholder = _.partial.placeholder;
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      });
      _.partial.placeholder = _;
      _.bindAll = restArguments(function(obj, keys) {
        keys = flatten(keys, false, false);
        var index = keys.length;
        if (index < 1) throw new Error("bindAll must be passed function names");
        while (index--) {
          var key = keys[index];
          obj[key] = _.bind(obj[key], obj);
        }
      });
      _.memoize = function(func, hasher) {
        var memoize = function(key) {
          var cache = memoize.cache;
          var address = "" + (hasher ? hasher.apply(this, arguments) : key);
          if (!has(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize.cache = {};
        return memoize;
      };
      _.delay = restArguments(function(func, wait, args) {
        return setTimeout(function() {
          return func.apply(null, args);
        }, wait);
      });
      _.defer = _.partial(_.delay, _, 1);
      _.throttle = function(func, wait, options) {
        var timeout, context, args, result;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        };
        var throttled = function() {
          var now = _.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
        throttled.cancel = function() {
          clearTimeout(timeout);
          previous = 0;
          timeout = context = args = null;
        };
        return throttled;
      };
      _.debounce = function(func, wait, immediate) {
        var timeout, result;
        var later = function(context, args) {
          timeout = null;
          if (args) result = func.apply(context, args);
        };
        var debounced = restArguments(function(args) {
          if (timeout) clearTimeout(timeout);
          if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(later, wait);
            if (callNow) result = func.apply(this, args);
          } else {
            timeout = _.delay(later, wait, this, args);
          }
          return result;
        });
        debounced.cancel = function() {
          clearTimeout(timeout);
          timeout = null;
        };
        return debounced;
      };
      _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
      };
      _.negate = function(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      };
      _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      };
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
      _.before = function(times, func) {
        var memo;
        return function() {
          if (--times > 0) {
            memo = func.apply(this, arguments);
          }
          if (times <= 1) func = null;
          return memo;
        };
      };
      _.once = _.partial(_.before, 2);
      _.restArguments = restArguments;
      var hasEnumBug = !{
        toString: null
      }.propertyIsEnumerable("toString");
      var nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
      var collectNonEnumProps = function(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
        var prop = "constructor";
        if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
            keys.push(prop);
          }
        }
      };
      _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
      _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
      };
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
      _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = _.keys(obj), length = keys.length, results = {};
        for (var index = 0; index < length; index++) {
          var currentKey = keys[index];
          results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
      };
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [ keys[i], obj[keys[i]] ];
        }
        return pairs;
      };
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
      var createAssigner = function(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index], keys = keysFunc(source), l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      };
      _.extend = createAssigner(_.allKeys);
      _.extendOwn = _.assign = createAssigner(_.keys);
      _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      };
      var keyInObj = function(value, key, obj) {
        return key in obj;
      };
      _.pick = restArguments(function(obj, keys) {
        var result = {}, iteratee = keys[0];
        if (obj == null) return result;
        if (_.isFunction(iteratee)) {
          if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
          keys = _.allKeys(obj);
        } else {
          iteratee = keyInObj;
          keys = flatten(keys, false, false);
          obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i];
          var value = obj[key];
          if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
      });
      _.omit = restArguments(function(obj, keys) {
        var iteratee = keys[0], context;
        if (_.isFunction(iteratee)) {
          iteratee = _.negate(iteratee);
          if (keys.length > 1) context = keys[1];
        } else {
          keys = _.map(flatten(keys, false, false), String);
          iteratee = function(value, key) {
            return !_.contains(keys, key);
          };
        }
        return _.pick(obj, iteratee, context);
      });
      _.defaults = createAssigner(_.allKeys, true);
      _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
      };
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
      _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      };
      var eq, deepEq;
      eq = function(a, b, aStack, bStack) {
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        if (a == null || b == null) return false;
        if (a !== a) return b !== b;
        var type = typeof a;
        if (type !== "function" && type !== "object" && typeof b != "object") return false;
        return deepEq(a, b, aStack, bStack);
      };
      deepEq = function(a, b, aStack, bStack) {
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
         case "[object RegExp]":
         case "[object String]":
          return "" + a === "" + b;

         case "[object Number]":
          if (+a !== +a) return +b !== +b;
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;

         case "[object Date]":
         case "[object Boolean]":
          return +a === +b;

         case "[object Symbol]":
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }
        var areArrays = className === "[object Array]";
        if (!areArrays) {
          if (typeof a != "object" || typeof b != "object") return false;
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
            return false;
          }
        }
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          if (aStack[length] === a) return bStack[length] === b;
        }
        aStack.push(a);
        bStack.push(b);
        if (areArrays) {
          length = a.length;
          if (length !== b.length) return false;
          while (length--) {
            if (!eq(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          var keys = _.keys(a), key;
          length = keys.length;
          if (_.keys(b).length !== length) return false;
          while (length--) {
            key = keys[length];
            if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
          }
        }
        aStack.pop();
        bStack.pop();
        return true;
      };
      _.isEqual = function(a, b) {
        return eq(a, b);
      };
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
      };
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      _.isObject = function(obj) {
        var type = typeof obj;
        return type === "function" || type === "object" && !!obj;
      };
      _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error", "Symbol", "Map", "WeakMap", "Set", "WeakSet" ], function(name) {
        _["is" + name] = function(obj) {
          return toString.call(obj) === "[object " + name + "]";
        };
      });
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return has(obj, "callee");
        };
      }
      var nodelist = root.document && root.document.childNodes;
      if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
        _.isFunction = function(obj) {
          return typeof obj == "function" || false;
        };
      }
      _.isFinite = function(obj) {
        return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
      };
      _.isNaN = function(obj) {
        return _.isNumber(obj) && isNaN(obj);
      };
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
      };
      _.isNull = function(obj) {
        return obj === null;
      };
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
      _.has = function(obj, path) {
        if (!_.isArray(path)) {
          return has(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
          var key = path[i];
          if (obj == null || !hasOwnProperty.call(obj, key)) {
            return false;
          }
          obj = obj[key];
        }
        return !!length;
      };
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
      _.identity = function(value) {
        return value;
      };
      _.constant = function(value) {
        return function() {
          return value;
        };
      };
      _.noop = function() {};
      _.property = function(path) {
        if (!_.isArray(path)) {
          return shallowProperty(path);
        }
        return function(obj) {
          return deepGet(obj, path);
        };
      };
      _.propertyOf = function(obj) {
        if (obj == null) {
          return function() {};
        }
        return function(path) {
          return !_.isArray(path) ? obj[path] : deepGet(obj, path);
        };
      };
      _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
          return _.isMatch(obj, attrs);
        };
      };
      _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
      };
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
      _.now = Date.now || function() {
        return new Date().getTime();
      };
      var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      var unescapeMap = _.invert(escapeMap);
      var createEscaper = function(map) {
        var escaper = function(match) {
          return map[match];
        };
        var source = "(?:" + _.keys(map).join("|") + ")";
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, "g");
        return function(string) {
          string = string == null ? "" : "" + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };
      _.escape = createEscaper(escapeMap);
      _.unescape = createEscaper(unescapeMap);
      _.result = function(obj, path, fallback) {
        if (!_.isArray(path)) path = [ path ];
        var length = path.length;
        if (!length) {
          return _.isFunction(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length;
          }
          obj = _.isFunction(prop) ? prop.call(obj) : prop;
        }
        return obj;
      };
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
      };
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
      var escapeChar = function(match) {
        return "\\" + escapes[match];
      };
      _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
          index = offset + match.length;
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          return match;
        });
        source += "';\n";
        if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        var render;
        try {
          render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
          e.source = source;
          throw e;
        }
        var template = function(data) {
          return render.call(this, data, _);
        };
        var argument = settings.variable || "obj";
        template.source = "function(" + argument + "){\n" + source + "}";
        return template;
      };
      _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
      };
      var chainResult = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
      };
      _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [ this._wrapped ];
            push.apply(args, arguments);
            return chainResult(this, func.apply(_, args));
          };
        });
        return _;
      };
      _.mixin(_);
      _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) delete obj[0];
          return chainResult(this, obj);
        };
      });
      _.each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return chainResult(this, method.apply(this._wrapped, arguments));
        };
      });
      _.prototype.value = function() {
        return this._wrapped;
      };
      _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
      _.prototype.toString = function() {
        return String(this._wrapped);
      };
      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
          return _;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
    })();
  }).call(exports, __webpack_require__(10), __webpack_require__(11)(module));
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
  (function(global, factory) {
    "use strict";
    if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = global.document ? factory(global, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    } else {
      factory(global);
    }
  })(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    "use strict";
    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction = function isFunction(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number";
    };
    var isWindow = function isWindow(obj) {
      return obj != null && obj === obj.window;
    };
    var preservedScriptAttributes = {
      type: true,
      src: true,
      noModule: true
    };
    function DOMEval(code, doc, node) {
      doc = doc || document;
      var i, script = doc.createElement("script");
      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {
          if (node[i]) {
            script[i] = node[i];
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    var version = "3.3.1", jQuery = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    jQuery.fn = jQuery.prototype = {
      jquery: version,
      constructor: jQuery,
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      get: function(num) {
        if (num == null) {
          return slice.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      push: push,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction(target)) {
        target = {};
      }
      if (i === length) {
        target = this;
        i--;
      }
      for (;i < length; i++) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            src = target[name];
            copy = options[name];
            if (target === copy) {
              continue;
            }
            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && Array.isArray(src) ? src : [];
              } else {
                clone = src && jQuery.isPlainObject(src) ? src : {};
              }
              target[name] = jQuery.extend(deep, clone, copy);
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {},
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      globalEval: function(code) {
        DOMEval(code);
      },
      each: function(obj, callback) {
        var length, i = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (;i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      trim: function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "");
      },
      makeArray: function(arr, results) {
        var ret = results || [];
        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
          } else {
            push.call(ret, arr);
          }
        }
        return ret;
      },
      inArray: function(elem, arr, i) {
        return arr == null ? -1 : indexOf.call(arr, elem, i);
      },
      merge: function(first, second) {
        var len = +second.length, j = 0, i = first.length;
        for (;j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
        for (;i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      map: function(elems, callback, arg) {
        var length, value, i = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (;i < length; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return concat.apply([], ret);
      },
      guid: 1,
      support: support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
      var length = !!obj && "length" in obj && obj.length, type = toType(obj);
      if (isFunction(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
    function(window) {
      var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
        var i = 0, len = list.length;
        for (;i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
        ID: new RegExp("^#(" + identifier + ")"),
        CLASS: new RegExp("^\\.(" + identifier + ")"),
        TAG: new RegExp("^(" + identifier + "|[*])"),
        ATTR: new RegExp("^" + attributes),
        PSEUDO: new RegExp("^" + pseudos),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + booleans + ")$", "i"),
        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }, unloadHandler = function() {
        setDocument();
      }, disabledAncestor = addCombinator(function(elem) {
        return elem.disabled === true && ("form" in elem || "label" in elem);
      }, {
        dir: "parentNode",
        next: "legend"
      });
      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? function(target, els) {
            push_native.apply(target, slice.call(els));
          } : function(target, els) {
            var j = target.length, i = 0;
            while (target[j++] = els[i++]) {}
            target.length = j - 1;
          }
        };
      }
      function Sizzle(selector, context, results, seed) {
        var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
        results = results || [];
        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed) {
          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
            setDocument(context);
          }
          context = context || document;
          if (documentIsHTML) {
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              if (m = match[1]) {
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results;
              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }
            if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector;
              } else if (context.nodeName.toLowerCase() !== "object") {
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
                groups = tokenize(selector);
                i = groups.length;
                while (i--) {
                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
                }
                newSelector = groups.join(",");
                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              }
              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {} finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        }
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      function createCache() {
        var keys = [];
        function cache(key, value) {
          if (keys.push(key + " ") > Expr.cacheLength) {
            delete cache[keys.shift()];
          }
          return cache[key + " "] = value;
        }
        return cache;
      }
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      function assert(fn) {
        var el = document.createElement("fieldset");
        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
          el = null;
        }
      }
      function addHandle(attrs, handler) {
        var arr = attrs.split("|"), i = arr.length;
        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      function siblingCheck(a, b) {
        var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
        if (diff) {
          return diff;
        }
        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }
      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }
      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }
      function createDisabledPseudo(disabled) {
        return function(elem) {
          if ("form" in elem) {
            if (elem.parentNode && elem.disabled === false) {
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }
              return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
            }
            return elem.disabled === disabled;
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }
          return false;
        };
      }
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }
      support = Sizzle.support = {};
      isXML = Sizzle.isXML = function(elem) {
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document);
        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false);
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        support.attributes = assert(function(el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        support.getElementsByTagName = assert(function(el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        });
        support.getElementsByClassName = rnative.test(document.getElementsByClassName);
        support.getById = assert(function(el) {
          docElem.appendChild(el).id = expando;
          return !document.getElementsByName || !document.getElementsByName(expando).length;
        });
        if (support.getById) {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find["ID"] = function(id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [ elem ] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };
          Expr.find["ID"] = function(id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node, i, elems, elem = context.getElementById(id);
              if (elem) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [ elem ];
                }
                elems = context.getElementsByName(id);
                i = 0;
                while (elem = elems[i++]) {
                  node = elem.getAttributeNode("id");
                  if (node && node.value === id) {
                    return [ elem ];
                  }
                }
              }
              return [];
            }
          };
        }
        Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function(tag, context) {
          var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }
            return tmp;
          }
          return results;
        };
        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if (support.qsa = rnative.test(document.querySelectorAll)) {
          assert(function(el) {
            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function(el) {
            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }
            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            docElem.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function(el) {
            support.disconnectedMatch = matches.call(el, "*");
            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function(a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };
        sortOrder = hasCompare ? function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }
          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }
            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        } : function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
          if (!aup || !bup) {
            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          } else if (aup === bup) {
            return siblingCheck(a, b);
          }
          cur = a;
          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }
          cur = b;
          while (cur = cur.parentNode) {
            bp.unshift(cur);
          }
          while (ap[i] === bp[i]) {
            i++;
          }
          return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return document;
      };
      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };
      Sizzle.matchesSelector = function(elem, expr) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        expr = expr.replace(rattributeQuotes, "='$1']");
        if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }
        return Sizzle(expr, document, null, [ elem ]).length > 0;
      };
      Sizzle.contains = function(context, elem) {
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle.attr = function(elem, name) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };
      Sizzle.escape = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle.uniqueSort = function(results) {
        var elem, duplicates = [], j = 0, i = 0;
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle.getText = function(elem) {
        var node, ret = "", i = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node = elem[i++]) {
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          ATTR: function(match) {
            match[1] = match[1].replace(runescape, funescape);
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
          },
          CHILD: function(match) {
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
              if (!match[3]) {
                Sizzle.error(match[0]);
              }
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd");
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }
            return match;
          },
          PSEUDO: function(match) {
            var excess, unquoted = !match[6] && match[2];
            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }
            if (match[3]) {
              match[2] = match[4] || match[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            return match.slice(0, 3);
          }
        },
        filter: {
          TAG: function(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function() {
              return true;
            } : function(elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          CLASS: function(className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          ATTR: function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          CHILD: function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
            return first === 1 && last === 0 ? function(elem) {
              return !!elem.parentNode;
            } : function(elem, context, xml) {
              var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
              if (parent) {
                if (simple) {
                  while (dir) {
                    node = elem;
                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    }
                    start = dir = type === "only" && !start && "nextSibling";
                  }
                  return true;
                }
                start = [ forward ? parent.firstChild : parent.lastChild ];
                if (forward && useCache) {
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                      break;
                    }
                  }
                } else {
                  if (useCache) {
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  }
                  if (diff === false) {
                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {});
                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type] = [ dirruns, diff ];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                }
                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          PSEUDO: function(pseudo, argument) {
            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args = [ pseudo, pseudo, "", argument ];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                var idx, matched = fn(seed, argument), i = matched.length;
                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function(elem) {
                return fn(elem, 0, args);
              };
            }
            return fn;
          }
        },
        pseudos: {
          not: markFunction(function(selector) {
            var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
              var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function(elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              input[0] = null;
              return !results.pop();
            };
          }),
          has: markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          contains: markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          lang: markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          target: function(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          root: function(elem) {
            return elem === docElem;
          },
          focus: function(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          enabled: createDisabledPseudo(false),
          disabled: createDisabledPseudo(true),
          checked: function(elem) {
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          selected: function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          empty: function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          parent: function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          header: function(elem) {
            return rheader.test(elem.nodeName);
          },
          input: function(elem) {
            return rinputs.test(elem.nodeName);
          },
          button: function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          text: function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          first: createPositionalPseudo(function() {
            return [ 0 ];
          }),
          last: createPositionalPseudo(function(matchIndexes, length) {
            return [ length - 1 ];
          }),
          eq: createPositionalPseudo(function(matchIndexes, length, argument) {
            return [ argument < 0 ? argument + length : argument ];
          }),
          even: createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for (;i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          odd: createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for (;i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          lt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (;--i >= 0; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          gt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (;++i < length; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in {
        submit: true,
        reset: true
      }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
      };
      function toSelector(tokens) {
        var i = 0, len = tokens.length, selector = "";
        for (;i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }
      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
        return combinator.first ? function(elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
          return false;
        } : function(elem, context, xml) {
          var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  uniqueCache[key] = newCache;
                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        };
      }
      function elementMatcher(matchers) {
        return matchers.length > 1 ? function(elem, context, xml) {
          var i = matchers.length;
          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } : matchers[0];
      }
      function multipleContexts(selector, contexts, results) {
        var i = 0, len = contexts.length;
        for (;i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }
      function condense(unmatched, map, filter, context, xml) {
        var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
        for (;i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            i = temp.length;
            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if (elem = matcherOut[i]) {
                    temp.push(matcherIn[i] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml);
              }
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [ function(elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          checkContext = null;
          return ret;
        } ];
        for (;i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
            if (matcher[expando]) {
              j = ++i;
              for (;j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
          if (outermost) {
            outermostContext = context === document || context || outermost;
          }
          for (;i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      compile = Sizzle.compile = function(selector, match) {
        var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
        if (!cached) {
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
          cached.selector = selector;
        }
        return cached;
      };
      select = Sizzle.select = function(selector, context, results, seed) {
        var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || [];
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      };
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support.detectDuplicates = !!hasDuplicate;
      setDocument();
      support.sortDetached = assert(function(el) {
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      });
      if (!assert(function(el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support.attributes || !assert(function(el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function(elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }
      return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (;n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction(qualifier)) {
        return jQuery.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function(elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [];
      }
      return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
        return elem.nodeType === 1;
      }));
    };
    jQuery.fn.extend({
      find: function(selector) {
        var i, ret, len = this.length, self = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery.find(selector, self[i], ret);
        }
        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root = root || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [ null, selector, null ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
      }
      return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function(target) {
        var targets = jQuery(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (;i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
        if (!rneedsContext.test(selectors)) {
          for (;i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        }
        return indexOf.call(this, elem.jquery ? elem[0] : elem);
      },
      add: function(selector, context) {
        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
      },
      addBack: function(selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      }
    });
    function sibling(cur, dir) {
      while ((cur = cur[dir]) && cur.nodeType !== 1) {}
      return cur;
    }
    jQuery.each({
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (nodeName(elem, "iframe")) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery.merge([], elem.childNodes);
      }
    }, function(name, fn) {
      jQuery.fn[name] = function(until, selector) {
        var matched = jQuery.map(this, fn, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          }
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
      var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (;queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self = {
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              jQuery.each(args, function(_, arg) {
                if (isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        remove: function() {
          jQuery.each(arguments, function(_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        lock: function() {
          locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [ context, args.slice ? args.slice() : args ];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        fire: function() {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function() {
          return !!fired;
        }
      };
      return self;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
      var method;
      try {
        if (value && isFunction(method = value.promise)) {
          method.call(value).done(resolve).fail(reject);
        } else if (value && isFunction(method = value.then)) {
          method.call(value, resolve, reject);
        } else {
          resolve.apply(undefined, [ value ].slice(noValue));
        }
      } catch (value) {
        reject.apply(undefined, [ value ]);
      }
    }
    jQuery.extend({
      Deferred: function(func) {
        var tuples = [ [ "notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2 ], [ "resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected" ] ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          catch: function(fn) {
            return promise.then(null, fn);
          },
          pipe: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(i, tuple) {
                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [ returned ] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction(then)) {
                    if (special) {
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                    } else {
                      maxDepth++;
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                    }
                  } else {
                    if (handler !== Identity) {
                      that = undefined;
                      args = [ returned ];
                    }
                    (special || deferred.resolveWith)(that, args);
                  }
                }, process = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(e, process.stackTrace);
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = undefined;
                        args = [ e ];
                      }
                      deferred.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process();
                } else {
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window.setTimeout(process);
                }
              };
            }
            return jQuery.Deferred(function(newDefer) {
              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery.each(tuples, function(i, tuple) {
          var list = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(function() {
              state = stateString;
            }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
          }
          list.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i) {
          return function(value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (!--remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
          if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
            return master.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), master.reject);
        }
        return master.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
      }
    };
    jQuery.readyException = function(error) {
      window.setTimeout(function() {
        throw error;
      });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error) {
        jQuery.readyException(error);
      });
      return this;
    };
    jQuery.extend({
      isReady: false,
      readyWait: 1,
      ready: function(wait) {
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }
        jQuery.isReady = true;
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document, [ jQuery ]);
      }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
      document.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
      jQuery.ready();
    }
    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
      window.setTimeout(jQuery.ready);
    } else {
      document.addEventListener("DOMContentLoaded", completed);
      window.addEventListener("load", completed);
    }
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (;i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data, value) {
        var prop, cache = this.cache(owner);
        if (typeof data === "string") {
          cache[camelCase(data)] = value;
        } else {
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
      },
      access: function(owner, key, value) {
        if (key === undefined || key && typeof key === "string" && value === undefined) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== undefined ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === undefined) {
          return;
        }
        if (key !== undefined) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [ key ] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === undefined || jQuery.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = undefined;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== undefined && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
      if (data === "true") {
        return true;
      }
      if (data === "false") {
        return false;
      }
      if (data === "null") {
        return null;
      }
      if (data === +data + "") {
        return +data;
      }
      if (rbrace.test(data)) {
        return JSON.parse(data);
      }
      return data;
    }
    function dataAttr(elem, key, data) {
      var name;
      if (data === undefined && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);
        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {}
          dataUser.set(elem, key, data);
        } else {
          data = undefined;
        }
      }
      return data;
    }
    jQuery.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function(elem, name) {
        dataUser.remove(elem, name);
      },
      _data: function(elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function(elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function(key, value) {
        var i, name, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === undefined) {
          if (this.length) {
            data = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name = attrs[i].name;
                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value) {
          var data;
          if (elem && value === undefined) {
            data = dataUser.get(elem, key);
            if (data !== undefined) {
              return data;
            }
            data = dataAttr(elem, key);
            if (data !== undefined) {
              return data;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function(elem, type, data) {
        var queue;
        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type);
          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }
          return queue || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
          jQuery.dequeue(elem, type);
        };
        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }
        if (fn) {
          if (type === "fx") {
            queue.unshift("inprogress");
          }
          delete hooks.stop;
          fn.call(elem, next, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [ type + "queue", key ]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }
        return data === undefined ? this : this.each(function() {
          var queue = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      promise: function(type, obj) {
        var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [ elements ]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = undefined;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
    };
    var swap = function(elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
      if (display) {
        return display;
      }
      temp = doc.body.appendChild(doc.createElement(nodeName));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values = [], index = 0, length = elements.length;
      for (;index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;
            if (!values[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }
      return elements;
    }
    jQuery.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    var wrapMap = {
      option: [ 1, "<select multiple='multiple'>", "</select>" ],
      thead: [ 1, "<table>", "</table>" ],
      col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
      tr: [ 2, "<table><tbody>", "</tbody></table>" ],
      td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
      _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === undefined || tag && nodeName(context, tag)) {
        return jQuery.merge([ context ], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (;i < l; i++) {
        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (;i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    (function() {
      var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var documentElement = document.documentElement;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function safeActiveElement() {
      try {
        return document.activeElement;
      } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }
        return elem;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    jQuery.event = {
      global: {},
      add: function(elem, types, handler, data, selector) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!elemData) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        }
        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = {};
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
          };
        }
        types = (types || "").match(rnothtmlwhite) || [ "" ];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery.event.special[type] || {};
          handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery.event.global[type] = true;
        }
      },
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types = (types || "").match(rnothtmlwhite) || [ "" ];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var event = jQuery.event.fix(nativeEvent);
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== undefined) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
          for (;cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === undefined) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: cur,
            handlers: handlers.slice(delegateCount)
          });
        }
        return handlerQueue;
      },
      addProp: function(name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          noBubble: true
        },
        focus: {
          trigger: function() {
            if (this !== safeActiveElement() && this.focus) {
              this.focus();
              return false;
            }
          },
          delegateType: "focusin"
        },
        blur: {
          trigger: function() {
            if (this === safeActiveElement() && this.blur) {
              this.blur();
              return false;
            }
          },
          delegateType: "focusout"
        },
        click: {
          trigger: function() {
            if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
              this.click();
              return false;
            }
          },
          _default: function(event) {
            return nodeName(event.target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== undefined && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    jQuery.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery.Event = function(src, props) {
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      char: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: function(event) {
        var button = event.button;
        if (event.which == null && rkeyEvent.test(event.type)) {
          return event.charCode != null ? event.charCode : event.keyCode;
        }
        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
          if (button & 1) {
            return 1;
          }
          if (button & 2) {
            return 3;
          }
          if (button & 4) {
            return 2;
          }
          return 0;
        }
        return event.which;
      }
    }, jQuery.event.addProp);
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function(types, selector, fn) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn = selector;
          selector = undefined;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.access(src);
        pdataCur = dataPriv.set(dest, pdataOld);
        events = pdataOld.events;
        if (events) {
          delete pdataCur.handle;
          pdataCur.events = {};
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName = dest.nodeName.toLowerCase();
      if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self.html());
          }
          domManip(self, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (;i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove(elem, selector, keepData) {
      var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
      for (;(node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && jQuery.contains(node.ownerDocument, node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery.extend({
      htmlPrefilter: function(html) {
        return html.replace(rxhtmlTag, "<$1></$2>");
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          destElements = getAll(clone);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        }
        destElements = getAll(clone, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone;
      },
      cleanData: function(elems) {
        var data, elem, type, special = jQuery.event.special, i = 0;
        for (;(elem = elems[i]) !== undefined; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type);
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              }
              elem[dataPriv.expando] = undefined;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = undefined;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function(selector) {
        return remove(this, selector, true);
      },
      remove: function(selector) {
        return remove(this, selector);
      },
      text: function(value) {
        return access(this, function(value) {
          return value === undefined ? jQuery.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (;(elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
            value = jQuery.htmlPrefilter(value);
            try {
              for (;i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }
              elem = 0;
            } catch (e) {}
          }
          if (elem) {
            this.empty().append(value);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent = this.parentNode;
          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name, original) {
      jQuery.fn[name] = function(selector) {
        var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
        for (;i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window;
      }
      return view.getComputedStyle(elem);
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        }
      });
    })();
    function curCSS(elem, name, computed) {
      var width, minWidth, maxWidth, ret, style = elem.style;
      computed = computed || getStyles(elem);
      if (computed) {
        ret = computed.getPropertyValue(name) || computed[name];
        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    function vendorPropName(name) {
      if (name in emptyStyle) {
        return name;
      }
      var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
      while (i--) {
        name = cssPrefixes[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }
    function finalPropName(name) {
      var ret = jQuery.cssProps[name];
      if (!ret) {
        ret = jQuery.cssProps[name] = vendorPropName(name) || name;
      }
      return ret;
    }
    function setPositiveNumber(elem, value, subtract) {
      var matches = rcssNum.exec(value);
      return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (;i < 4; i += 2) {
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
        }
        if (!isBorderBox) {
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          }
          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5));
      }
      return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), val = curCSS(elem, dimension, styles), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox;
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
      if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
        val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
        valueIsBorderBox = true;
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
    }
    jQuery.extend({
      cssHooks: {
        opacity: {
          get: function(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      cssNumber: {
        animationIterationCount: true,
        columnCount: true,
        fillOpacity: true,
        flexGrow: true,
        flexShrink: true,
        fontWeight: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        widows: true,
        zIndex: true,
        zoom: true
      },
      cssProps: {},
      style: function(elem, name, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (value !== undefined) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number") {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
            return ret;
          }
          return style[name];
        }
      },
      css: function(elem, name, extra, styles) {
        var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === undefined) {
          val = curCSS(elem, name, styles);
        }
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery.each([ "height", "width" ], function(i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function(elem, computed, extra) {
          if (computed) {
            return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
          if (isBorderBox && support.scrollboxSize() === styles.position) {
            subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - .5);
          }
          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function() {
          return elem.getBoundingClientRect().left;
        })) + "px";
      }
    });
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
          for (;i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function(name, value) {
        return access(this, function(elem, name, value) {
          var styles, len, map = {}, i = 0;
          if (Array.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;
            for (;i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }
            return map;
          }
          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
        }, name, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function(p) {
        return p;
      },
      swing: function(p) {
        return .5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document.hidden === false && window.requestAnimationFrame) {
          window.requestAnimationFrame(schedule);
        } else {
          window.setTimeout(schedule, jQuery.fx.interval);
        }
        jQuery.fx.tick();
      }
    }
    function createFxNow() {
      window.setTimeout(function() {
        fxNow = undefined;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = {
        height: type
      };
      includeWidth = includeWidth ? 1 : 0;
      for (;i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (;index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }
      propTween = !jQuery.isEmptyObject(props);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([ elem ], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([ elem ]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", {
              display: restoreDisplay
            });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([ elem ], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([ elem ]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks;
      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }
        if (index !== name) {
          props[name] = value;
          delete props[index];
        }
        hooks = jQuery.cssHooks[name];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name];
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (;index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [ animation, percent, remaining ]);
        if (percent < 1 && length) {
          return remaining;
        }
        if (!length) {
          deferred.notifyWith(elem, [ animation, 1, 0 ]);
        }
        deferred.resolveWith(elem, [ animation ]);
        return false;
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (;index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [ animation, 1, 0 ]);
            deferred.resolveWith(elem, [ animation, gotoEnd ]);
          } else {
            deferred.rejectWith(elem, [ animation, gotoEnd ]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (;index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery.map(props, createTween, animation);
      if (isFunction(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      }));
      return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [ function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        } ]
      },
      tweener: function(props, callback) {
        if (isFunction(props)) {
          callback = props;
          props = [ "*" ];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index = 0, length = props.length;
        for (;index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [ defaultPrefilter ],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery.speed = function(speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction(easing) && easing
      };
      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
          opacity: to
        }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = undefined;
        }
        if (clearQueue && type !== false) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
          data.finish = true;
          jQuery.queue(this, type, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
      var cssFn = jQuery.fn[name];
      jQuery.fn[name] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    });
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(name, props) {
      jQuery.fn[name] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
      var timer, i = 0, timers = jQuery.timers;
      fxNow = Date.now();
      for (;i < timers.length; i++) {
        timer = timers[i];
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery.fx.stop = function() {
      inProgress = null;
    };
    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    };
    jQuery.fn.delay = function(time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks) {
        var timeout = window.setTimeout(next, time);
        hooks.stop = function() {
          window.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function(name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function(name) {
        return this.each(function() {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
        }
        if (value !== undefined) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }
          elem.setAttribute(name, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name) {
        if (value === false) {
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }
        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;
      attrHandle[name] = function(elem, name, isXML) {
        var ret, handle, lowercaseName = name.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function(name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function(name) {
        return this.each(function() {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }
        if (value !== undefined) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }
          return elem[name] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        for: "htmlFor",
        class: "className"
      }
    });
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function(elem) {
          var parent = elem.parentNode;
          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
      jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery.fn.extend({
      addClass: function(value) {
        var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
        if (isFunction(value)) {
          return this.each(function(j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }
        classes = classesToArray(value);
        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              j = 0;
              while (clazz = classes[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }
        return this;
      },
      removeClass: function(value) {
        var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
        if (isFunction(value)) {
          return this.each(function(j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classes = classesToArray(value);
        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              j = 0;
              while (clazz = classes[j++]) {
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (isFunction(value)) {
          return this.each(function(i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
          });
        }
        return this.each(function() {
          var className, i, self, classNames;
          if (isValidValue) {
            i = 0;
            self = jQuery(this);
            classNames = classesToArray(value);
            while (className = classNames[i++]) {
              if (self.hasClass(className)) {
                self.removeClass(className);
              } else {
                self.addClass(className);
              }
            }
          } else if (value === undefined || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i = 0;
        className = " " + selector + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function(value) {
        var hooks, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function(value) {
              return value == null ? "" : value + "";
            });
          }
          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function(elem) {
            var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            }
            for (;i < max; i++) {
              option = options[i];
              if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                value = jQuery(option).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
            while (i--) {
              option = options[i];
              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
      jQuery.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
      trigger: function(event, data, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = undefined;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
        special = jQuery.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (;cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery.event.triggered = undefined;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      simulate: function(type, elem, event) {
        var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true
        });
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function(type, data) {
        return this.each(function() {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function(orig, fix) {
        var handler = function(event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
          setup: function() {
            var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }
            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }
    var location = window.location;
    var nonce = Date.now();
    var rquery = /\?/;
    jQuery.parseXML = function(data) {
      var xml;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        xml = new window.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName("parsererror").length) {
        jQuery.error("Invalid XML: " + data);
      }
      return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
      var name;
      if (Array.isArray(obj)) {
        jQuery.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix)) {
            add(prefix, v);
          } else {
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        add(prefix, obj);
      }
    }
    jQuery.param = function(a, traditional) {
      var prefix, s = [], add = function(key, valueOrFunction) {
        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        jQuery.each(a, function() {
          add(this.name, this.value);
        });
      } else {
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      }
      return s.join("&");
    };
    jQuery.fn.extend({
      serialize: function() {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(i, elem) {
          var val = jQuery(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery.map(val, function(val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            });
          }
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== undefined) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === undefined) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return {
        state: "success",
        data: response
      };
    }
    jQuery.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        converters: {
          "* text": String,
          "text html": true,
          "text json": JSON.parse,
          "text xml": jQuery.parseXML
        },
        flatOptions: {
          url: true,
          context: true
        }
      },
      ajaxSetup: function(target, settings) {
        return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      ajax: function(url, options) {
        if (typeof url === "object") {
          options = url;
          url = undefined;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          getResponseHeader: function(key) {
            var match;
            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function() {
            return completed ? responseHeadersString : null;
          },
          setRequestHeader: function(name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function(type) {
            if (completed == null) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function(map) {
            var code;
            if (map) {
              if (completed) {
                jqXHR.always(map[jqXHR.status]);
              } else {
                for (code in map) {
                  statusCode[code] = [ statusCode[code], map[code] ];
                }
              }
            }
            return this;
          },
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [ "" ];
        if (s.crossDomain == null) {
          urlAnchor = document.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed) {
          return jqXHR;
        }
        fireGlobals = jQuery.event && s.global;
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
          }
          if (completed) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (completed) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified, statusText = nativeStatusText;
          if (completed) {
            return;
          }
          completed = true;
          if (timeoutTimer) {
            window.clearTimeout(timeoutTimer);
          }
          transport = undefined;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
          } else {
            deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = undefined;
          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
          }
          completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
            if (!--jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery.get(url, undefined, callback, "script");
      }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
      jQuery[method] = function(url, data, callback, type) {
        if (isFunction(data)) {
          type = type || callback;
          callback = data;
          data = undefined;
        }
        return jQuery.ajax(jQuery.extend({
          url: url,
          type: method,
          dataType: type,
          data: data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });
    jQuery._evalUrl = function(url) {
      return jQuery.ajax({
        url: url,
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        throws: true
      });
    };
    jQuery.fn.extend({
      wrapAll: function(html) {
        var wrap;
        if (this[0]) {
          if (isFunction(html)) {
            html = html.call(this[0]);
          }
          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction(html)) {
          return this.each(function(i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self = jQuery(this), contents = self.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction(html);
        return this.each(function(i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
      try {
        return new window.XMLHttpRequest();
      } catch (e) {}
    };
    var xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(options.type, options.url, options.async, options.username, options.password);
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(xhr.status, xhr.statusText);
                    }
                  } else {
                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                      binary: xhr.response
                    } : {
                      text: xhr.responseText
                    }, xhr.getAllResponseHeaders());
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== undefined) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });
    jQuery.ajaxPrefilter("script", function(s) {
      if (s.cache === undefined) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery.ajaxTransport("script", function(s) {
      if (s.crossDomain) {
        var script, callback;
        return {
          send: function(_, complete) {
            script = jQuery("<script>").prop({
              charset: s.scriptCharset,
              src: s.url
            }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window[callbackName];
        window[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === undefined) {
            jQuery(window).removeProp(callbackName);
          } else {
            window[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = undefined;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function(data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document.implementation.createHTMLDocument("");
          base = context.createElement("base");
          base.href = document.location.href;
          context.head.appendChild(base);
        } else {
          context = document;
        }
      }
      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];
      if (parsed) {
        return [ context.createElement(parsed[1]) ];
      }
      parsed = buildFragment([ data ], context, scripts);
      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function(url, params, callback) {
      var selector, type, response, self = this, off = url.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }
      if (isFunction(params)) {
        callback = params;
        params = undefined;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self.length > 0) {
        jQuery.ajax({
          url: url,
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).always(callback && function(jqXHR, status) {
          self.each(function() {
            callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
          });
        });
      }
      return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
      jQuery.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    });
    jQuery.expr.pseudos.animated = function(elem) {
      return jQuery.grep(jQuery.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction(options)) {
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      offset: function(options) {
        if (arguments.length) {
          return options === undefined ? this : this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return {
            top: 0,
            left: 0
          };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset, doc, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
        if (jQuery.css(elem, "position") === "fixed") {
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset();
          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;
          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
    }, function(method, prop) {
      var top = "pageYOffset" === prop;
      jQuery.fn[method] = function(val) {
        return access(this, function(elem, method, val) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }
          if (win) {
            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
          } else {
            elem[method] = val;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        }
      });
    });
    jQuery.each({
      Height: "height",
      Width: "width"
    }, function(name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function(defaultExtra, funcName) {
        jQuery.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type, value) {
            var doc;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            }
            if (elem.nodeType === 9) {
              doc = elem.documentElement;
              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
            }
            return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
          }, type, chainable ? margin : undefined, chainable);
        };
      });
    });
    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
      jQuery.fn[name] = function(data, fn) {
        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
      };
    });
    jQuery.fn.extend({
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.fn.extend({
      bind: function(types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function(types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function(selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function(selector, types, fn) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      }
    });
    jQuery.proxy = function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };
    jQuery.holdReady = function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
    };
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return jQuery;
      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    };
    if (!noGlobal) {
      window.jQuery = window.$ = jQuery;
    }
    return jQuery;
  });
}, function(module, exports, __webpack_require__) {
  (function(_, $) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var Cookies = __webpack_require__(12), Globalize = __webpack_require__(17), storage = __webpack_require__(8), defaults = __webpack_require__(32), defaultSettings = __webpack_require__(33);
      var initLocale = function(settings) {
        if (!window.OW.mainConfig.LOCALE) {
          throw new Error("LOCALE is not defined in main.js");
        }
        window.WB.currentLocale = storage.get("LOCALE") || window.OW.mainConfig.LOCALE;
        var locale = window.WB.currentLocale;
        settings.LOCALE = locale;
        storage.set("LOCALE", locale, {
          path: window.WB.contextPath
        });
        var xsrfToken = Cookies.get("XSRF-TOKEN"), headers = {
          "Accept-Language": locale
        };
        if (xsrfToken) {
          _.extend(headers, {
            "X-XSRF-TOKEN": xsrfToken
          });
        }
        $.ajaxSetup({
          headers: headers
        });
        if (locale === "ua") {
          locale = "uk";
        }
        Globalize.load(__webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(14)("./" + locale + "/numbers.json"), __webpack_require__(14)("./" + locale + "/ca-gregorian.json"));
        Globalize.locale(locale);
      };
      var initApiUrl = function(settings) {
        settings.API_URL = window.WB.API_URL;
      };
      var settings = _.extend({}, defaults);
      initApiUrl(settings);
      defaultSettings.initDefaultSettings(settings);
      settings.IMAGE_PATH = window.WB.STATIC_PATH + "/client/images";
      settings.RESOURCES_PATH = window.WB.contextPath + "/resources";
      settings.loadPromise.then(function() {
        settings.MASKS = __webpack_require__(45);
        initLocale(settings);
      });
      return settings;
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0), __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
  var define = false;
  /**
 * Globalize v1.4.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2018-07-17T20:38Z
 */
  /*!
 * Globalize v1.4.0 2018-07-17T20:38Z Released under the MIT license
 * http://git.io/TrdQbw
 */
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([ "cldr", "cldr/event" ], factory);
    } else if (true) {
      module.exports = factory(__webpack_require__(5));
    } else {
      root.Globalize = factory(root.Cldr);
    }
  })(this, function(Cldr) {
    var toString = function(variable) {
      return typeof variable === "string" ? variable : typeof variable === "number" ? "" + variable : JSON.stringify(variable);
    };
    var formatMessage = function(message, data) {
      message = message.replace(/{[0-9a-zA-Z-_. ]+}/g, function(name) {
        name = name.replace(/^{([^}]*)}$/, "$1");
        return toString(data[name]);
      });
      return message;
    };
    var objectExtend = function() {
      var destination = arguments[0], sources = [].slice.call(arguments, 1);
      sources.forEach(function(source) {
        var prop;
        for (prop in source) {
          destination[prop] = source[prop];
        }
      });
      return destination;
    };
    var createError = function(code, message, attributes) {
      var error;
      message = code + (message ? ": " + formatMessage(message, attributes) : "");
      error = new Error(message);
      error.code = code;
      objectExtend(error, attributes);
      return error;
    };
    var runtimeStringify = function(args) {
      return JSON.stringify(args, function(key, value) {
        if (value && value.runtimeKey) {
          return value.runtimeKey;
        }
        return value;
      });
    };
    var stringHash = function(str) {
      return [].reduce.call(str, function(hash, i) {
        var chr = i.charCodeAt(0);
        hash = (hash << 5) - hash + chr;
        return hash | 0;
      }, 0);
    };
    var runtimeKey = function(fnName, locale, args, argsStr) {
      var hash;
      argsStr = argsStr || runtimeStringify(args);
      hash = stringHash(fnName + locale + argsStr);
      return hash > 0 ? "a" + hash : "b" + Math.abs(hash);
    };
    var functionName = function(fn) {
      if (fn.name !== undefined) {
        return fn.name;
      }
      var matches = /^function\s+([\w\$]+)\s*\(/.exec(fn.toString());
      if (matches && matches.length > 0) {
        return matches[1];
      }
    };
    var runtimeBind = function(args, cldr, fn, runtimeArgs) {
      var argsStr = runtimeStringify(args), fnName = functionName(fn), locale = cldr.locale;
      if (!fnName) {
        return fn;
      }
      fn.runtimeKey = runtimeKey(fnName, locale, null, argsStr);
      fn.generatorString = function() {
        return 'Globalize("' + locale + '").' + fnName + "(" + argsStr.slice(1, -1) + ")";
      };
      fn.runtimeArgs = runtimeArgs;
      return fn;
    };
    var validate = function(code, message, check, attributes) {
      if (!check) {
        throw createError(code, message, attributes);
      }
    };
    var alwaysArray = function(stringOrArray) {
      return Array.isArray(stringOrArray) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
    };
    var validateCldr = function(path, value, options) {
      var skipBoolean;
      options = options || {};
      skipBoolean = alwaysArray(options.skip).some(function(pathRe) {
        return pathRe.test(path);
      });
      validate("E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
        path: path
      });
    };
    var validateDefaultLocale = function(value) {
      validate("E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.", value !== undefined, {});
    };
    var validateParameterPresence = function(value, name) {
      validate("E_MISSING_PARAMETER", "Missing required parameter `{name}`.", value !== undefined, {
        name: name
      });
    };
    var validateParameterRange = function(value, name, minimum, maximum) {
      validate("E_PAR_OUT_OF_RANGE", "Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].", value === undefined || value >= minimum && value <= maximum, {
        maximum: maximum,
        minimum: minimum,
        name: name,
        value: value
      });
    };
    var validateParameterType = function(value, name, check, expected) {
      validate("E_INVALID_PAR_TYPE", "Invalid `{name}` parameter ({value}). {expected} expected.", check, {
        expected: expected,
        name: name,
        value: value
      });
    };
    var validateParameterTypeLocale = function(value, name) {
      validateParameterType(value, name, value === undefined || typeof value === "string" || value instanceof Cldr, "String or Cldr instance");
    };
    var isPlainObject = function(obj) {
      return obj !== null && "" + obj === "[object Object]";
    };
    var validateParameterTypePlainObject = function(value, name) {
      validateParameterType(value, name, value === undefined || isPlainObject(value), "Plain Object");
    };
    var alwaysCldr = function(localeOrCldr) {
      return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr(localeOrCldr);
    };
    var regexpEscape = function(string) {
      return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    };
    var stringPad = function(str, count, right) {
      var length;
      if (typeof str !== "string") {
        str = String(str);
      }
      for (length = str.length; length < count; length += 1) {
        str = right ? str + "0" : "0" + str;
      }
      return str;
    };
    function validateLikelySubtags(cldr) {
      cldr.once("get", validateCldr);
      cldr.get("supplemental/likelySubtags");
    }
    function Globalize(locale) {
      if (!(this instanceof Globalize)) {
        return new Globalize(locale);
      }
      validateParameterPresence(locale, "locale");
      validateParameterTypeLocale(locale, "locale");
      this.cldr = alwaysCldr(locale);
      validateLikelySubtags(this.cldr);
    }
    Globalize.load = function() {
      Cldr.load.apply(Cldr, arguments);
    };
    Globalize.locale = function(locale) {
      validateParameterTypeLocale(locale, "locale");
      if (arguments.length) {
        this.cldr = alwaysCldr(locale);
        validateLikelySubtags(this.cldr);
      }
      return this.cldr;
    };
    Globalize._alwaysArray = alwaysArray;
    Globalize._createError = createError;
    Globalize._formatMessage = formatMessage;
    Globalize._isPlainObject = isPlainObject;
    Globalize._objectExtend = objectExtend;
    Globalize._regexpEscape = regexpEscape;
    Globalize._runtimeBind = runtimeBind;
    Globalize._stringPad = stringPad;
    Globalize._validate = validate;
    Globalize._validateCldr = validateCldr;
    Globalize._validateDefaultLocale = validateDefaultLocale;
    Globalize._validateParameterPresence = validateParameterPresence;
    Globalize._validateParameterRange = validateParameterRange;
    Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
    Globalize._validateParameterType = validateParameterType;
    return Globalize;
  });
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /**
 * CLDR JavaScript Library v0.5.1
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2019-01-21T13:43Z
 */
  /*!
 * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
  (function(root, factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = factory();
    } else {
      root.Cldr = factory();
    }
  })(this, function() {
    var arrayIsArray = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var pathNormalize = function(path, attributes) {
      if (arrayIsArray(path)) {
        path = path.join("/");
      }
      if (typeof path !== "string") {
        throw new Error('invalid path "' + path + '"');
      }
      path = path.replace(/^\//, "").replace(/^cldr\//, "");
      path = path.replace(/{[a-zA-Z]+}/g, function(name) {
        name = name.replace(/^{([^}]*)}$/, "$1");
        return attributes[name];
      });
      return path.split("/");
    };
    var arraySome = function(array, callback) {
      var i, length;
      if (array.some) {
        return array.some(callback);
      }
      for (i = 0, length = array.length; i < length; i++) {
        if (callback(array[i], i, array)) {
          return true;
        }
      }
      return false;
    };
    var coreLikelySubtags = function(Cldr, cldr, subtags, options) {
      var match, matchFound, language = subtags[0], script = subtags[1], sep = Cldr.localeSep, territory = subtags[2], variants = subtags.slice(3, 4);
      options = options || {};
      if (language !== "und" && script !== "Zzzz" && territory !== "ZZ") {
        return [ language, script, territory ].concat(variants);
      }
      if (typeof cldr.get("supplemental/likelySubtags") === "undefined") {
        return;
      }
      matchFound = arraySome([ [ language, script, territory ], [ language, territory ], [ language, script ], [ language ], [ "und", script ] ], function(test) {
        return match = !/\b(Zzzz|ZZ)\b/.test(test.join(sep)) && cldr.get([ "supplemental/likelySubtags", test.join(sep) ]);
      });
      if (matchFound) {
        match = match.split(sep);
        return [ language !== "und" ? language : match[0], script !== "Zzzz" ? script : match[1], territory !== "ZZ" ? territory : match[2] ].concat(variants);
      } else if (options.force) {
        return cldr.get("supplemental/likelySubtags/und").split(sep);
      } else {
        return;
      }
    };
    var coreRemoveLikelySubtags = function(Cldr, cldr, maxLanguageId) {
      var match, matchFound, language = maxLanguageId[0], script = maxLanguageId[1], territory = maxLanguageId[2], variants = maxLanguageId[3];
      matchFound = arraySome([ [ [ language, "Zzzz", "ZZ" ], [ language ] ], [ [ language, "Zzzz", territory ], [ language, territory ] ], [ [ language, script, "ZZ" ], [ language, script ] ] ], function(test) {
        var result = coreLikelySubtags(Cldr, cldr, test[0]);
        match = test[1];
        return result && result[0] === maxLanguageId[0] && result[1] === maxLanguageId[1] && result[2] === maxLanguageId[2];
      });
      if (matchFound) {
        if (variants) {
          match.push(variants);
        }
        return match;
      }
      return maxLanguageId;
    };
    var coreSubtags = function(locale) {
      var aux, unicodeLanguageId, subtags = [];
      locale = locale.replace(/_/, "-");
      aux = locale.split("-u-");
      if (aux[1]) {
        aux[1] = aux[1].split("-t-");
        locale = aux[0] + (aux[1][1] ? "-t-" + aux[1][1] : "");
        subtags[4] = aux[1][0];
      }
      unicodeLanguageId = locale.split("-t-")[0];
      aux = unicodeLanguageId.match(/^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/);
      if (aux === null) {
        return [ "und", "Zzzz", "ZZ" ];
      }
      subtags[0] = aux[10] || aux[2] || "und";
      subtags[1] = aux[4] || "Zzzz";
      subtags[2] = aux[6] || "ZZ";
      if (aux[7] && aux[7].length) {
        subtags[3] = aux[7].slice(1);
      }
      return subtags;
    };
    var arrayForEach = function(array, callback) {
      var i, length;
      if (array.forEach) {
        return array.forEach(callback);
      }
      for (i = 0, length = array.length; i < length; i++) {
        callback(array[i], i, array);
      }
    };
    var bundleLookup = function(Cldr, cldr, minLanguageId) {
      var availableBundleMap = Cldr._availableBundleMap, availableBundleMapQueue = Cldr._availableBundleMapQueue;
      if (availableBundleMapQueue.length) {
        arrayForEach(availableBundleMapQueue, function(bundle) {
          var existing, maxBundle, minBundle, subtags;
          subtags = coreSubtags(bundle);
          maxBundle = coreLikelySubtags(Cldr, cldr, subtags);
          minBundle = coreRemoveLikelySubtags(Cldr, cldr, maxBundle);
          minBundle = minBundle.join(Cldr.localeSep);
          existing = availableBundleMap[minBundle];
          if (existing && existing.length < bundle.length) {
            return;
          }
          availableBundleMap[minBundle] = bundle;
        });
        Cldr._availableBundleMapQueue = [];
      }
      return availableBundleMap[minLanguageId] || null;
    };
    var objectKeys = function(object) {
      var i, result = [];
      if (Object.keys) {
        return Object.keys(object);
      }
      for (i in object) {
        result.push(i);
      }
      return result;
    };
    var createError = function(code, attributes) {
      var error, message;
      message = code + (attributes && JSON ? ": " + JSON.stringify(attributes) : "");
      error = new Error(message);
      error.code = code;
      arrayForEach(objectKeys(attributes), function(attribute) {
        error[attribute] = attributes[attribute];
      });
      return error;
    };
    var validate = function(code, check, attributes) {
      if (!check) {
        throw createError(code, attributes);
      }
    };
    var validatePresence = function(value, name) {
      validate("E_MISSING_PARAMETER", typeof value !== "undefined", {
        name: name
      });
    };
    var validateType = function(value, name, check, expected) {
      validate("E_INVALID_PAR_TYPE", check, {
        expected: expected,
        name: name,
        value: value
      });
    };
    var validateTypePath = function(value, name) {
      validateType(value, name, typeof value === "string" || arrayIsArray(value), "String or Array");
    };
    var isPlainObject = function(obj) {
      return obj !== null && "" + obj === "[object Object]";
    };
    var validateTypePlainObject = function(value, name) {
      validateType(value, name, typeof value === "undefined" || isPlainObject(value), "Plain Object");
    };
    var validateTypeString = function(value, name) {
      validateType(value, name, typeof value === "string", "a string");
    };
    var resourceGet = function(data, path) {
      var i, node = data, length = path.length;
      for (i = 0; i < length - 1; i++) {
        node = node[path[i]];
        if (!node) {
          return undefined;
        }
      }
      return node[path[i]];
    };
    var coreSetAvailableBundles = function(Cldr, json) {
      var bundle, availableBundleMapQueue = Cldr._availableBundleMapQueue, main = resourceGet(json, [ "main" ]);
      if (main) {
        for (bundle in main) {
          if (main.hasOwnProperty(bundle) && bundle !== "root" && availableBundleMapQueue.indexOf(bundle) === -1) {
            availableBundleMapQueue.push(bundle);
          }
        }
      }
    };
    var alwaysArray = function(somethingOrArray) {
      return arrayIsArray(somethingOrArray) ? somethingOrArray : [ somethingOrArray ];
    };
    var jsonMerge = function() {
      var merge = function() {
        var destination = {}, sources = [].slice.call(arguments, 0);
        arrayForEach(sources, function(source) {
          var prop;
          for (prop in source) {
            if (prop in destination && typeof destination[prop] === "object" && !arrayIsArray(destination[prop])) {
              destination[prop] = merge(destination[prop], source[prop]);
            } else {
              destination[prop] = source[prop];
            }
          }
        });
        return destination;
      };
      return merge;
    }();
    var coreLoad = function(Cldr, source, jsons) {
      var i, j, json;
      validatePresence(jsons[0], "json");
      for (i = 0; i < jsons.length; i++) {
        json = alwaysArray(jsons[i]);
        for (j = 0; j < json.length; j++) {
          validateTypePlainObject(json[j], "json");
          source = jsonMerge(source, json[j]);
          coreSetAvailableBundles(Cldr, json[j]);
        }
      }
      return source;
    };
    var itemGetResolved = function(Cldr, path, attributes) {
      var normalizedPath = pathNormalize(path, attributes);
      return resourceGet(Cldr._resolved, normalizedPath);
    };
    var Cldr = function(locale) {
      this.init(locale);
    };
    Cldr._alwaysArray = alwaysArray;
    Cldr._coreLoad = coreLoad;
    Cldr._createError = createError;
    Cldr._itemGetResolved = itemGetResolved;
    Cldr._jsonMerge = jsonMerge;
    Cldr._pathNormalize = pathNormalize;
    Cldr._resourceGet = resourceGet;
    Cldr._validatePresence = validatePresence;
    Cldr._validateType = validateType;
    Cldr._validateTypePath = validateTypePath;
    Cldr._validateTypePlainObject = validateTypePlainObject;
    Cldr._availableBundleMap = {};
    Cldr._availableBundleMapQueue = [];
    Cldr._resolved = {};
    Cldr.localeSep = "-";
    Cldr.load = function() {
      Cldr._resolved = coreLoad(Cldr, Cldr._resolved, arguments);
    };
    Cldr.prototype.init = function(locale) {
      var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant, sep = Cldr.localeSep, unicodeLocaleExtensionsRaw = "";
      validatePresence(locale, "locale");
      validateTypeString(locale, "locale");
      subtags = coreSubtags(locale);
      if (subtags.length === 5) {
        unicodeLocaleExtensions = subtags.pop();
        unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
        if (!subtags[3]) {
          subtags.pop();
        }
      }
      variant = subtags[3];
      maxLanguageId = coreLikelySubtags(Cldr, this, subtags, {
        force: true
      }) || subtags;
      language = maxLanguageId[0];
      script = maxLanguageId[1];
      territory = maxLanguageId[2];
      minLanguageId = coreRemoveLikelySubtags(Cldr, this, maxLanguageId).join(sep);
      this.attributes = attributes = {
        bundle: bundleLookup(Cldr, this, minLanguageId),
        minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
        maxLanguageId: maxLanguageId.join(sep) + unicodeLocaleExtensionsRaw,
        language: language,
        script: script,
        territory: territory,
        region: territory,
        variant: variant
      };
      unicodeLocaleExtensions && ("-" + unicodeLocaleExtensions).replace(/-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function(attribute, key, type) {
        if (key) {
          attributes["u" + key] = type;
        } else {
          attributes["u" + attribute] = true;
        }
      });
      this.locale = locale;
    };
    Cldr.prototype.get = function(path) {
      validatePresence(path, "path");
      validateTypePath(path, "path");
      return itemGetResolved(Cldr, path, this.attributes);
    };
    Cldr.prototype.main = function(path) {
      validatePresence(path, "path");
      validateTypePath(path, "path");
      validate("E_MISSING_BUNDLE", this.attributes.bundle !== null, {
        locale: this.locale
      });
      path = alwaysArray(path);
      return this.get([ "main/{bundle}" ].concat(path));
    };
    return Cldr;
  });
}, function(module, exports, __webpack_require__) {
  /**
 * CLDR JavaScript Library v0.5.1
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2019-01-21T13:43Z
 */
  /*!
 * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
  module.exports = __webpack_require__(4);
  __webpack_require__(27);
  __webpack_require__(28);
  __webpack_require__(29);
}, function(module, exports, __webpack_require__) {
  (function($) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var getLocaleData, loadLocaleData;
      loadLocaleData = function() {
        var settings;
        settings = __webpack_require__(2);
        if (!settings.LOCALE) {
          throw new Error("Current locale is undefined");
        }
        return $.getJSON(settings.API_URL + "/locale/" + settings.LOCALE + "/dictionary.json").done(function(localeData) {
          return window.OW.localeData = localeData;
        });
      };
      getLocaleData = function() {
        var localeData;
        localeData = window.OW.localeData;
        localeData.webbank[""]["plural_forms"] = localeData.webbank[""]["Plural-Forms"];
        return {
          locale_data: localeData,
          domain: "webbank"
        };
      };
      return {
        loadLocaleData: loadLocaleData,
        getLocaleData: getLocaleData
      };
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
  (function(module) {
    var require;
    (function(global, factory) {
      true ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(this, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (obj.hasOwnProperty(k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this);
          var len = t.length >>> 0;
          for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          var parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [];
      function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
          to._i = from._i;
        }
        if (!isUndefined(from._f)) {
          to._f = from._f;
        }
        if (!isUndefined(from._l)) {
          to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }
        return to;
      }
      var updateInProgress = false;
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (var key in arguments[0]) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now) : output;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
          return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
          return val.slice(1);
        });
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d";
      var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
          units.push({
            unit: u,
            priority: priorities[u]
          });
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
      var formatFunctions = {};
      var formatTokenFunctions = {};
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token) {
          formatTokenFunctions[token] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i;
          for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format;
      }
      var match1 = /\d/;
      var match2 = /\d\d/;
      var match3 = /\d{3}/;
      var match4 = /\d{4}/;
      var match6 = /[+-]?\d{6}/;
      var match1to2 = /\d\d?/;
      var match3to4 = /\d\d\d\d?/;
      var match5to6 = /\d\d\d\d\d\d?/;
      var match1to3 = /\d{1,3}/;
      var match1to4 = /\d{1,4}/;
      var match1to6 = /[+-]?\d{1,6}/;
      var matchUnsigned = /\d+/;
      var matchSigned = /[+-]?\d+/;
      var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
      var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
      var regexes = {};
      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
          token = [ token ];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
        }
      }
      function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }
      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }
      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? "" + y : "+" + y;
      });
      addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, [ "YYYY", 4 ], 0, "year");
      addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
      addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units);
          for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
      });
      addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
      });
      addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
      function localeMonths(m, format) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
      }
      var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
      function localeMonthsShort(m, format) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([ 2e3, i ]);
            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([ 2e3, i ]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      var defaultMonthsRegex = matchWord;
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([ 2e3, i ]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date;
        if (y < 100 && y >= 0) {
          var args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", [ "ww", 2 ], "wo", "week");
      addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
      });
      addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
      });
      addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
      });
      addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
      });
      function parseWeekday(input, locale) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale) {
        if (typeof input === "string") {
          return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
      function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([ 2e3, 1 ]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([ 2e3, 1 ]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([ 2e3, 1 ]).day(i);
          minp = this.weekdaysMin(mom, "");
          shortp = this.weekdaysShort(mom, "");
          longp = this.weekdays(mom, "");
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", [ "HH", 2 ], 0, "hour");
      addFormatToken("h", [ "hh", 2 ], 0, hFormat);
      addFormatToken("k", [ "kk", 2 ], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken([ "H", "HH" ], HOUR);
      addParseToken([ "k", "kk" ], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var getSetHour = makeGetSet("Hours", true);
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {};
      var localeFamilies = {};
      var globalLocale;
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join("-"));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            !function webpackMissingModule() {
              var e = new Error('Cannot find module "./locale"');
              e.code = "MODULE_NOT_FOUND";
              throw e;
            }();
            getSetGlobalLocale(oldLocale);
          } catch (e) {}
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale = loadLocale(config.parentLocale);
              if (locale != null) {
                parentConfig = locale._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name,
                  config: config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale, tmpLocale, parentConfig = baseConfig;
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          locale = new Locale(config);
          locale.parentLocale = locales[name];
          locales[name] = locale;
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [ key ];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ];
        }
        return [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          var curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
      var isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, false ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, false ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, false ], [ "YYYYDDD", /\d{7}/ ] ];
      var isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ];
      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [ untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10) ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10);
          var m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
          var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        hooks.createFromInputFallback(config);
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged and will be removed in an upcoming major release. Please refer to " + "http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      hooks.ISO_8601 = function() {};
      hooks.RFC_2822 = function() {};
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
          return hour;
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (!isValid(tempConfig)) {
            continue;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = undefined;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format === undefined && input === "") {
          return createInvalid({
            nullInput: true
          });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      });
      var prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
      function isDurationValid(m) {
        for (var key in m) {
          if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
          var offset = this.utcOffset();
          var sign = "+";
          if (offset < 0) {
            offset = -offset;
            sign = "-";
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher);
        if (matches === null) {
          return null;
        }
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
      }
      function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }
      hooks.updateOffset = function() {};
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
      var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input)) {
          duration = {};
          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign
          };
        } else if (!!(match = isoRegex.exec(input))) {
          sign = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return {
            milliseconds: 0,
            months: 0
          };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          val = typeof val === "string" ? +val : val;
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
          setMonth(mom, get(mom, "Month") + months * isAdding);
        }
        if (days) {
          set$1(mom, "Date", get(mom, "Date") + days * isAdding);
        }
        if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days || months);
        }
      }
      var add = createAdder(1, "add");
      var subtract = createAdder(-1, "subtract");
      function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", true);
        return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse";
        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
         case "year":
          output = monthDiff(this, that) / 12;
          break;

         case "month":
          output = monthDiff(this, that);
          break;

         case "quarter":
          output = monthDiff(this, that) / 3;
          break;

         case "second":
          output = (this - that) / 1e3;
          break;

         case "minute":
          output = (this - that) / 6e4;
          break;

         case "hour":
          output = (this - that) / 36e5;
          break;

         case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;

         case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;

         default:
          output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment";
        var zone = "";
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        var prefix = "[" + func + '("]';
        var year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        var datetime = "-MM-DD[T]HH:mm:ss.SSS";
        var suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            from: this,
            to: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3;
      var MS_PER_MINUTE = 60 * MS_PER_SECOND;
      var MS_PER_HOUR = 60 * MS_PER_MINUTE;
      var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond" || !this.isValid()) {
          return this;
        }
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
         case "year":
          time = startOfDate(this.year(), 0, 1);
          break;

         case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

         case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;

         case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

         case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

         case "day":
         case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;

         case "hour":
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

         case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

         case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond" || !this.isValid()) {
          return this;
        }
        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
         case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

         case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

         case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

         case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

         case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

         case "day":
         case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

         case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

         case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

         case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", [ "DD", 2 ], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
      });
      addParseToken([ "D", "DD" ], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", [ "mm", 2 ], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken([ "m", "mm" ], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", [ "ss", 2 ], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken([ "s", "ss" ], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
      addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      var getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
      }
      function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }
        format = format || "";
        if (index != null) {
          return get$1(format, index, field, "month");
        }
        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || "";
        } else {
          format = localeSorted;
          index = format;
          localeSorted = false;
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || "";
        }
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (index != null) {
          return get$1(format, (index + shift) % 7, field, "day");
        }
        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
      }
      function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
      }
      function daysToMonths(days) {
        return days * 4800 / 146097;
      }
      function monthsToDays(months) {
        return months * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          switch (units) {
           case "month":
            return months;

           case "quarter":
            return months / 3;

           case "year":
            return months / 12;
          }
        } else {
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
           case "week":
            return days / 7 + milliseconds / 6048e5;

           case "day":
            return days + milliseconds / 864e5;

           case "hour":
            return days * 24 + milliseconds / 36e5;

           case "minute":
            return days * 1440 + milliseconds / 6e4;

           case "second":
            return days * 86400 + milliseconds / 1e3;

           case "millisecond":
            return Math.floor(days * 864e5) + milliseconds;

           default:
            throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms");
      var asSeconds = makeAs("s");
      var asMinutes = makeAs("m");
      var asHours = makeAs("h");
      var asDays = makeAs("d");
      var asWeeks = makeAs("w");
      var asMonths = makeAs("M");
      var asQuarters = makeAs("Q");
      var asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds");
      var seconds = makeGetter("seconds");
      var minutes = makeGetter("minutes");
      var hours = makeGetter("hours");
      var days = makeGetter("days");
      var months = makeGetter("months");
      var years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round;
      var thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as("s"));
        var minutes = round(duration.as("m"));
        var hours = round(duration.as("h"));
        var days = round(duration.as("d"));
        var months = round(duration.as("M"));
        var years = round(duration.as("y"));
        var a = seconds <= thresholds.ss && [ "s", seconds ] || seconds < thresholds.s && [ "ss", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(withSuffix) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);
        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1e3;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
        var total = this.asSeconds();
        if (!total) {
          return "P0D";
        }
        var totalSign = total < 0 ? "-" : "";
        var ymSign = sign(this._months) !== sign(total) ? "-" : "";
        var daysSign = sign(this._days) !== sign(total) ? "-" : "";
        var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.24.0";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }).call(exports, __webpack_require__(11)(module));
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_RESULT__;
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
    var Cookies, exports;
    Cookies = __webpack_require__(12);
    __webpack_require__(13);
    exports = {};
    exports.get = function(key) {
      var value;
      if (value = Cookies.get(key)) {
        return value;
      } else if (Modernizr.localstorage) {
        return window.localStorage.getItem(key);
      }
    };
    exports.set = function(key, value, options) {
      var defaultPath;
      if (options == null) {
        options = {};
      }
      defaultPath = "/";
      if (window.location.pathname !== defaultPath) {
        defaultPath = window.location.pathname.replace(/(?!^)\/.*/, "");
      }
      Cookies.set(key, value, {
        expires: options.expires || 365,
        path: options.path || defaultPath
      });
      if (Modernizr.localstorage) {
        return window.localStorage.setItem(key, value);
      }
    };
    exports.remove = function(key, options) {
      var defaultPath;
      if (options == null) {
        options = {};
      }
      if (window.location.pathname !== defaultPath) {
        defaultPath = window.location.pathname.replace(/(?!^)\/.*/, "");
      }
      Cookies.remove(key, {
        path: options.path || defaultPath
      });
      if (Modernizr.localstorage) {
        return window.localStorage.removeItem(key);
      }
    };
    exports.clear = function(options) {
      var cookie, cookies, eqPos, j, len, name;
      if (options == null) {
        options = {};
      }
      cookies = document.cookie.split(";");
      for (j = 0, len = cookies.length; j < len; j++) {
        cookie = cookies[j];
        eqPos = cookie.indexOf("=");
        name = (eqPos > -1 ? cookie.substr(0, eqPos) : cookie).trim();
        if (!name) {
          continue;
        }
        exports.remove(name, options);
      }
      if (Modernizr.localstorage) {
        return window.localStorage.clear();
      }
    };
    exports.getAll = function() {
      var cookie, cookies, eqPos, i, j, k, len, name, ref, result;
      result = {};
      cookies = document.cookie.split(";");
      for (j = 0, len = cookies.length; j < len; j++) {
        cookie = cookies[j];
        eqPos = cookie.indexOf("=");
        name = (eqPos > -1 ? cookie.substr(0, eqPos) : cookie).trim();
        if (!name) {
          continue;
        }
        result[name] = Cookies.get(name);
      }
      if (Modernizr.localstorage) {
        for (i = k = 0, ref = window.localStorage.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          name = window.localStorage.key(i);
          result[name] = window.localStorage.getItem(name);
        }
      }
      return result;
    };
    return window.store = exports;
  }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}, function(module, exports, __webpack_require__) {
  (function($, _) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item) return i;
      }
      return -1;
    }, slice = [].slice;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var configLoadFunc, loadCasheableConfig, loadConfig, loadUncacheableConfig, nonCacheableConfigs, requireConfig;
      nonCacheableConfigs = [];
      configLoadFunc = function(url) {
        return $.ajax(url, {
          dataType: "text",
          error: function(xhr) {
            return xhr.errorHandled = true;
          }
        }).then(function(script) {
          return eval(script);
        });
      };
      loadCasheableConfig = _.memoize(configLoadFunc);
      loadUncacheableConfig = configLoadFunc;
      loadConfig = function(url) {
        var configName;
        configName = _.last(url.split("/"));
        if (indexOf.call(nonCacheableConfigs, configName) >= 0) {
          return loadUncacheableConfig(url);
        } else {
          return loadCasheableConfig(url);
        }
      };
      requireConfig = function(deps, callback, errback) {
        var loadPromises;
        if (errback == null) {
          errback = function() {
            var args, ref, response, xhr;
            xhr = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (xhr.status === 410) {
              response = JSON.parse(xhr.responseText);
              if (response._status === "error" && ((ref = response._error) != null ? ref.code : void 0) === "UPGRADE_REQUIRED") {
                return window.updateRequired = true;
              }
            }
            return window.networkError = true;
          };
        }
        if (!_.isArray(deps)) {
          deps = [ deps ];
        }
        loadPromises = _.map(deps, function(dep) {
          return loadConfig(dep).fail(function() {
            return console.warn("Could not load config: " + dep);
          });
        });
        return $.when.apply($, loadPromises).fail(errback).done(callback);
      };
      requireConfig.loadConfig = loadConfig;
      return requireConfig;
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(1), __webpack_require__(0));
}, function(module, exports) {
  var g;
  g = function() {
    return this;
  }();
  try {
    g = g || Function("return this")() || (1, eval)("this");
  } catch (e) {
    if (typeof window === "object") g = window;
  }
  module.exports = g;
}, function(module, exports) {
  module.exports = function(module) {
    if (!module.webpackPolyfill) {
      module.deprecate = function() {};
      module.paths = [];
      if (!module.children) module.children = [];
      Object.defineProperty(module, "loaded", {
        enumerable: true,
        get: function() {
          return module.l;
        }
      });
      Object.defineProperty(module, "id", {
        enumerable: true,
        get: function() {
          return module.i;
        }
      });
      module.webpackPolyfill = 1;
    }
    return module;
  };
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
  (function(factory) {
    var registeredInModuleLoader = false;
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      registeredInModuleLoader = true;
    }
    if (true) {
      module.exports = factory();
      registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
      var OldCookies = window.Cookies;
      var api = window.Cookies = factory();
      api.noConflict = function() {
        window.Cookies = OldCookies;
        return api;
      };
    }
  })(function() {
    function extend() {
      var i = 0;
      var result = {};
      for (;i < arguments.length; i++) {
        var attributes = arguments[i];
        for (var key in attributes) {
          result[key] = attributes[key];
        }
      }
      return result;
    }
    function init(converter) {
      function api(key, value, attributes) {
        var result;
        if (typeof document === "undefined") {
          return;
        }
        if (arguments.length > 1) {
          attributes = extend({
            path: "/"
          }, api.defaults, attributes);
          if (typeof attributes.expires === "number") {
            var expires = new Date();
            expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e5);
            attributes.expires = expires;
          }
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
          try {
            result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}
          if (!converter.write) {
            value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          } else {
            value = converter.write(value, key);
          }
          key = encodeURIComponent(String(key));
          key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
          key = key.replace(/[\(\)]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes[attributeName];
          }
          return document.cookie = key + "=" + value + stringifiedAttributes;
        }
        if (!key) {
          result = {};
        }
        var cookies = document.cookie ? document.cookie.split("; ") : [];
        var rdecode = /(%[0-9A-Z]{2})+/g;
        var i = 0;
        for (;i < cookies.length; i++) {
          var parts = cookies[i].split("=");
          var cookie = parts.slice(1).join("=");
          if (!this.json && cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
          }
          try {
            var name = parts[0].replace(rdecode, decodeURIComponent);
            cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);
            if (this.json) {
              try {
                cookie = JSON.parse(cookie);
              } catch (e) {}
            }
            if (key === name) {
              result = cookie;
              break;
            }
            if (!key) {
              result[name] = cookie;
            }
          } catch (e) {}
        }
        return result;
      }
      api.set = api;
      api.get = function(key) {
        return api.call(api, key);
      };
      api.getJSON = function() {
        return api.apply({
          json: true
        }, [].slice.call(arguments));
      };
      api.defaults = {};
      api.remove = function(key, attributes) {
        api(key, "", extend(attributes, {
          expires: -1
        }));
      };
      api.withConverter = init;
      return api;
    }
    return init(function() {});
  });
}, function(module, exports) {
  (function() {
    window.Modernizr = function(window, document, undefined) {
      var version = "2.6.2", Modernizr = {}, enableClasses = true, docElement = document.documentElement, mod = "modernizr", modElem = document.createElement(mod), mStyle = modElem.style, inputElem = document.createElement("input"), smile = ":)", toString = {}.toString, prefixes = " -webkit- -moz- -o- -ms- ".split(" "), omPrefixes = "Webkit Moz O ms", cssomPrefixes = omPrefixes.split(" "), domPrefixes = omPrefixes.toLowerCase().split(" "), ns = {
        svg: "http://www.w3.org/2000/svg"
      }, tests = {}, inputs = {}, attrs = {}, classes = [], slice = classes.slice, featureName, injectElementWithStyles = function(rule, callback, nodes, testnames) {
        var style, ret, node, docOverflow, div = document.createElement("div"), body = document.body, fakeBody = body || document.createElement("body");
        if (parseInt(nodes, 10)) {
          while (nodes--) {
            node = document.createElement("div");
            node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
            div.appendChild(node);
          }
        }
        style = [ "&#173;", '<style id="s', mod, '">', rule, "</style>" ].join("");
        div.id = mod;
        (body ? div : fakeBody).innerHTML += style;
        fakeBody.appendChild(div);
        if (!body) {
          fakeBody.style.background = "";
          fakeBody.style.overflow = "hidden";
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = "hidden";
          docElement.appendChild(fakeBody);
        }
        ret = callback(div, rule);
        if (!body) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
        } else {
          div.parentNode.removeChild(div);
        }
        return !!ret;
      }, isEventSupported = function() {
        var TAGNAMES = {
          select: "input",
          change: "input",
          submit: "form",
          reset: "form",
          error: "img",
          load: "img",
          abort: "img"
        };
        function isEventSupported(eventName, element) {
          element = element || document.createElement(TAGNAMES[eventName] || "div");
          eventName = "on" + eventName;
          var isSupported = eventName in element;
          if (!isSupported) {
            if (!element.setAttribute) {
              element = document.createElement("div");
            }
            if (element.setAttribute && element.removeAttribute) {
              element.setAttribute(eventName, "");
              isSupported = is(element[eventName], "function");
              if (!is(element[eventName], "undefined")) {
                element[eventName] = undefined;
              }
              element.removeAttribute(eventName);
            }
          }
          element = null;
          return isSupported;
        }
        return isEventSupported;
      }(), _hasOwnProperty = {}.hasOwnProperty, hasOwnProp;
      if (!is(_hasOwnProperty, "undefined") && !is(_hasOwnProperty.call, "undefined")) {
        hasOwnProp = function(object, property) {
          return _hasOwnProperty.call(object, property);
        };
      } else {
        hasOwnProp = function(object, property) {
          return property in object && is(object.constructor.prototype[property], "undefined");
        };
      }
      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          var target = this;
          if (typeof target != "function") {
            throw new TypeError();
          }
          var args = slice.call(arguments, 1), bound = function() {
            if (this instanceof bound) {
              var F = function() {};
              F.prototype = target.prototype;
              var self = new F();
              var result = target.apply(self, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return self;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          return bound;
        };
      }
      function setCss(str) {
        mStyle.cssText = str;
      }
      function setCssAll(str1, str2) {
        return setCss(prefixes.join(str1 + ";") + (str2 || ""));
      }
      function is(obj, type) {
        return typeof obj === type;
      }
      function contains(str, substr) {
        return !!~("" + str).indexOf(substr);
      }
      function testProps(props, prefixed) {
        for (var i in props) {
          var prop = props[i];
          if (!contains(prop, "-") && mStyle[prop] !== undefined) {
            return prefixed == "pfx" ? prop : true;
          }
        }
        return false;
      }
      function testDOMProps(props, obj, elem) {
        for (var i in props) {
          var item = obj[props[i]];
          if (item !== undefined) {
            if (elem === false) return props[i];
            if (is(item, "function")) {
              return item.bind(elem || obj);
            }
            return item;
          }
        }
        return false;
      }
      function testPropsAll(prop, prefixed, elem) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
        if (is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);
        } else {
          props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" ");
          return testDOMProps(props, prefixed, elem);
        }
      }
      tests["flexbox"] = function() {
        return testPropsAll("flexWrap");
      };
      tests["canvas"] = function() {
        var elem = document.createElement("canvas");
        return !!(elem.getContext && elem.getContext("2d"));
      };
      tests["canvastext"] = function() {
        return !!(Modernizr["canvas"] && is(document.createElement("canvas").getContext("2d").fillText, "function"));
      };
      tests["webgl"] = function() {
        return !!window.WebGLRenderingContext;
      };
      tests["touch"] = function() {
        var bool;
        if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles([ "@media (", prefixes.join("touch-enabled),("), mod, ")", "{#modernizr{top:9px;position:absolute}}" ].join(""), function(node) {
            bool = node.offsetTop === 9;
          });
        }
        return bool;
      };
      tests["geolocation"] = function() {
        return "geolocation" in navigator;
      };
      tests["postmessage"] = function() {
        return !!window.postMessage;
      };
      tests["websqldatabase"] = function() {
        return !!window.openDatabase;
      };
      tests["indexedDB"] = function() {
        return !!testPropsAll("indexedDB", window);
      };
      tests["hashchange"] = function() {
        return isEventSupported("hashchange", window) && (document.documentMode === undefined || document.documentMode > 7);
      };
      tests["history"] = function() {
        return !!(window.history && history.pushState);
      };
      tests["draganddrop"] = function() {
        var div = document.createElement("div");
        return "draggable" in div || "ondragstart" in div && "ondrop" in div;
      };
      tests["websockets"] = function() {
        return "WebSocket" in window || "MozWebSocket" in window;
      };
      tests["rgba"] = function() {
        setCss("background-color:rgba(150,255,150,.5)");
        return contains(mStyle.backgroundColor, "rgba");
      };
      tests["hsla"] = function() {
        setCss("background-color:hsla(120,40%,100%,.5)");
        return contains(mStyle.backgroundColor, "rgba") || contains(mStyle.backgroundColor, "hsla");
      };
      tests["multiplebgs"] = function() {
        setCss("background:url(https://),url(https://),red url(https://)");
        return /(url\s*\(.*?){3}/.test(mStyle.background);
      };
      tests["backgroundsize"] = function() {
        return testPropsAll("backgroundSize");
      };
      tests["borderimage"] = function() {
        return testPropsAll("borderImage");
      };
      tests["borderradius"] = function() {
        return testPropsAll("borderRadius");
      };
      tests["boxshadow"] = function() {
        return testPropsAll("boxShadow");
      };
      tests["textshadow"] = function() {
        return document.createElement("div").style.textShadow === "";
      };
      tests["opacity"] = function() {
        setCssAll("opacity:.55");
        return /^0.55$/.test(mStyle.opacity);
      };
      tests["cssanimations"] = function() {
        return testPropsAll("animationName");
      };
      tests["csscolumns"] = function() {
        return testPropsAll("columnCount");
      };
      tests["cssgradients"] = function() {
        var str1 = "background-image:", str2 = "gradient(linear,left top,right bottom,from(#9f9),to(white));", str3 = "linear-gradient(left top,#9f9, white);";
        setCss((str1 + "-webkit- ".split(" ").join(str2 + str1) + prefixes.join(str3 + str1)).slice(0, -str1.length));
        return contains(mStyle.backgroundImage, "gradient");
      };
      tests["cssreflections"] = function() {
        return testPropsAll("boxReflect");
      };
      tests["csstransforms"] = function() {
        return !!testPropsAll("transform");
      };
      tests["csstransforms3d"] = function() {
        var ret = !!testPropsAll("perspective");
        if (ret && "webkitPerspective" in docElement.style) {
          injectElementWithStyles("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}", function(node, rule) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
      };
      tests["csstransitions"] = function() {
        return testPropsAll("transition");
      };
      tests["fontface"] = function() {
        var bool;
        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function(node, rule) {
          var style = document.getElementById("smodernizr"), sheet = style.sheet || style.styleSheet, cssText = sheet ? sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || "" : "";
          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(" ")[0]) === 0;
        });
        return bool;
      };
      tests["generatedcontent"] = function() {
        var bool;
        injectElementWithStyles([ "#", mod, "{font:0/0 a}#", mod, ':after{content:"', smile, '";visibility:hidden;font:3px/1 a}' ].join(""), function(node) {
          bool = node.offsetHeight >= 3;
        });
        return bool;
      };
      tests["video"] = function() {
        var elem = document.createElement("video"), bool = false;
        try {
          if (bool = !!elem.canPlayType) {
            bool = new Boolean(bool);
            bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "");
            bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "");
            bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "");
          }
        } catch (e) {}
        return bool;
      };
      tests["audio"] = function() {
        var elem = document.createElement("audio"), bool = false;
        try {
          if (bool = !!elem.canPlayType) {
            bool = new Boolean(bool);
            bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "");
            bool.mp3 = elem.canPlayType("audio/mpeg;").replace(/^no$/, "");
            bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "");
            bool.m4a = (elem.canPlayType("audio/x-m4a;") || elem.canPlayType("audio/aac;")).replace(/^no$/, "");
          }
        } catch (e) {}
        return bool;
      };
      tests["localstorage"] = function() {
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
      };
      tests["sessionstorage"] = function() {
        try {
          sessionStorage.setItem(mod, mod);
          sessionStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
      };
      tests["webworkers"] = function() {
        return !!window.Worker;
      };
      tests["applicationcache"] = function() {
        return !!window.applicationCache;
      };
      tests["svg"] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, "svg").createSVGRect;
      };
      tests["inlinesvg"] = function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
      };
      tests["smil"] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, "animate")));
      };
      tests["svgclippaths"] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, "clipPath")));
      };
      function webforms() {
        Modernizr["input"] = function(props) {
          for (var i = 0, len = props.length; i < len; i++) {
            attrs[props[i]] = !!(props[i] in inputElem);
          }
          if (attrs.list) {
            attrs.list = !!(document.createElement("datalist") && window.HTMLDataListElement);
          }
          return attrs;
        }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" "));
        Modernizr["inputtypes"] = function(props) {
          for (var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++) {
            inputElem.setAttribute("type", inputElemType = props[i]);
            bool = inputElem.type !== "text";
            if (bool) {
              inputElem.value = smile;
              inputElem.style.cssText = "position:absolute;visibility:hidden;";
              if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {
                docElement.appendChild(inputElem);
                defaultView = document.defaultView;
                bool = defaultView.getComputedStyle && defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== "textfield" && inputElem.offsetHeight !== 0;
                docElement.removeChild(inputElem);
              } else if (/^(search|tel)$/.test(inputElemType)) {} else if (/^(url|email)$/.test(inputElemType)) {
                bool = inputElem.checkValidity && inputElem.checkValidity() === false;
              } else {
                bool = inputElem.value != smile;
              }
            }
            inputs[props[i]] = !!bool;
          }
          return inputs;
        }("search tel url email datetime date month week time datetime-local number range color".split(" "));
      }
      for (var feature in tests) {
        if (hasOwnProp(tests, feature)) {
          featureName = feature.toLowerCase();
          Modernizr[featureName] = tests[feature]();
          classes.push((Modernizr[featureName] ? "" : "no-") + featureName);
        }
      }
      Modernizr.input || webforms();
      Modernizr.addTest = function(feature, test) {
        if (typeof feature == "object") {
          for (var key in feature) {
            if (hasOwnProp(feature, key)) {
              Modernizr.addTest(key, feature[key]);
            }
          }
        } else {
          feature = feature.toLowerCase();
          if (Modernizr[feature] !== undefined) {
            return Modernizr;
          }
          test = typeof test == "function" ? test() : test;
          if (typeof enableClasses !== "undefined" && enableClasses) {
            docElement.className += " " + (test ? "" : "no-") + feature;
          }
          Modernizr[feature] = test;
        }
        return Modernizr;
      };
      setCss("");
      modElem = inputElem = null;
      (function(window, document) {
        var options = window.html5 || {};
        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
        var supportsHtml5Styles;
        var expando = "_html5shiv";
        var expanID = 0;
        var expandoData = {};
        var supportsUnknownElements;
        (function() {
          try {
            var a = document.createElement("a");
            a.innerHTML = "<xyz></xyz>";
            supportsHtml5Styles = "hidden" in a;
            supportsUnknownElements = a.childNodes.length == 1 || function() {
              document.createElement("a");
              var frag = document.createDocumentFragment();
              return typeof frag.cloneNode == "undefined" || typeof frag.createDocumentFragment == "undefined" || typeof frag.createElement == "undefined";
            }();
          } catch (e) {
            supportsHtml5Styles = true;
            supportsUnknownElements = true;
          }
        })();
        function addStyleSheet(ownerDocument, cssText) {
          var p = ownerDocument.createElement("p"), parent = ownerDocument.getElementsByTagName("head")[0] || ownerDocument.documentElement;
          p.innerHTML = "x<style>" + cssText + "</style>";
          return parent.insertBefore(p.lastChild, parent.firstChild);
        }
        function getElements() {
          var elements = html5.elements;
          return typeof elements == "string" ? elements.split(" ") : elements;
        }
        function getExpandoData(ownerDocument) {
          var data = expandoData[ownerDocument[expando]];
          if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
          }
          return data;
        }
        function createElement(nodeName, ownerDocument, data) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if (supportsUnknownElements) {
            return ownerDocument.createElement(nodeName);
          }
          if (!data) {
            data = getExpandoData(ownerDocument);
          }
          var node;
          if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
          } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
          } else {
            node = data.createElem(nodeName);
          }
          return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
        }
        function createDocumentFragment(ownerDocument, data) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if (supportsUnknownElements) {
            return ownerDocument.createDocumentFragment();
          }
          data = data || getExpandoData(ownerDocument);
          var clone = data.frag.cloneNode(), i = 0, elems = getElements(), l = elems.length;
          for (;i < l; i++) {
            clone.createElement(elems[i]);
          }
          return clone;
        }
        function shivMethods(ownerDocument, data) {
          if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
          }
          ownerDocument.createElement = function(nodeName) {
            if (!html5.shivMethods) {
              return data.createElem(nodeName);
            }
            return createElement(nodeName, ownerDocument, data);
          };
          ownerDocument.createDocumentFragment = Function("h,f", "return function(){" + "var n=f.cloneNode(),c=n.createElement;" + "h.shivMethods&&(" + getElements().join().replace(/\w+/g, function(nodeName) {
            data.createElem(nodeName);
            data.frag.createElement(nodeName);
            return 'c("' + nodeName + '")';
          }) + ");return n}")(html5, data.frag);
        }
        function shivDocument(ownerDocument) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          var data = getExpandoData(ownerDocument);
          if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
            data.hasCSS = !!addStyleSheet(ownerDocument, "article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}" + "mark{background:#FF0;color:#000}");
          }
          if (!supportsUnknownElements) {
            shivMethods(ownerDocument, data);
          }
          return ownerDocument;
        }
        var html5 = {
          elements: options.elements || "abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",
          shivCSS: options.shivCSS !== false,
          supportsUnknownElements: supportsUnknownElements,
          shivMethods: options.shivMethods !== false,
          type: "default",
          shivDocument: shivDocument,
          createElement: createElement,
          createDocumentFragment: createDocumentFragment
        };
        window.html5 = html5;
        shivDocument(document);
      })(this, document);
      Modernizr._version = version;
      Modernizr._prefixes = prefixes;
      Modernizr._domPrefixes = domPrefixes;
      Modernizr._cssomPrefixes = cssomPrefixes;
      Modernizr.hasEvent = isEventSupported;
      Modernizr.testProp = function(prop) {
        return testProps([ prop ]);
      };
      Modernizr.testAllProps = testPropsAll;
      Modernizr.testStyles = injectElementWithStyles;
      Modernizr.prefixed = function(prop, obj, elem) {
        if (!obj) {
          return testPropsAll(prop, "pfx");
        } else {
          return testPropsAll(prop, obj, elem);
        }
      };
      docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (enableClasses ? " js " + classes.join(" ") : "");
      return Modernizr;
    }(this, this.document);
    (function(a, b, c) {
      function d(a) {
        return "[object Function]" == o.call(a);
      }
      function e(a) {
        return "string" == typeof a;
      }
      function f() {}
      function g(a) {
        return !a || "loaded" == a || "complete" == a || "uninitialized" == a;
      }
      function h() {
        var a = p.shift();
        q = 1, a ? a.t ? m(function() {
          ("c" == a.t ? B.injectCss : B.injectJs)(a.s, 0, a.a, a.x, a.e, 1);
        }, 0) : (a(), h()) : q = 0;
      }
      function i(a, c, d, e, f, i, j) {
        function k(b) {
          if (!o && g(l.readyState) && (u.r = o = 1, !q && h(), l.onload = l.onreadystatechange = null, 
          b)) {
            "img" != a && m(function() {
              t.removeChild(l);
            }, 50);
            for (var d in y[c]) y[c].hasOwnProperty(d) && y[c][d].onload();
          }
        }
        var j = j || B.errorTimeout, l = b.createElement(a), o = 0, r = 0, u = {
          t: d,
          s: c,
          e: f,
          a: i,
          x: j
        };
        1 === y[c] && (r = 1, y[c] = []), "object" == a ? l.data = c : (l.src = c, l.type = a), 
        l.width = l.height = "0", l.onerror = l.onload = l.onreadystatechange = function() {
          k.call(this, r);
        }, p.splice(e, 0, u), "img" != a && (r || 2 === y[c] ? (t.insertBefore(l, s ? null : n), 
        m(k, j)) : y[c].push(l));
      }
      function j(a, b, c, d, f) {
        return q = 0, b = b || "j", e(a) ? i("c" == b ? v : u, a, b, this.i++, c, d, f) : (p.splice(this.i++, 0, a), 
        1 == p.length && h()), this;
      }
      function k() {
        var a = B;
        return a.loader = {
          load: j,
          i: 0
        }, a;
      }
      var l = b.documentElement, m = a.setTimeout, n = b.getElementsByTagName("script")[0], o = {}.toString, p = [], q = 0, r = "MozAppearance" in l.style, s = r && !!b.createRange().compareNode, t = s ? l : n.parentNode, l = a.opera && "[object Opera]" == o.call(a.opera), l = !!b.attachEvent && !l, u = r ? "object" : l ? "script" : "img", v = l ? "script" : u, w = Array.isArray || function(a) {
        return "[object Array]" == o.call(a);
      }, x = [], y = {}, z = {
        timeout: function(a, b) {
          return b.length && (a.timeout = b[0]), a;
        }
      }, A, B;
      B = function(a) {
        function b(a) {
          var a = a.split("!"), b = x.length, c = a.pop(), d = a.length, c = {
            url: c,
            origUrl: c,
            prefixes: a
          }, e, f, g;
          for (f = 0; f < d; f++) g = a[f].split("="), (e = z[g.shift()]) && (c = e(c, g));
          for (f = 0; f < b; f++) c = x[f](c);
          return c;
        }
        function g(a, e, f, g, h) {
          var i = b(a), j = i.autoCallback;
          i.url.split(".").pop().split("?").shift(), i.bypass || (e && (e = d(e) ? e : e[a] || e[g] || e[a.split("/").pop().split("?")[0]]), 
          i.instead ? i.instead(a, e, f, g, h) : (y[i.url] ? i.noexec = !0 : y[i.url] = 1, 
          f.load(i.url, i.forceCSS || !i.forceJS && "css" == i.url.split(".").pop().split("?").shift() ? "c" : c, i.noexec, i.attrs, i.timeout), 
          (d(e) || d(j)) && f.load(function() {
            k(), e && e(i.origUrl, h, g), j && j(i.origUrl, h, g), y[i.url] = 2;
          })));
        }
        function h(a, b) {
          function c(a, c) {
            if (a) {
              if (e(a)) c || (j = function() {
                var a = [].slice.call(arguments);
                k.apply(this, a), l();
              }), g(a, j, b, 0, h); else if (Object(a) === a) for (n in m = function() {
                var b = 0, c;
                for (c in a) a.hasOwnProperty(c) && b++;
                return b;
              }(), a) a.hasOwnProperty(n) && (!c && !--m && (d(j) ? j = function() {
                var a = [].slice.call(arguments);
                k.apply(this, a), l();
              } : j[n] = function(a) {
                return function() {
                  var b = [].slice.call(arguments);
                  a && a.apply(this, b), l();
                };
              }(k[n])), g(a[n], j, b, n, h));
            } else !c && l();
          }
          var h = !!a.test, i = a.load || a.both, j = a.callback || f, k = j, l = a.complete || f, m, n;
          c(h ? a.yep : a.nope, !!i), i && c(i);
        }
        var i, j, l = this.yepnope.loader;
        if (e(a)) g(a, 0, l, 0); else if (w(a)) for (i = 0; i < a.length; i++) j = a[i], 
        e(j) ? g(j, 0, l, 0) : w(j) ? B(j) : Object(j) === j && h(j, l); else Object(a) === a && h(a, l);
      }, B.addPrefix = function(a, b) {
        z[a] = b;
      }, B.addFilter = function(a) {
        x.push(a);
      }, B.errorTimeout = 1e4, null == b.readyState && b.addEventListener && (b.readyState = "loading", 
      b.addEventListener("DOMContentLoaded", A = function() {
        b.removeEventListener("DOMContentLoaded", A, 0), b.readyState = "complete";
      }, 0)), a.yepnope = k(), a.yepnope.executeStack = h, a.yepnope.injectJs = function(a, c, d, e, i, j) {
        var k = b.createElement("script"), l, o, e = e || B.errorTimeout;
        k.src = a;
        for (o in d) k.setAttribute(o, d[o]);
        c = j ? h : c || f, k.onreadystatechange = k.onload = function() {
          !l && g(k.readyState) && (l = 1, c(), k.onload = k.onreadystatechange = null);
        }, m(function() {
          l || (l = 1, c(1));
        }, e), i ? k.onload() : n.parentNode.insertBefore(k, n);
      }, a.yepnope.injectCss = function(a, c, d, e, g, i) {
        var e = b.createElement("link"), j, c = i ? h : c || f;
        e.href = a, e.rel = "stylesheet", e.type = "text/css";
        for (j in d) e.setAttribute(j, d[j]);
        g || (n.parentNode.insertBefore(e, n), m(c, 0));
      };
    })(this, document);
    Modernizr.load = function() {
      yepnope.apply(window, [].slice.call(arguments, 0));
    };
    module.exports = window.Modernizr;
  }).call(window);
}, function(module, exports, __webpack_require__) {
  var map = {
    "./en/ca-gregorian.json": 39,
    "./en/numbers.json": 40,
    "./ro/ca-gregorian.json": 41,
    "./ro/numbers.json": 42,
    "./ru/ca-gregorian.json": 43,
    "./ru/numbers.json": 44
  };
  function webpackContext(req) {
    return __webpack_require__(webpackContextResolve(req));
  }
  function webpackContextResolve(req) {
    var id = map[req];
    if (!(id + 1)) throw new Error("Cannot find module '" + req + "'.");
    return id;
  }
  webpackContext.keys = function webpackContextKeys() {
    return Object.keys(map);
  };
  webpackContext.resolve = webpackContextResolve;
  module.exports = webpackContext;
  webpackContext.id = 14;
}, function(module, exports) {
  var process = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = "browser";
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = "";
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  process.listeners = function(name) {
    return [];
  };
  process.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process.cwd = function() {
    return "/";
  };
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process.umask = function() {
    return 0;
  };
}, function(module, exports, __webpack_require__) {
  (function(_, jQuery) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var AjaxLogger, filter, logToConsole, settings;
      __webpack_require__(48);
      __webpack_require__(1);
      settings = __webpack_require__(2);
      if (settings.LOG_ERRORS_TO_SERVER == null) {
        settings.LOG_ERRORS_TO_SERVER = true;
      }
      if (settings.LOGGER_NAME == null) {
        settings.LOGGER_NAME = "mwb";
      }
      AjaxLogger = function(superClass) {
        extend(AjaxLogger, superClass);
        function AjaxLogger() {
          AjaxLogger.__super__.constructor.apply(this, arguments);
          window.clearTimeout(this.timer);
          this.schedule();
        }
        AjaxLogger.prototype.schedule = function() {
          return this.timer = _.delay(function(_this) {
            return function() {
              return _this.sendLog();
            };
          }(this), this.interval);
        };
        AjaxLogger.prototype.sendLog = function() {
          var logs, ref, ref1;
          if (this.cache.length === 0 || !((ref = window.app) != null ? (ref1 = ref.session) != null ? ref1.isAuthenticated() : void 0 : void 0)) {
            return this.schedule();
          }
          logs = JSON.stringify(this.getLogs());
          jQuery.ajax(this.url, {
            type: "POST",
            cache: false,
            processData: false,
            data: logs,
            dateType: "json",
            contentType: "application/json",
            timeout: 1e4
          }).done(function(_this) {
            return function() {
              return _this.interval = 1e3;
            };
          }(this)).fail(function(_this) {
            return function(xhr) {
              xhr.errorHandled = true;
              return _this.interval = 3e4;
            };
          }(this)).always(function(_this) {
            return function() {
              return _this.schedule();
            };
          }(this));
          return this.cache = [];
        };
        AjaxLogger.prototype.getLogs = function() {
          var err, i, len, log, logs, ref, ref1, x;
          logs = [];
          ref = this.cache;
          for (i = 0, len = ref.length; i < len; i++) {
            log = ref[i];
            try {
              if (_.isArray(log.slice(2))) {
                [].splice.apply(log, [ 2, 9e9 ].concat(ref1 = function() {
                  var j, len1, ref2, results;
                  ref2 = log.slice(2);
                  results = [];
                  for (j = 0, len1 = ref2.length; j < len1; j++) {
                    x = ref2[j];
                    results.push(JSON.stringify(x));
                  }
                  return results;
                }().join(" | "))), ref1;
              }
              JSON.stringify(log);
              logs.push(log);
            } catch (error) {
              err = error;
            }
          }
          return logs;
        };
        return AjaxLogger;
      }(window.Minilog.backends.jQuery);
      logToConsole = function(name, level, args) {
        var func;
        func = console[level] || console.log;
        return func.apply(console, args);
      };
      window.Minilog.backends.browser.write = logToConsole;
      if (settings.LOG_ERRORS_TO_SERVER) {
        filter = new window.Minilog.Filter();
        filter.deny(settings.LOGGER_NAME, "info");
        window.Minilog.pipe(filter).pipe(new AjaxLogger({
          url: settings.API_URL + "/log",
          interval: 5e3
        }));
      }
      window.Minilog.enable();
      return window.Minilog(settings.LOGGER_NAME);
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0), __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
  (function($) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var Globalize;
      Globalize = __webpack_require__(3);
      __webpack_require__(30);
      __webpack_require__(31);
      Globalize.parseFloat = function(value, options) {
        var string;
        string = String(value).replace(/\s|,/g, "");
        if (!$.isNumeric(string)) {
          return 0 / 0;
        }
        return Globalize.parseNumber(string, options) || Number(string);
      };
      return Globalize;
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(1));
}, function(module, exports, __webpack_require__) {
  "use strict";
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /**
 * jquery.mask.js
 * @version: v1.13.4
 * @author: Igor Escobar
 *
 * Created by Igor Escobar on 2012-03-10. Please report any bug at http://blog.igorescobar.com
 *
 * Copyright (c) 2012 Igor Escobar http://blog.igorescobar.com
 *
 * The MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
  (function(factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
      __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === "object") {
      module.exports = factory(require("jquery"));
    } else {
      factory(jQuery || Zepto);
    }
  })(function($) {
    var Mask = function(el, mask, options) {
      el = $(el);
      var jMask = this, oldValue = el.val(), regexMask;
      mask = typeof mask === "function" ? mask(el.val(), undefined, el, options) : mask;
      var p = {
        invalid: [],
        getCaret: function() {
          try {
            var sel, pos = 0, ctrl = el.get(0), dSel = document.selection, cSelStart = ctrl.selectionEnd;
            if (dSel && navigator.appVersion.indexOf("MSIE 10") === -1) {
              sel = dSel.createRange();
              sel.moveStart("character", el.is("input") ? -el.val().length : -el.text().length);
              pos = sel.text.length;
            } else if (cSelStart || cSelStart === "0") {
              pos = cSelStart;
            }
            return pos;
          } catch (e) {}
        },
        setCaret: function(pos) {
          try {
            if (el.is(":focus")) {
              var range, ctrl = el.get(0);
              if (ctrl.setSelectionRange) {
                ctrl.setSelectionRange(pos, pos);
              } else if (ctrl.createTextRange) {
                range = ctrl.createTextRange();
                range.collapse(true);
                range.moveEnd("character", pos);
                range.moveStart("character", pos);
                range.select();
              }
            }
          } catch (e) {}
        },
        events: function() {
          el.on("input.mask keyup.mask", p.behaviour).on("paste.mask drop.mask", function() {
            setTimeout(function() {
              el.keydown().keyup();
            }, 100);
          }).on("change.mask", function() {
            el.data("changed", true);
          }).on("blur.mask", function() {
            el.trigger("change");
            if (oldValue !== el.val() && !el.data("changed")) {
              el.triggerHandler("change");
            }
            el.data("changed", false);
          }).on("blur.mask", function() {
            oldValue = el.val();
          }).on("focus.mask", function(e) {
            if (options.selectOnFocus === true) {
              $(e.target).select();
            }
          }).on("focusout.mask", function() {
            if (options.clearIfNotMatch && !regexMask.test(p.val())) {
              p.val("");
            }
          });
        },
        getRegexMask: function() {
          var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;
          for (var i = 0; i < mask.length; i++) {
            translation = jMask.translation[mask.charAt(i)];
            if (translation) {
              pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, "");
              optional = translation.optional;
              recursive = translation.recursive;
              if (recursive) {
                maskChunks.push(mask.charAt(i));
                oRecursive = {
                  digit: mask.charAt(i),
                  pattern: pattern
                };
              } else {
                maskChunks.push(!optional && !recursive ? pattern : pattern + "?");
              }
            } else {
              maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
            }
          }
          r = maskChunks.join("");
          if (oRecursive) {
            r = r.replace(new RegExp("(" + oRecursive.digit + "(.*" + oRecursive.digit + ")?)"), "($1)?").replace(new RegExp(oRecursive.digit, "g"), oRecursive.pattern);
          }
          return new RegExp(r);
        },
        destroyEvents: function() {
          el.off([ "input", "keydown", "keyup", "paste", "drop", "blur", "focusout", "" ].join(".mask "));
        },
        val: function(v) {
          var isInput = el.is("input"), method = isInput ? "val" : "text", r;
          if (arguments.length > 0) {
            if (el[method]() !== v) {
              el[method](v);
            }
            r = el;
          } else {
            r = el[method]();
          }
          return r;
        },
        getMCharsBeforeCount: function(index, onCleanVal) {
          for (var count = 0, i = 0, maskL = mask.length; i < maskL && i < index; i++) {
            if (!jMask.translation[mask.charAt(i)]) {
              index = onCleanVal ? index + 1 : index;
              count++;
            }
          }
          return count;
        },
        caretPos: function(originalCaretPos, oldLength, newLength, maskDif) {
          var translation = jMask.translation[mask.charAt(Math.min(originalCaretPos - 1, mask.length - 1))];
          return !translation ? p.caretPos(originalCaretPos + 1, oldLength, newLength, maskDif) : Math.min(originalCaretPos + newLength - oldLength - maskDif, newLength);
        },
        behaviour: function(e) {
          e = e || window.event;
          p.invalid = [];
          var keyCode = e.keyCode || e.which;
          if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
            var caretPos = p.getCaret(), currVal = p.val(), currValL = currVal.length, changeCaret = caretPos < currValL, newVal = p.getMasked(), newValL = newVal.length, maskDif = p.getMCharsBeforeCount(newValL - 1) - p.getMCharsBeforeCount(currValL - 1);
            p.val(newVal);
            if (changeCaret && !(keyCode === 65 && e.ctrlKey)) {
              if (!(keyCode === 8 || keyCode === 46)) {
                caretPos = p.caretPos(caretPos, currValL, newValL, maskDif);
              }
              p.setCaret(caretPos);
            }
            return p.callbacks(e);
          }
        },
        getMasked: function(skipMaskChars) {
          var buf = [], value = p.val(), m = 0, maskLen = mask.length, v = 0, valLen = value.length, offset = 1, addMethod = "push", resetPos = -1, lastMaskChar, check;
          if (options.reverse) {
            addMethod = "unshift";
            offset = -1;
            lastMaskChar = 0;
            m = maskLen - 1;
            v = valLen - 1;
            check = function() {
              return m > -1 && v > -1;
            };
          } else {
            lastMaskChar = maskLen - 1;
            check = function() {
              return m < maskLen && v < valLen;
            };
          }
          while (check()) {
            var maskDigit = mask.charAt(m), valDigit = value.charAt(v), translation = jMask.translation[maskDigit];
            if (translation) {
              if (valDigit.match(translation.pattern)) {
                buf[addMethod](valDigit);
                if (translation.recursive) {
                  if (resetPos === -1) {
                    resetPos = m;
                  } else if (m === lastMaskChar) {
                    m = resetPos - offset;
                  }
                  if (lastMaskChar === resetPos) {
                    m -= offset;
                  }
                }
                m += offset;
              } else if (translation.optional) {
                m += offset;
                v -= offset;
              } else if (translation.fallback) {
                buf[addMethod](translation.fallback);
                m += offset;
                v -= offset;
              } else {
                p.invalid.push({
                  p: v,
                  v: valDigit,
                  e: translation.pattern
                });
              }
              v += offset;
            } else {
              if (!skipMaskChars) {
                buf[addMethod](maskDigit);
              }
              if (valDigit === maskDigit) {
                v += offset;
              }
              m += offset;
            }
          }
          var lastMaskCharDigit = mask.charAt(lastMaskChar);
          if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
          }
          return buf.join("");
        },
        callbacks: function(e) {
          var val = p.val(), changed = val !== oldValue, defaultArgs = [ val, e, el, options ], callback = function(name, criteria, args) {
            if (typeof options[name] === "function" && criteria) {
              options[name].apply(this, args);
            }
          };
          callback("onChange", changed === true, defaultArgs);
          callback("onKeyPress", changed === true, defaultArgs);
          callback("onComplete", val.length === mask.length, defaultArgs);
          callback("onInvalid", p.invalid.length > 0, [ val, e, el, p.invalid, options ]);
        }
      };
      jMask.mask = mask;
      jMask.options = options;
      jMask.remove = function() {
        var caret = p.getCaret();
        p.destroyEvents();
        p.val(jMask.getCleanVal());
        p.setCaret(caret - p.getMCharsBeforeCount(caret));
        return el;
      };
      jMask.getCleanVal = function() {
        return p.getMasked(true);
      };
      jMask.init = function(onlyMask) {
        onlyMask = onlyMask || false;
        options = options || {};
        jMask.byPassKeys = $.jMaskGlobals.byPassKeys;
        jMask.translation = $.jMaskGlobals.translation;
        jMask.translation = $.extend({}, jMask.translation, options.translation);
        jMask = $.extend(true, {}, jMask, options);
        regexMask = p.getRegexMask();
        if (onlyMask === false) {
          if (options.placeholder) {
            el.attr("placeholder", options.placeholder);
          }
          if ($("input").length && "oninput" in $("input")[0] === false && el.attr("autocomplete") === "on") {
            el.attr("autocomplete", "off");
          }
          p.destroyEvents();
          p.events();
          var caret = p.getCaret();
          p.val(p.getMasked());
          p.setCaret(caret + p.getMCharsBeforeCount(caret, true));
        } else {
          p.events();
          p.val(p.getMasked());
        }
      };
      jMask.init(!el.is("input"));
    };
    $.maskWatchers = {};
    var HTMLAttributes = function() {
      var input = $(this), options = {}, prefix = "data-mask-", mask = input.attr("data-mask");
      if (input.attr(prefix + "reverse")) {
        options.reverse = true;
      }
      if (input.attr(prefix + "clearifnotmatch")) {
        options.clearIfNotMatch = true;
      }
      if (input.attr(prefix + "selectonfocus") === "true") {
        options.selectOnFocus = true;
      }
      if (notSameMaskObject(input, mask, options)) {
        return input.data("mask", new Mask(this, mask, options));
      }
    }, notSameMaskObject = function(field, mask, options) {
      options = options || {};
      var maskObject = $(field).data("mask"), stringify = JSON.stringify, value = $(field).val() || $(field).text();
      try {
        if (typeof mask === "function") {
          mask = mask(value);
        }
        return typeof maskObject !== "object" || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
      } catch (e) {}
    };
    $.fn.mask = function(mask, options) {
      options = options || {};
      var selector = this.selector, globals = $.jMaskGlobals, interval = $.jMaskGlobals.watchInterval, maskFunction = function() {
        if (notSameMaskObject(this, mask, options)) {
          return $(this).data("mask", new Mask(this, mask, options));
        }
      };
      $(this).each(maskFunction);
      if (selector && selector !== "" && globals.watchInputs) {
        clearInterval($.maskWatchers[selector]);
        $.maskWatchers[selector] = setInterval(function() {
          $(document).find(selector).each(maskFunction);
        }, interval);
      }
      return this;
    };
    $.fn.unmask = function() {
      clearInterval($.maskWatchers[this.selector]);
      delete $.maskWatchers[this.selector];
      return this.each(function() {
        var dataMask = $(this).data("mask");
        if (dataMask) {
          dataMask.remove().removeData("mask");
        }
      });
    };
    $.fn.cleanVal = function() {
      return this.data("mask").getCleanVal();
    };
    $.applyDataMask = function(selector) {
      selector = selector || $.jMaskGlobals.maskElements;
      var $selector = selector instanceof $ ? selector : $(selector);
      $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
    };
    var globals = {
      maskElements: "input,td,span,div",
      dataMaskAttr: "*[data-mask]",
      dataMask: true,
      watchInterval: 300,
      watchInputs: true,
      watchDataMask: false,
      byPassKeys: [ 9, 16, 17, 18, 36, 37, 38, 39, 40, 91 ],
      translation: {
        "0": {
          pattern: /\d/
        },
        "9": {
          pattern: /\d/,
          optional: true
        },
        "#": {
          pattern: /\d/,
          recursive: true
        },
        A: {
          pattern: /[a-zA-Z0-9]/
        },
        S: {
          pattern: /[a-zA-Z]/
        }
      }
    };
    $.jMaskGlobals = $.jMaskGlobals || {};
    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);
    if (globals.dataMask) {
      $.applyDataMask();
    }
    setInterval(function() {
      if ($.jMaskGlobals.watchDataMask) {
        $.applyDataMask();
      }
    }, globals.watchInterval);
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _xregexp = __webpack_require__(54);
  var _xregexp2 = _interopRequireDefault(_xregexp);
  var _build = __webpack_require__(55);
  var _build2 = _interopRequireDefault(_build);
  var _matchrecursive = __webpack_require__(56);
  var _matchrecursive2 = _interopRequireDefault(_matchrecursive);
  var _unicodeBase = __webpack_require__(57);
  var _unicodeBase2 = _interopRequireDefault(_unicodeBase);
  var _unicodeBlocks = __webpack_require__(58);
  var _unicodeBlocks2 = _interopRequireDefault(_unicodeBlocks);
  var _unicodeCategories = __webpack_require__(60);
  var _unicodeCategories2 = _interopRequireDefault(_unicodeCategories);
  var _unicodeProperties = __webpack_require__(62);
  var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);
  var _unicodeScripts = __webpack_require__(64);
  var _unicodeScripts2 = _interopRequireDefault(_unicodeScripts);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  (0, _build2.default)(_xregexp2.default);
  (0, _matchrecursive2.default)(_xregexp2.default);
  (0, _unicodeBase2.default)(_xregexp2.default);
  (0, _unicodeBlocks2.default)(_xregexp2.default);
  (0, _unicodeCategories2.default)(_xregexp2.default);
  (0, _unicodeProperties2.default)(_xregexp2.default);
  (0, _unicodeScripts2.default)(_xregexp2.default);
  exports.default = _xregexp2.default;
  module.exports = exports["default"];
}, , function(module, exports, __webpack_require__) {
  __webpack_require__(22);
  module.exports = __webpack_require__(24);
}, function(module, exports, __webpack_require__) {
  __webpack_require__(23).polyfill();
}, function(module, exports, __webpack_require__) {
  (function(process, global) {
    /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */
    (function(global, factory) {
      true ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.ES6Promise = factory();
    })(this, function() {
      "use strict";
      function objectOrFunction(x) {
        var type = typeof x;
        return x !== null && (type === "object" || type === "function");
      }
      function isFunction(x) {
        return typeof x === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
      }
      var isArray = _isArray;
      var len = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap(callback, arg) {
        queue[len] = callback;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : undefined;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process.nextTick(flush);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode("");
        observer.observe(node, {
          characterData: true
        });
        return function() {
          node.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush, 1);
        };
      }
      var queue = new Array(1e3);
      function flush() {
        for (var i = 0; i < len; i += 2) {
          var callback = queue[i];
          var arg = queue[i + 1];
          callback(arg);
          queue[i] = undefined;
          queue[i + 1] = undefined;
        }
        len = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === undefined && "function" === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop);
        if (child[PROMISE_ID] === undefined) {
          makePromise(child);
        }
        var _state = parent._state;
        if (_state) {
          var callback = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback, parent._result);
          });
        } else {
          subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$1(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(noop);
        resolve(promise, object);
        return promise;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop() {}
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var TRY_CATCH_ERROR = {
        error: null
      };
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function getThen(promise) {
        try {
          return promise.then;
        } catch (error) {
          TRY_CATCH_ERROR.error = error;
          return TRY_CATCH_ERROR;
        }
      }
      function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise) {
          var sealed = false;
          var error = tryThen(then$$1, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              resolve(promise, value);
            } else {
              fulfill(promise, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise, reason);
          }, "Settle: " + (promise._label || " unknown promise"));
          if (!sealed && error) {
            sealed = true;
            reject(promise, error);
          }
        }, promise);
      }
      function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise, thenable._result);
        } else {
          subscribe(thenable, undefined, function(value) {
            return resolve(promise, value);
          }, function(reason) {
            return reject(promise, reason);
          });
        }
      }
      function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
          handleOwnThenable(promise, maybeThenable);
        } else {
          if (then$$1 === TRY_CATCH_ERROR) {
            reject(promise, TRY_CATCH_ERROR.error);
            TRY_CATCH_ERROR.error = null;
          } else if (then$$1 === undefined) {
            fulfill(promise, maybeThenable);
          } else if (isFunction(then$$1)) {
            handleForeignThenable(promise, maybeThenable, then$$1);
          } else {
            fulfill(promise, maybeThenable);
          }
        }
      }
      function resolve(promise, value) {
        if (promise === value) {
          reject(promise, selfFulfillment());
        } else if (objectOrFunction(value)) {
          handleMaybeThenable(promise, value, getThen(value));
        } else {
          fulfill(promise, value);
        }
      }
      function publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        publish(promise);
      }
      function fulfill(promise, value) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._result = value;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) {
          asap(publish, promise);
        }
      }
      function reject(promise, reason) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
      }
      function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length = _subscribers.length;
        parent._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          asap(publish, parent);
        }
      }
      function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback = void 0, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function tryCatch(callback, detail) {
        try {
          return callback(detail);
        } catch (e) {
          TRY_CATCH_ERROR.error = e;
          return TRY_CATCH_ERROR;
        }
      }
      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0;
        if (hasCallback) {
          value = tryCatch(callback, detail);
          if (value === TRY_CATCH_ERROR) {
            failed = true;
            error = value.error;
            value.error = null;
          } else {
            succeeded = true;
          }
          if (promise === value) {
            reject(promise, cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
          succeeded = true;
        }
        if (promise._state !== PENDING) {} else if (hasCallback && succeeded) {
          resolve(promise, value);
        } else if (failed) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          fulfill(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }
      function initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            resolve(promise, value);
          }, function rejectPromise(reason) {
            reject(promise, reason);
          });
        } catch (e) {
          reject(promise, e);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = undefined;
        promise._result = undefined;
        promise._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = function() {
        function Enumerator(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator.prototype._enumerate = function _enumerate(input) {
          for (var i = 0; this._state === PENDING && i < input.length; i++) {
            this._eachEntry(input[i], i);
          }
        };
        Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
          var c = this._instanceConstructor;
          var resolve$$1 = c.resolve;
          if (resolve$$1 === resolve$1) {
            var _then = getThen(entry);
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i] = entry;
            } else if (c === Promise$1) {
              var promise = new c(noop);
              handleMaybeThenable(promise, entry, _then);
              this._willSettleAt(promise, i);
            } else {
              this._willSettleAt(new c(function(resolve$$1) {
                return resolve$$1(entry);
              }), i);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i);
          }
        };
        Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
          var promise = this.promise;
          if (promise._state === PENDING) {
            this._remaining--;
            if (state === REJECTED) {
              reject(promise, value);
            } else {
              this._result[i] = value;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise, this._result);
          }
        };
        Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
          var enumerator = this;
          subscribe(promise, undefined, function(value) {
            return enumerator._settledAt(FULFILLED, i, value);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i, reason);
          });
        };
        return Enumerator;
      }();
      function all(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray(entries)) {
          return new Constructor(function(_, reject) {
            return reject(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve, reject) {
            var length = entries.length;
            for (var i = 0; i < length; i++) {
              Constructor.resolve(entries[i]).then(resolve, reject);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise = new Constructor(noop);
        reject(promise, reason);
        return promise;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = function() {
        function Promise(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = undefined;
          this._subscribers = [];
          if (noop !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise.prototype.finally = function _finally(callback) {
          var promise = this;
          var constructor = promise.constructor;
          if (isFunction(callback)) {
            return promise.then(function(value) {
              return constructor.resolve(callback()).then(function() {
                return value;
              });
            }, function(reason) {
              return constructor.resolve(callback()).then(function() {
                throw reason;
              });
            });
          }
          return promise.then(callback, callback);
        };
        return Promise;
      }();
      Promise$1.prototype.then = then;
      Promise$1.all = all;
      Promise$1.race = race;
      Promise$1.resolve = resolve$1;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") {
          local = global;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P = local.Promise;
        if (P) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P.resolve());
          } catch (e) {}
          if (promiseToString === "[object Promise]" && !P.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    });
  }).call(exports, __webpack_require__(15), __webpack_require__(10));
}, function(module, exports, __webpack_require__) {
  (function($, _) {
    var __webpack_public_path__, i18n, loadOptionalConfigs, loadRequiredConfigs, locales, requireConfig, setApplicationVersion, settings, settingsPromise, storage;
    __webpack_public_path__ = window.WB.contextPath + "/static/rainbow/client/js/";
    __webpack_require__.p = __webpack_public_path__;
    __webpack_require__(25);
    __webpack_require__(13);
    __webpack_require__(18);
    i18n = __webpack_require__(26);
    locales = __webpack_require__(6);
    storage = __webpack_require__(8);
    requireConfig = __webpack_require__(9);
    window.$ = window.jQuery = $;
    window._ = _;
    settings = __webpack_require__(2);
    window.OW = window.OW || {};
    window.OW.configHelpers = __webpack_require__(50);
    loadRequiredConfigs = function() {
      var contractsJsPromise, featuresPromise;
      featuresPromise = $.getJSON(settings.API_URL + "/features").then(function(features) {
        return window.OW.features = features;
      });
      contractsJsPromise = requireConfig([ settings.API_URL + "/conf/contracts.js" ]);
      return $.when(featuresPromise, contractsJsPromise);
    };
    loadOptionalConfigs = function() {
      var loadConfig, promises;
      promises = [];
      loadConfig = function(configName, successCallback) {
        return requireConfig.loadConfig(settings.API_URL + ("/conf/" + configName)).then(successCallback, function() {
          console.warn(configName + " config is missing");
          return new $.Deferred().resolve();
        });
      };
      promises.push(loadConfig("applications.js", _.noop));
      promises.push(loadConfig("tutorial.js", _.noop));
      promises.push(loadConfig("masks.js", function(masks) {
        return _.extend(settings.MASKS, masks);
      }));
      __webpack_require__(51);
      promises.push(loadConfig("validation.js", function() {
        return _.noop;
      }));
      return $.when.apply($, promises);
    };
    setApplicationVersion = function() {
      return $(document.head).append("<meta name='app-version' content='" + "2.15.4528-169" + "' />");
    };
    settingsPromise = settings.loadPromise.then(locales.loadLocaleData).then(function() {
      i18n.init();
      return $.when(loadRequiredConfigs(), loadOptionalConfigs());
    });
    __webpack_require__.e(0).then(function() {
      return $(function() {
        setApplicationVersion();
        return settingsPromise.then(function() {
          var Application;
          Application = __webpack_require__(20);
          window.app = new Application();
          return window.app.init();
        });
      });
    }.bind(null, __webpack_require__)).catch(__webpack_require__.oe);
    console.timeEnd("init");
  }).call(exports, __webpack_require__(1), __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_RESULT__;
  !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
    RegExp.escape = function(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    };
    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(obj, start) {
        for (var i = start || 0, j = this.length; i < j; i++) {
          if (this[i] === obj) {
            return i;
          }
        }
        return -1;
      };
    }
    String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
    String.prototype.startsWith = function(str) {
      return this.indexOf(str) == 0;
    };
    Number.isInteger = Number.isInteger || function(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    var method, methods = [ "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeStamp", "trace", "warn" ], length = methods.length, console = window.console = window.console || {};
    while (length--) {
      method = methods[length];
      !console[method] && (console[method] = function() {});
    }
    console.assert = console.assert || function(assertion, message) {
      if (!assertion) {
        throw new Error(message);
      }
    };
    // MIT license
    var lastTime = 0;
    var vendors = [ "ms", "moz", "webkit", "o" ];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}, function(module, exports, __webpack_require__) {
  (function(_) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    var slice = [].slice;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var Jed, argsHasher, ensureJed1xFormat, exports, jed, locales, log, settings, stripContext, translate, translatePlural;
      settings = __webpack_require__(2);
      locales = __webpack_require__(6);
      log = __webpack_require__(16);
      Jed = __webpack_require__(49);
      exports = {};
      ensureJed1xFormat = function(dictionary) {
        var item, key, results;
        results = [];
        for (key in dictionary) {
          item = dictionary[key];
          if (_.isArray(item) && item.length > 1 && item[0] === null) {
            results.push(item.shift());
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      jed = new Jed({
        domain: "webbank",
        locale_data: {
          webbank: {
            "": {
              domain: "webbank",
              plural_forms: "nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);",
              lang: "ru"
            }
          }
        },
        missing_key_callback: function(key) {
          if (settings.DEBUG_SHOW_I18N_MISSING_KEYS) {
            return log.warn("Translation missing: '" + key + "'");
          }
        }
      });
      stripContext = function(key, translatedValue) {
        var context, contextRegex, m;
        contextRegex = /\s+(\[.+?\])$/;
        if (m = key.match(contextRegex)) {
          context = m[1];
          if (translatedValue.endsWith(context)) {
            translatedValue = translatedValue.replace(contextRegex, "");
          }
        }
        return translatedValue;
      };
      translate = function() {
        var args, key, ref, value;
        key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        value = (ref = jed.translate(key)).fetch.apply(ref, args);
        return stripContext(key, value);
      };
      translatePlural = function() {
        var args, num, plural, singular, value;
        singular = arguments[0], plural = arguments[1], num = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
        console.assert(singular);
        console.assert(plural);
        console.assert(num || num === 0);
        console.assert(_.isEmpty(args), "Additional args not supported in i18n.tn");
        value = jed.translate(singular).ifPlural(num, plural).fetch({
          num: num
        });
        return stripContext(singular, stripContext(plural, value));
      };
      argsHasher = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return JSON.stringify(args);
      };
      exports.init = function() {
        var localeData;
        console.debug("init jed");
        localeData = locales.getLocaleData();
        ensureJed1xFormat(localeData.locale_data.webbank);
        return jed = new Jed(_.extend(localeData, {
          missing_key_callback: function(key) {
            if (settings.DEBUG_SHOW_I18N_MISSING_KEYS) {
              return log.warn("Translation missing: '" + key + "'");
            }
          }
        }));
      };
      exports.t = _.memoize(translate, argsHasher);
      exports.tn = _.memoize(translatePlural, argsHasher);
      _.extend(window, {
        t: exports.t,
        tn: exports.tn
      });
      return exports;
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /**
 * CLDR JavaScript Library v0.5.1
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2019-01-21T13:43Z
 */
  /*!
 * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
  (function(factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(4) ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
      __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = factory(require("../cldr"));
    } else {
      factory(Cldr);
    }
  })(function(Cldr) {
    var pathNormalize = Cldr._pathNormalize, validatePresence = Cldr._validatePresence, validateType = Cldr._validateType;
    /*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */
    var EventEmitter;
    EventEmitter = function() {
      function EventEmitter() {}
      var proto = EventEmitter.prototype;
      var exports = {};
      function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
          if (listeners[i].listener === listener) {
            return i;
          }
        }
        return -1;
      }
      function alias(name) {
        return function aliasClosure() {
          return this[name].apply(this, arguments);
        };
      }
      proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;
        if (evt instanceof RegExp) {
          response = {};
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              response[key] = events[key];
            }
          }
        } else {
          response = events[evt] || (events[evt] = []);
        }
        return response;
      };
      proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;
        for (i = 0; i < listeners.length; i += 1) {
          flatListeners.push(listeners[i].listener);
        }
        return flatListeners;
      };
      proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;
        if (listeners instanceof Array) {
          response = {};
          response[evt] = listeners;
        }
        return response || listeners;
      };
      proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === "object";
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
            listeners[key].push(listenerIsWrapped ? listener : {
              listener: listener,
              once: false
            });
          }
        }
        return this;
      };
      proto.on = alias("addListener");
      proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
          listener: listener,
          once: true
        });
      };
      proto.once = alias("addOnceListener");
      proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
      };
      proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
          this.defineEvent(evts[i]);
        }
        return this;
      };
      proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key)) {
            index = indexOfListener(listeners[key], listener);
            if (index !== -1) {
              listeners[key].splice(index, 1);
            }
          }
        }
        return this;
      };
      proto.off = alias("removeListener");
      proto.addListeners = function addListeners(evt, listeners) {
        return this.manipulateListeners(false, evt, listeners);
      };
      proto.removeListeners = function removeListeners(evt, listeners) {
        return this.manipulateListeners(true, evt, listeners);
      };
      proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;
        if (typeof evt === "object" && !(evt instanceof RegExp)) {
          for (i in evt) {
            if (evt.hasOwnProperty(i) && (value = evt[i])) {
              if (typeof value === "function") {
                single.call(this, i, value);
              } else {
                multiple.call(this, i, value);
              }
            }
          }
        } else {
          i = listeners.length;
          while (i--) {
            single.call(this, evt, listeners[i]);
          }
        }
        return this;
      };
      proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;
        if (type === "string") {
          delete events[evt];
        } else if (evt instanceof RegExp) {
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              delete events[key];
            }
          }
        } else {
          delete this._events;
        }
        return this;
      };
      proto.removeAllListeners = alias("removeEvent");
      proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key)) {
            i = listeners[key].length;
            while (i--) {
              listener = listeners[key][i];
              if (listener.once === true) {
                this.removeListener(evt, listener.listener);
              }
              response = listener.listener.apply(this, args || []);
              if (response === this._getOnceReturnValue()) {
                this.removeListener(evt, listener.listener);
              }
            }
          }
        }
        return this;
      };
      proto.trigger = alias("emitEvent");
      proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
      };
      proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
      };
      proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty("_onceReturnValue")) {
          return this._onceReturnValue;
        } else {
          return true;
        }
      };
      proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
      };
      EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
      };
      return EventEmitter;
    }();
    var validateTypeFunction = function(value, name) {
      validateType(value, name, typeof value === "undefined" || typeof value === "function", "Function");
    };
    var superGet, superInit, globalEe = new EventEmitter();
    function validateTypeEvent(value, name) {
      validateType(value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp");
    }
    function validateThenCall(method, self) {
      return function(event, listener) {
        validatePresence(event, "event");
        validateTypeEvent(event, "event");
        validatePresence(listener, "listener");
        validateTypeFunction(listener, "listener");
        return self[method].apply(self, arguments);
      };
    }
    function off(self) {
      return validateThenCall("off", self);
    }
    function on(self) {
      return validateThenCall("on", self);
    }
    function once(self) {
      return validateThenCall("once", self);
    }
    Cldr.off = off(globalEe);
    Cldr.on = on(globalEe);
    Cldr.once = once(globalEe);
    superInit = Cldr.prototype.init;
    Cldr.prototype.init = function() {
      var ee;
      this.ee = ee = new EventEmitter();
      this.off = off(ee);
      this.on = on(ee);
      this.once = once(ee);
      superInit.apply(this, arguments);
    };
    function getOverload() {
      superGet = Cldr.prototype.get;
      Cldr.prototype.get = function(path) {
        var value = superGet.apply(this, arguments);
        path = pathNormalize(path, this.attributes).join("/");
        globalEe.trigger("get", [ path, value ]);
        this.ee.trigger("get", [ path, value ]);
        return value;
      };
    }
    Cldr._eventInit = getOverload;
    getOverload();
    return Cldr;
  });
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /**
 * CLDR JavaScript Library v0.5.1
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2019-01-21T13:43Z
 */
  /*!
 * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
  (function(factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(4) ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
      __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = factory(require("../cldr"));
    } else {
      factory(Cldr);
    }
  })(function(Cldr) {
    var alwaysArray = Cldr._alwaysArray;
    var supplementalMain = function(cldr) {
      var prepend, supplemental;
      prepend = function(prepend) {
        return function(path) {
          path = alwaysArray(path);
          return cldr.get([ prepend ].concat(path));
        };
      };
      supplemental = prepend("supplemental");
      supplemental.weekData = prepend("supplemental/weekData");
      supplemental.weekData.firstDay = function() {
        return cldr.get("supplemental/weekData/firstDay/{territory}") || cldr.get("supplemental/weekData/firstDay/001");
      };
      supplemental.weekData.minDays = function() {
        var minDays = cldr.get("supplemental/weekData/minDays/{territory}") || cldr.get("supplemental/weekData/minDays/001");
        return parseInt(minDays, 10);
      };
      supplemental.timeData = prepend("supplemental/timeData");
      supplemental.timeData.allowed = function() {
        return cldr.get("supplemental/timeData/{territory}/_allowed") || cldr.get("supplemental/timeData/001/_allowed");
      };
      supplemental.timeData.preferred = function() {
        return cldr.get("supplemental/timeData/{territory}/_preferred") || cldr.get("supplemental/timeData/001/_preferred");
      };
      return supplemental;
    };
    var initSuper = Cldr.prototype.init;
    Cldr.prototype.init = function() {
      initSuper.apply(this, arguments);
      this.supplemental = supplementalMain(this);
    };
    return Cldr;
  });
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /**
 * CLDR JavaScript Library v0.5.1
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2019-01-21T13:43Z
 */
  /*!
 * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
  (function(factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(4) ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
      __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = factory(require("../cldr"));
    } else {
      factory(Cldr);
    }
  })(function(Cldr) {
    var coreLoad = Cldr._coreLoad;
    var jsonMerge = Cldr._jsonMerge;
    var pathNormalize = Cldr._pathNormalize;
    var resourceGet = Cldr._resourceGet;
    var validatePresence = Cldr._validatePresence;
    var validateTypePath = Cldr._validateTypePath;
    var bundleParentLookup = function(Cldr, locale) {
      var normalizedPath, parent;
      if (locale === "root") {
        return;
      }
      normalizedPath = pathNormalize([ "supplemental/parentLocales/parentLocale", locale ]);
      parent = resourceGet(Cldr._resolved, normalizedPath) || resourceGet(Cldr._raw, normalizedPath);
      if (parent) {
        return parent;
      }
      parent = locale.substr(0, locale.lastIndexOf(Cldr.localeSep));
      if (!parent) {
        return "root";
      }
      return parent;
    };
    var resourceSet = function(data, path, value) {
      var i, node = data, length = path.length;
      for (i = 0; i < length - 1; i++) {
        if (!node[path[i]]) {
          node[path[i]] = {};
        }
        node = node[path[i]];
      }
      node[path[i]] = value;
    };
    var itemLookup = function() {
      var lookup;
      lookup = function(Cldr, locale, path, attributes, childLocale) {
        var normalizedPath, parent, value;
        if (typeof locale === "undefined" || locale === childLocale) {
          return;
        }
        normalizedPath = pathNormalize(path, attributes);
        value = resourceGet(Cldr._resolved, normalizedPath);
        if (value !== undefined && typeof value !== "object") {
          return value;
        }
        value = resourceGet(Cldr._raw, normalizedPath);
        if (value === undefined) {
          parent = bundleParentLookup(Cldr, locale);
          value = lookup(Cldr, parent, path, jsonMerge(attributes, {
            bundle: parent
          }), locale);
        }
        if (value !== undefined) {
          resourceSet(Cldr._resolved, normalizedPath, value);
        }
        return value;
      };
      return lookup;
    }();
    Cldr._raw = {};
    Cldr.load = function() {
      Cldr._raw = coreLoad(Cldr, Cldr._raw, arguments);
    };
    Cldr.prototype.get = function(path) {
      validatePresence(path, "path");
      validateTypePath(path, "path");
      return itemLookup(Cldr, this.attributes && this.attributes.bundle || "", path, this.attributes);
    };
    if (Cldr._eventInit) {
      Cldr._eventInit();
    }
    return Cldr;
  });
}, function(module, exports, __webpack_require__) {
  var define = false;
  /**
 * Globalize v1.4.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2018-07-17T20:38Z
 */
  /*!
 * Globalize v1.4.0 2018-07-17T20:38Z Released under the MIT license
 * http://git.io/TrdQbw
 */
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([ "cldr", "../globalize", "cldr/event", "cldr/supplemental" ], factory);
    } else if (true) {
      module.exports = factory(__webpack_require__(5), __webpack_require__(3));
    } else {
      factory(root.Cldr, root.Globalize);
    }
  })(this, function(Cldr, Globalize) {
    var createError = Globalize._createError, regexpEscape = Globalize._regexpEscape, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterRange = Globalize._validateParameterRange, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
    var createErrorUnsupportedFeature = function(feature) {
      return createError("E_UNSUPPORTED", "Unsupported {feature}.", {
        feature: feature
      });
    };
    var validateParameterTypeNumber = function(value, name) {
      validateParameterType(value, name, value === undefined || typeof value === "number", "Number");
    };
    var validateParameterTypeString = function(value, name) {
      validateParameterType(value, name, value === undefined || typeof value === "string", "a string");
    };
    var numberCompactPatternRe = /^([^0]*)(0+)([^0]*)$/;
    var numberFormatGroupingSeparator = function(number, primaryGroupingSize, secondaryGroupingSize) {
      var index, currentGroupingSize = primaryGroupingSize, ret = "", sep = ",", switchToSecondary = secondaryGroupingSize ? true : false;
      number = String(number).split(".");
      index = number[0].length;
      while (index > currentGroupingSize) {
        ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : "") + ret;
        index -= currentGroupingSize;
        if (switchToSecondary) {
          currentGroupingSize = secondaryGroupingSize;
          switchToSecondary = false;
        }
      }
      number[0] = number[0].slice(0, index) + (ret.length ? sep : "") + ret;
      return number.join(".");
    };
    var numberFormatIntegerFractionDigits = function(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {
      if (maximumFractionDigits) {
        if (roundIncrement) {
          number = round(number, roundIncrement);
        } else {
          number = round(number, {
            exponent: -maximumFractionDigits
          });
        }
      } else {
        number = round(number);
      }
      number = String(number);
      if (maximumFractionDigits && /e-/.test(number)) {
        number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, "").replace(/\.$/, "");
      }
      if (minimumFractionDigits) {
        number = number.split(".");
        number[1] = stringPad(number[1] || "", minimumFractionDigits, true);
        number = number.join(".");
      }
      if (minimumIntegerDigits) {
        number = number.split(".");
        number[0] = stringPad(number[0], minimumIntegerDigits);
        number = number.join(".");
      }
      return number;
    };
    var numberToPrecision = function(number, precision, round) {
      var roundOrder;
      roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));
      roundOrder -= precision;
      return round(number, {
        exponent: roundOrder
      });
    };
    var numberFormatSignificantDigits = function(number, minimumSignificantDigits, maximumSignificantDigits, round) {
      var atMinimum, atMaximum;
      if (minimumSignificantDigits > maximumSignificantDigits) {
        maximumSignificantDigits = minimumSignificantDigits;
      }
      atMinimum = numberToPrecision(number, minimumSignificantDigits, round);
      atMaximum = numberToPrecision(number, maximumSignificantDigits, round);
      number = +atMinimum === +atMaximum ? atMinimum : atMaximum;
      number = (+number).toString(10);
      if (/e/.test(number)) {
        throw createErrorUnsupportedFeature({
          feature: "integers out of (1e21, 1e-7)"
        });
      }
      if (minimumSignificantDigits - number.replace(/^0+|\./g, "").length > 0) {
        number = number.split(".");
        number[1] = stringPad(number[1] || "", minimumSignificantDigits - number[0].replace(/^0+/, "").length, true);
        number = number.join(".");
      }
      return number;
    };
    var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
    var removeLiteralQuotes = function(string) {
      if (string[0] + string[string.length - 1] !== "''") {
        return string;
      }
      if (string === "''") {
        return "";
      }
      return string.replace(/''/g, "'").slice(1, -1);
    };
    var numberFormat = function(number, properties, pluralGenerator) {
      var compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix, symbolMap;
      padding = properties[1];
      minimumIntegerDigits = properties[2];
      minimumFractionDigits = properties[3];
      maximumFractionDigits = properties[4];
      minimumSignificantDigits = properties[5];
      maximumSignificantDigits = properties[6];
      roundIncrement = properties[7];
      primaryGroupingSize = properties[8];
      secondaryGroupingSize = properties[9];
      round = properties[15];
      infinitySymbol = properties[16];
      nanSymbol = properties[17];
      symbolMap = properties[18];
      nuDigitsMap = properties[19];
      compactMap = properties[20];
      if (isNaN(number)) {
        return nanSymbol;
      }
      if (number < 0) {
        pattern = properties[12];
        prefix = properties[13];
        suffix = properties[14];
      } else {
        pattern = properties[11];
        prefix = properties[0];
        suffix = properties[10];
      }
      if (!isFinite(number)) {
        return prefix + infinitySymbol + suffix;
      }
      if (pattern.indexOf("%") !== -1) {
        number *= 100;
      } else if (pattern.indexOf("") !== -1) {
        number *= 1e3;
      }
      var compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm;
      if (compactMap) {
        numberExponent = Math.abs(Math.floor(number)).toString().length - 1;
        numberExponent = Math.min(numberExponent, compactMap.maxExponent);
        if (numberExponent >= 3) {
          compactPattern = compactMap[numberExponent] && compactMap[numberExponent].other;
        }
        if (compactPattern === "0") {
          compactPattern = null;
        } else if (compactPattern) {
          compactDigits = compactPattern.split("0").length - 1;
          divisor = numberExponent - (compactDigits - 1);
          number = number / Math.pow(10, divisor);
        }
      }
      if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {
        number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round);
      } else {
        number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);
      }
      if (compactMap && compactPattern) {
        pluralForm = pluralGenerator ? pluralGenerator(+number) : "other";
        compactPattern = compactMap[numberExponent][pluralForm] || compactPattern;
        compactProperties = compactPattern.match(numberCompactPatternRe);
        prefix += compactProperties[1];
        suffix = compactProperties[3] + suffix;
      }
      number = number.replace(/^-/, "");
      if (primaryGroupingSize) {
        number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);
      }
      ret = prefix;
      ret += number;
      ret += suffix;
      return ret.replace(/('([^']|'')+'|'')|./g, function(character, literal) {
        if (literal) {
          return removeLiteralQuotes(literal);
        }
        character = character.replace(/[.,\-+E%\u2030]/, function(symbol) {
          return symbolMap[symbol];
        });
        if (nuDigitsMap) {
          character = character.replace(/[0-9]/, function(digit) {
            return nuDigitsMap[+digit];
          });
        }
        return character;
      });
    };
    var numberFormatterFn = function(properties, pluralGenerator) {
      return function numberFormatter(value) {
        validateParameterPresence(value, "value");
        validateParameterTypeNumber(value, "value");
        return numberFormat(value, properties, pluralGenerator);
      };
    };
    var numberNumberingSystem = function(cldr) {
      var nu = cldr.attributes["u-nu"];
      if (nu) {
        if (nu === "traditio") {
          nu = "traditional";
        }
        if ([ "native", "traditional", "finance" ].indexOf(nu) !== -1) {
          return cldr.main([ "numbers/otherNumberingSystems", nu ]);
        }
        return nu;
      }
      return cldr.main("numbers/defaultNumberingSystem");
    };
    var numberCompact = function(compactType, cldr) {
      var maxExponent = 0;
      var object = cldr.main([ "numbers/decimalFormats-numberSystem-" + numberNumberingSystem(cldr), compactType, "decimalFormat" ]);
      object = Object.keys(object).reduce(function(newObject, compactKey) {
        var numberExponent = compactKey.split("0").length - 1;
        var pluralForm = compactKey.split("-")[2];
        newObject[numberExponent] = newObject[numberExponent] || {};
        newObject[numberExponent][pluralForm] = object[compactKey];
        maxExponent = Math.max(numberExponent, maxExponent);
        return newObject;
      }, {});
      object.maxExponent = maxExponent;
      return object;
    };
    var numberNumberingSystemDigitsMap = function(cldr) {
      var aux, nu = numberNumberingSystem(cldr);
      if (nu === "latn") {
        return;
      }
      aux = cldr.supplemental([ "numberingSystems", nu ]);
      if (aux._type !== "numeric") {
        throw createErrorUnsupportedFeature("`" + aux._type + "` numbering system");
      }
      return aux._digits;
    };
    var numberPatternProperties = function(pattern) {
      var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;
      pattern = pattern.match(numberPatternRe);
      if (!pattern) {
        throw new Error("Invalid pattern: " + pattern);
      }
      prefix = pattern[1];
      padding = pattern[4];
      integerFractionOrSignificantPattern = pattern[5];
      significantPattern = pattern[9];
      scientificNotation = pattern[10];
      suffix = pattern[11];
      if (significantPattern) {
        significantPattern.replace(/(@+)(#*)/, function(match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) {
          minimumSignificantDigits = minimumSignificantDigitsMatch.length;
          maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length;
        });
      } else {
        fractionPattern = pattern[8];
        integerPattern = pattern[7];
        if (fractionPattern) {
          fractionPattern.replace(/[0-9]+/, function(match) {
            minimumFractionDigits = match;
          });
          if (minimumFractionDigits) {
            roundIncrement = +("0." + minimumFractionDigits);
            minimumFractionDigits = minimumFractionDigits.length;
          } else {
            minimumFractionDigits = 0;
          }
          maximumFractionDigits = fractionPattern.length - 1;
        } else {
          minimumFractionDigits = 0;
          maximumFractionDigits = 0;
        }
        integerPattern.replace(/0+$/, function(match) {
          minimumIntegerDigits = match.length;
        });
      }
      if (scientificNotation) {
        throw createErrorUnsupportedFeature({
          feature: "scientific notation (not implemented)"
        });
      }
      if (padding) {
        throw createErrorUnsupportedFeature({
          feature: "padding (not implemented)"
        });
      }
      if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(",")) !== -1) {
        aux2 = integerFractionOrSignificantPattern.split(".")[0];
        primaryGroupingSize = aux2.length - aux1 - 1;
        if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(",", aux1 - 1)) !== -1) {
          secondaryGroupingSize = aux1 - 1 - aux2;
        }
      }
      return [ prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix ];
    };
    var numberSymbol = function(name, cldr) {
      return cldr.main([ "numbers/symbols-numberSystem-" + numberNumberingSystem(cldr), name ]);
    };
    var numberSymbolName = {
      ".": "decimal",
      ",": "group",
      "%": "percentSign",
      "+": "plusSign",
      "-": "minusSign",
      E: "exponential",
      "": "perMille"
    };
    var numberSymbolMap = function(cldr) {
      var symbol, symbolMap = {};
      for (symbol in numberSymbolName) {
        symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr);
      }
      return symbolMap;
    };
    var numberTruncate = function(value) {
      if (isNaN(value)) {
        return NaN;
      }
      return Math[value < 0 ? "ceil" : "floor"](value);
    };
    var numberRound = function(method) {
      method = method || "round";
      method = method === "truncate" ? numberTruncate : Math[method];
      return function(value, incrementOrExp) {
        var exp, increment;
        value = +value;
        if (isNaN(value)) {
          return NaN;
        }
        if (typeof incrementOrExp === "object" && incrementOrExp.exponent) {
          exp = +incrementOrExp.exponent;
          increment = 1;
          if (exp === 0) {
            return method(value);
          }
          if (!(typeof exp === "number" && exp % 1 === 0)) {
            return NaN;
          }
        } else {
          increment = +incrementOrExp || 1;
          if (increment === 1) {
            return method(value);
          }
          if (isNaN(increment)) {
            return NaN;
          }
          increment = increment.toExponential().split("e");
          exp = +increment[1];
          increment = +increment[0];
        }
        value = value.toString().split("e");
        value[0] = +value[0] / increment;
        value[1] = value[1] ? +value[1] - exp : -exp;
        value = method(+(value[0] + "e" + value[1]));
        value = value.toString().split("e");
        value[0] = +value[0] * increment;
        value[1] = value[1] ? +value[1] + exp : exp;
        return +(value[0] + "e" + value[1]);
      };
    };
    var numberFormatProperties = function(pattern, cldr, options) {
      var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties;
      function getOptions(attribute, propertyIndex) {
        if (attribute in options) {
          properties[propertyIndex] = options[attribute];
        }
      }
      options = options || {};
      pattern = pattern.split(";");
      positivePattern = pattern[0];
      negativePattern = pattern[1] || "-" + positivePattern;
      negativeProperties = numberPatternProperties(negativePattern);
      negativePrefix = negativeProperties[0];
      negativeSuffix = negativeProperties[10];
      roundFn = numberRound(options.round);
      roundFn.generatorString = function() {
        return "numberRound(" + (options.round ? '"' + options.round + '"' : "") + ")";
      };
      properties = numberPatternProperties(positivePattern).concat([ positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol("infinity", cldr), numberSymbol("nan", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr) ]);
      if (options.compact) {
        properties[2] = negativeSuffix[2] = 1;
        properties[3] = negativeSuffix[3] = 0;
        properties[4] = negativeSuffix[4] = 0;
        properties[5] = negativeSuffix[5] = properties[6] = negativeSuffix[6] = undefined;
        properties[20] = numberCompact(options.compact, cldr);
      }
      getOptions("minimumIntegerDigits", 2);
      getOptions("minimumFractionDigits", 3);
      getOptions("maximumFractionDigits", 4);
      getOptions("minimumSignificantDigits", 5);
      getOptions("maximumSignificantDigits", 6);
      if (options.useGrouping === false) {
        properties[8] = null;
      }
      if ("minimumFractionDigits" in options && !("maximumFractionDigits" in options)) {
        properties[4] = Math.max(properties[3], properties[4]);
      } else if (!("minimumFractionDigits" in options) && "maximumFractionDigits" in options) {
        properties[3] = Math.min(properties[3], properties[4]);
      }
      return properties;
    };
    var regexpCfG = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/g;
    var regexpDashG = /[\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u2212]/g;
    var regexpZsG = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/g;
    var looseMatching = function(value) {
      return value.replace(regexpCfG, "").replace(regexpDashG, "-").replace(regexpZsG, " ");
    };
    var numberParse = function(value, properties) {
      var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid;
      grammar = [ [ "nan" ], [ "prefix", "infinity", "suffix" ], [ "prefix", "number", "suffix" ], [ "negativePrefix", "infinity", "negativeSuffix" ], [ "negativePrefix", "number", "negativeSuffix" ] ];
      invertedSymbolMap = properties[0];
      invertedNuDigitsMap = properties[1] || {};
      tokenizer = properties[2];
      value = looseMatching(value);
      function parse(type) {
        return function(lexeme) {
          lexeme = lexeme.split("").map(function(character) {
            return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;
          }).join("");
          switch (type) {
           case "infinity":
            number = Infinity;
            break;

           case "nan":
            number = NaN;
            break;

           case "number":
            lexeme = lexeme.replace(/,/g, "");
            number = +lexeme;
            break;

           case "prefix":
           case "negativePrefix":
            prefix = lexeme;
            break;

           case "suffix":
            suffix = lexeme;
            break;

           case "negativeSuffix":
            suffix = lexeme;
            negative = true;
            break;

           default:
            throw new Error("Internal error");
          }
          return "";
        };
      }
      function tokenizeNParse(_value, grammar) {
        return grammar.some(function(statement) {
          var value = _value;
          return statement.every(function(type) {
            if (value.match(tokenizer[type]) === null) {
              return false;
            }
            value = value.replace(tokenizer[type], parse(type));
            return true;
          }) && !value.length;
        });
      }
      valid = tokenizeNParse(value, grammar);
      if (!valid || isNaN(number)) {
        return NaN;
      }
      prefixNSuffix = "" + prefix + suffix;
      if (prefixNSuffix.indexOf("%") !== -1) {
        number /= 100;
      } else if (prefixNSuffix.indexOf("") !== -1) {
        number /= 1e3;
      }
      if (negative) {
        number *= -1;
      }
      return number;
    };
    var numberParserFn = function(properties) {
      return function numberParser(value) {
        validateParameterPresence(value, "value");
        validateParameterTypeString(value, "value");
        return numberParse(value, properties);
      };
    };
    var numberSymbolInvertedMap = function(cldr) {
      var symbol, symbolMap = {};
      for (symbol in numberSymbolName) {
        symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol;
      }
      return symbolMap;
    };
    var objectMap = function(object, fn) {
      return Object.keys(object).map(function(key) {
        return fn([ key, object[key] ]);
      }).reduce(function(object, pair) {
        object[pair[0]] = pair[1];
        return object;
      }, {});
    };
    var numberParseProperties = function(pattern, cldr, options) {
      var aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap, invertedSymbolMap, maximumFractionDigits, maximumSignificantDigits, minimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap, numberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap, formatProperties = numberFormatProperties(pattern, cldr, options);
      prefix = looseMatching(formatProperties[0]);
      maximumFractionDigits = formatProperties[4];
      minimumSignificantDigits = formatProperties[5];
      maximumSignificantDigits = formatProperties[6];
      primaryGroupingSize = formatProperties[8];
      secondaryGroupingSize = formatProperties[9];
      suffix = looseMatching(formatProperties[10]);
      negativePrefix = looseMatching(formatProperties[13]);
      negativeSuffix = looseMatching(formatProperties[14]);
      infinitySymbol = looseMatching(formatProperties[16]);
      nanSymbol = looseMatching(formatProperties[17]);
      symbolMap = objectMap(formatProperties[18], function(pair) {
        return [ pair[0], looseMatching(pair[1]) ];
      });
      nuDigitsMap = formatProperties[19];
      invertedSymbolMap = objectMap(numberSymbolInvertedMap(cldr), function(pair) {
        return [ looseMatching(pair[0]), pair[1] ];
      });
      digitsRe = nuDigitsMap ? "[" + nuDigitsMap + "]" : "\\d";
      groupingSeparatorRe = regexpEscape(symbolMap[","]);
      decimalSymbolRe = regexpEscape(symbolMap["."]);
      if (nuDigitsMap) {
        invertedNuDigitsMap = nuDigitsMap.split("").reduce(function(object, localizedDigit, i) {
          object[localizedDigit] = String(i);
          return object;
        }, {});
      }
      aux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function(value) {
        return value.replace(/('([^']|'')+'|'')|./g, function(character, literal) {
          if (literal) {
            return removeLiteralQuotes(literal);
          }
          character = character.replace(/[\-+E%\u2030]/, function(symbol) {
            return symbolMap[symbol];
          });
          return character;
        });
      });
      prefix = aux[0];
      suffix = aux[1];
      negativePrefix = aux[2];
      negativeSuffix = aux[3];
      numberTokenizer = digitsRe + "+";
      if (primaryGroupingSize) {
        if (secondaryGroupingSize) {
          aux = digitsRe + "{1," + secondaryGroupingSize + "}((" + groupingSeparatorRe + digitsRe + "{" + secondaryGroupingSize + "})*(" + groupingSeparatorRe + digitsRe + "{" + primaryGroupingSize + "}))";
        } else {
          aux = digitsRe + "{1," + primaryGroupingSize + "}(" + groupingSeparatorRe + digitsRe + "{" + primaryGroupingSize + "})+";
        }
        numberTokenizer = "(" + aux + "|" + numberTokenizer + ")";
      }
      if (!isNaN(minimumSignificantDigits * maximumSignificantDigits) || maximumFractionDigits) {
        aux = decimalSymbolRe + digitsRe + "+";
        numberTokenizer = numberTokenizer + "(" + aux + "|" + decimalSymbolRe + ")?" + "|(" + numberTokenizer + ")?" + aux;
        numberTokenizer = "(" + numberTokenizer + ")";
      }
      return [ invertedSymbolMap, invertedNuDigitsMap, {
        infinity: new RegExp("^" + regexpEscape(infinitySymbol)),
        nan: new RegExp("^" + regexpEscape(nanSymbol)),
        negativePrefix: new RegExp("^" + regexpEscape(negativePrefix)),
        negativeSuffix: new RegExp("^" + regexpEscape(negativeSuffix)),
        number: new RegExp("^" + numberTokenizer),
        prefix: new RegExp("^" + regexpEscape(prefix)),
        suffix: new RegExp("^" + regexpEscape(suffix))
      } ];
    };
    var numberPattern = function(style, cldr) {
      if (style !== "decimal" && style !== "percent") {
        throw new Error("Invalid style");
      }
      return cldr.main([ "numbers", style + "Formats-numberSystem-" + numberNumberingSystem(cldr), "standard" ]);
    };
    function validateDigits(properties) {
      var minimumIntegerDigits = properties[2], minimumFractionDigits = properties[3], maximumFractionDigits = properties[4], minimumSignificantDigits = properties[5], maximumSignificantDigits = properties[6];
      if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {
        validateParameterRange(minimumSignificantDigits, "minimumSignificantDigits", 1, 21);
        validateParameterRange(maximumSignificantDigits, "maximumSignificantDigits", minimumSignificantDigits, 21);
      } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) {
        throw new Error("Neither or both the minimum and maximum significant digits must be " + "present");
      } else {
        validateParameterRange(minimumIntegerDigits, "minimumIntegerDigits", 1, 21);
        validateParameterRange(minimumFractionDigits, "minimumFractionDigits", 0, 20);
        validateParameterRange(maximumFractionDigits, "maximumFractionDigits", minimumFractionDigits, 20);
      }
    }
    Globalize.numberFormatter = Globalize.prototype.numberFormatter = function(options) {
      var args, cldr, fnArgs, pattern, properties, returnFn;
      validateParameterTypePlainObject(options, "options");
      options = options || {};
      cldr = this.cldr;
      args = [ options ];
      validateDefaultLocale(cldr);
      cldr.on("get", validateCldr);
      if (options.raw) {
        pattern = options.raw;
      } else {
        pattern = numberPattern(options.style || "decimal", cldr);
      }
      properties = numberFormatProperties(pattern, cldr, options);
      fnArgs = [ properties ];
      cldr.off("get", validateCldr);
      validateDigits(properties);
      if (options.compact) {
        fnArgs.push(this.pluralGenerator());
      }
      returnFn = numberFormatterFn.apply(null, fnArgs);
      runtimeBind(args, cldr, returnFn, fnArgs);
      return returnFn;
    };
    Globalize.numberParser = Globalize.prototype.numberParser = function(options) {
      var args, cldr, pattern, properties, returnFn;
      validateParameterTypePlainObject(options, "options");
      options = options || {};
      cldr = this.cldr;
      args = [ options ];
      validateDefaultLocale(cldr);
      if (options.compact) {
        throw createErrorUnsupportedFeature({
          feature: "compact number parsing (not implemented)"
        });
      }
      cldr.on("get", validateCldr);
      if (options.raw) {
        pattern = options.raw;
      } else {
        pattern = numberPattern(options.style || "decimal", cldr);
      }
      properties = numberParseProperties(pattern, cldr, options);
      cldr.off("get", validateCldr);
      returnFn = numberParserFn(properties);
      runtimeBind(args, cldr, returnFn, [ properties ]);
      return returnFn;
    };
    Globalize.formatNumber = Globalize.prototype.formatNumber = function(value, options) {
      validateParameterPresence(value, "value");
      validateParameterTypeNumber(value, "value");
      return this.numberFormatter(options)(value);
    };
    Globalize.parseNumber = Globalize.prototype.parseNumber = function(value, options) {
      validateParameterPresence(value, "value");
      validateParameterTypeString(value, "value");
      return this.numberParser(options)(value);
    };
    Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
    Globalize._numberNumberingSystem = numberNumberingSystem;
    Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;
    Globalize._numberPattern = numberPattern;
    Globalize._numberSymbol = numberSymbol;
    Globalize._looseMatching = looseMatching;
    Globalize._removeLiteralQuotes = removeLiteralQuotes;
    Globalize._stringPad = stringPad;
    Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
    Globalize._validateParameterTypeString = validateParameterTypeString;
    return Globalize;
  });
}, function(module, exports, __webpack_require__) {
  var define = false;
  /**
 * Globalize v1.4.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2018-07-17T20:38Z
 */
  /*!
 * Globalize v1.4.0 2018-07-17T20:38Z Released under the MIT license
 * http://git.io/TrdQbw
 */
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([ "cldr", "../globalize", "./number", "cldr/event", "cldr/supplemental" ], factory);
    } else if (true) {
      module.exports = factory(__webpack_require__(5), __webpack_require__(3));
    } else {
      factory(root.Cldr, root.Globalize);
    }
  })(this, function(Cldr, Globalize) {
    var createError = Globalize._createError, createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature, formatMessage = Globalize._formatMessage, isPlainObject = Globalize._isPlainObject, looseMatching = Globalize._looseMatching, numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap, numberSymbol = Globalize._numberSymbol, regexpEscape = Globalize._regexpEscape, removeLiteralQuotes = Globalize._removeLiteralQuotes, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validate = Globalize._validate, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject, validateParameterTypeString = Globalize._validateParameterTypeString;
    var validateParameterTypeDate = function(value, name) {
      validateParameterType(value, name, value === undefined || value instanceof Date, "Date");
    };
    var createErrorInvalidParameterValue = function(name, value) {
      return createError("E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
        name: name,
        value: value
      });
    };
    var validateSkeletonFieldsPosMap = "GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx".split("").reduce(function(memo, item, i) {
      memo[item] = i;
      return memo;
    }, {});
    var validateSkeleton = function validateSkeleton(skeleton) {
      var last, fieldsPosMap = validateSkeletonFieldsPosMap;
      skeleton.replace(/[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function(field) {
        throw createError("E_INVALID_OPTIONS", "Invalid field `{invalidField}` of skeleton `{value}`", {
          invalidField: field,
          type: "skeleton",
          value: skeleton
        });
      });
      skeleton.split("").every(function(field) {
        if (fieldsPosMap[field] < last) {
          throw createError("E_INVALID_OPTIONS", "Invalid order `{invalidField}` of skeleton `{value}`", {
            invalidField: field,
            type: "skeleton",
            value: skeleton
          });
        }
        last = fieldsPosMap[field];
        return true;
      });
    };
    var objectInvert = function(object, fn) {
      fn = fn || function(object, key, value) {
        object[value] = key;
        return object;
      };
      return Object.keys(object).reduce(function(newObject, key) {
        return fn(newObject, key, object[key]);
      }, {});
    };
    var dateExpandPatternSimilarFieldsMap = objectInvert({
      e: "eEc",
      L: "ML"
    }, function(object, key, value) {
      value.split("").forEach(function(field) {
        object[field] = key;
      });
      return object;
    });
    var dateExpandPatternNormalizePatternType = function(character) {
      return dateExpandPatternSimilarFieldsMap[character] || character;
    };
    var datePatternRe = /([a-z])\1*|'([^']|'')+'|''|./gi;
    var stringRepeat = function(str, count) {
      var i, result = "";
      for (i = 0; i < count; i++) {
        result = result + str;
      }
      return result;
    };
    function expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat) {
      var i, j, bestMatchFormatParts, matchedType, matchedLength, requestedType, requestedLength, requestedSkeletonParts, normalizePatternType = dateExpandPatternNormalizePatternType;
      requestedSkeletonParts = skeletonWithoutFractionalSeconds.match(datePatternRe);
      bestMatchFormatParts = bestMatchFormat.match(datePatternRe);
      for (i = 0; i < bestMatchFormatParts.length; i++) {
        matchedType = bestMatchFormatParts[i].charAt(0);
        matchedLength = bestMatchFormatParts[i].length;
        for (j = 0; j < requestedSkeletonParts.length; j++) {
          requestedType = requestedSkeletonParts[j].charAt(0);
          requestedLength = requestedSkeletonParts[j].length;
          if (normalizePatternType(matchedType) === normalizePatternType(requestedType) && matchedLength < requestedLength) {
            bestMatchFormatParts[i] = stringRepeat(matchedType, requestedLength);
          }
        }
      }
      return bestMatchFormatParts.join("");
    }
    var dateExpandPatternAugmentFormat = function(requestedSkeleton, bestMatchFormat, decimalSeparator) {
      var countOfFractionalSeconds, fractionalSecondMatch, lastSecondIdx, skeletonWithoutFractionalSeconds;
      fractionalSecondMatch = requestedSkeleton.match(/S/g);
      countOfFractionalSeconds = fractionalSecondMatch ? fractionalSecondMatch.length : 0;
      skeletonWithoutFractionalSeconds = requestedSkeleton.replace(/S/g, "");
      bestMatchFormat = expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat);
      lastSecondIdx = bestMatchFormat.lastIndexOf("s");
      if (lastSecondIdx !== -1 && countOfFractionalSeconds !== 0) {
        bestMatchFormat = bestMatchFormat.slice(0, lastSecondIdx + 1) + decimalSeparator + stringRepeat("S", countOfFractionalSeconds) + bestMatchFormat.slice(lastSecondIdx + 1);
      }
      return bestMatchFormat;
    };
    var dateExpandPatternCompareFormats = function(formatA, formatB) {
      var a, b, distance, lenA, lenB, typeA, typeB, i, j, normalizePatternType = dateExpandPatternNormalizePatternType;
      if (formatA === formatB) {
        return 0;
      }
      formatA = formatA.match(datePatternRe);
      formatB = formatB.match(datePatternRe);
      if (formatA.length !== formatB.length) {
        return -1;
      }
      distance = 1;
      for (i = 0; i < formatA.length; i++) {
        a = formatA[i].charAt(0);
        typeA = normalizePatternType(a);
        typeB = null;
        for (j = 0; j < formatB.length; j++) {
          b = formatB[j].charAt(0);
          typeB = normalizePatternType(b);
          if (typeA === typeB) {
            break;
          } else {
            typeB = null;
          }
        }
        if (typeB === null) {
          return -1;
        }
        lenA = formatA[i].length;
        lenB = formatB[j].length;
        distance = distance + Math.abs(lenA - lenB);
        if (a !== b) {
          distance += 1;
        }
        if (lenA < 3 && lenB >= 3 || lenA >= 3 && lenB < 3) {
          distance += 20;
        }
      }
      return distance;
    };
    var dateExpandPatternGetBestMatchPattern = function(cldr, askedSkeleton) {
      var availableFormats, decimalSeparator, pattern, ratedFormats, skeleton, path = "dates/calendars/gregorian/dateTimeFormats/availableFormats", augmentFormat = dateExpandPatternAugmentFormat, compareFormats = dateExpandPatternCompareFormats;
      pattern = cldr.main([ path, askedSkeleton ]);
      if (askedSkeleton && !pattern) {
        availableFormats = cldr.main([ path ]);
        ratedFormats = [];
        for (skeleton in availableFormats) {
          ratedFormats.push({
            skeleton: skeleton,
            pattern: availableFormats[skeleton],
            rate: compareFormats(askedSkeleton, skeleton)
          });
        }
        ratedFormats = ratedFormats.filter(function(format) {
          return format.rate > -1;
        }).sort(function(formatA, formatB) {
          return formatA.rate - formatB.rate;
        });
        if (ratedFormats.length) {
          decimalSeparator = numberSymbol("decimal", cldr);
          pattern = augmentFormat(askedSkeleton, ratedFormats[0].pattern, decimalSeparator);
        }
      }
      return pattern;
    };
    var dateExpandPattern = function(options, cldr) {
      var dateSkeleton, result, skeleton, timeSkeleton, type, getBestMatchPattern = dateExpandPatternGetBestMatchPattern;
      function combineDateTime(type, datePattern, timePattern) {
        return formatMessage(cldr.main([ "dates/calendars/gregorian/dateTimeFormats", type ]), [ timePattern, datePattern ]);
      }
      switch (true) {
       case "skeleton" in options:
        skeleton = options.skeleton;
        skeleton = skeleton.replace(/j/g, function() {
          return cldr.supplemental.timeData.preferred();
        });
        validateSkeleton(skeleton);
        result = getBestMatchPattern(cldr, skeleton);
        if (result) {
          break;
        }
        timeSkeleton = skeleton.split(/[^hHKkmsSAzZOvVXx]/).slice(-1)[0];
        dateSkeleton = skeleton.split(/[^GyYuUrQqMLlwWdDFgEec]/)[0];
        dateSkeleton = getBestMatchPattern(cldr, dateSkeleton);
        timeSkeleton = getBestMatchPattern(cldr, timeSkeleton);
        if (/(MMMM|LLLL).*[Ec]/.test(dateSkeleton)) {
          type = "full";
        } else if (/MMMM|LLLL/.test(dateSkeleton)) {
          type = "long";
        } else if (/MMM|LLL/.test(dateSkeleton)) {
          type = "medium";
        } else {
          type = "short";
        }
        if (dateSkeleton && timeSkeleton) {
          result = combineDateTime(type, dateSkeleton, timeSkeleton);
        } else {
          result = dateSkeleton || timeSkeleton;
        }
        break;

       case "date" in options:
       case "time" in options:
        result = cldr.main([ "dates/calendars/gregorian", "date" in options ? "dateFormats" : "timeFormats", options.date || options.time ]);
        break;

       case "datetime" in options:
        result = combineDateTime(options.datetime, cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]), cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ]));
        break;

       case "raw" in options:
        result = options.raw;
        break;

       default:
        throw createErrorInvalidParameterValue({
          name: "options",
          value: options
        });
      }
      return result;
    };
    var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];
    var dateFirstDayOfWeek = function(cldr) {
      return dateWeekDays.indexOf(cldr.supplemental.weekData.firstDay());
    };
    var dateGetTimeZoneName = function(length, type, timeZone, cldr) {
      var metaZone, result;
      if (!timeZone) {
        return;
      }
      result = cldr.main([ "dates/timeZoneNames/zone", timeZone, length < 4 ? "short" : "long", type ]);
      if (result) {
        return result;
      }
      metaZone = cldr.supplemental([ "metaZones/metazoneInfo/timezone", timeZone, 0, "usesMetazone/_mzone" ]);
      return cldr.main([ "dates/timeZoneNames/metazone", metaZone, length < 4 ? "short" : "long", type ]);
    };
    var dateTimezoneHourFormatH = function(hourFormat) {
      return hourFormat.split(";").map(function(format) {
        return format.slice(0, format.indexOf("H") + 1);
      }).join(";");
    };
    var dateTimezoneHourFormatHm = function(hourFormat, hFormat) {
      return hourFormat.split(";").map(function(format) {
        var parts = format.split(/H+/);
        parts.splice(1, 0, hFormat);
        return parts.join("");
      }).join(";");
    };
    var runtimeCacheDataBind = function(key, data) {
      var fn = function() {
        return data;
      };
      fn.dataCacheKey = key;
      return fn;
    };
    var dateFormatProperties = function(pattern, cldr, timeZone) {
      var properties = {
        numberFormatters: {},
        pattern: pattern,
        timeSeparator: numberSymbol("timeSeparator", cldr)
      }, widths = [ "abbreviated", "wide", "narrow" ];
      function setNumberFormatterPattern(pad) {
        properties.numberFormatters[pad] = stringPad("", pad);
      }
      if (timeZone) {
        properties.timeZoneData = runtimeCacheDataBind("iana/" + timeZone, {
          offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
          untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
          isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
        });
      }
      pattern.replace(datePatternRe, function(current) {
        var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;
        chr = current.charAt(0);
        length = current.length;
        if (chr === "j") {
          properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
        }
        if (chr === "Z" && length === 4) {
          chr = "O";
          length = 4;
        }
        if (chr === "z") {
          standardTzName = dateGetTimeZoneName(length, "standard", timeZone, cldr);
          daylightTzName = dateGetTimeZoneName(length, "daylight", timeZone, cldr);
          if (standardTzName) {
            properties.standardTzName = standardTzName;
          }
          if (daylightTzName) {
            properties.daylightTzName = daylightTzName;
          }
          if (!standardTzName || !daylightTzName) {
            chr = "O";
            if (length < 4) {
              length = 1;
            }
          }
        }
        if (chr === "v") {
          genericTzName = dateGetTimeZoneName(length, "generic", timeZone, cldr);
          if (!genericTzName) {
            chr = "V";
            length = 4;
          }
        }
        switch (chr) {
         case "G":
          properties.eras = cldr.main([ "dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
          break;

         case "y":
          formatNumber = true;
          break;

         case "Y":
          properties.firstDay = dateFirstDayOfWeek(cldr);
          properties.minDays = cldr.supplemental.weekData.minDays();
          formatNumber = true;
          break;

         case "u":
         case "U":
          throw createErrorUnsupportedFeature({
            feature: "year pattern `" + chr + "`"
          });

         case "Q":
         case "q":
          if (length > 2) {
            if (!properties.quarters) {
              properties.quarters = {};
            }
            if (!properties.quarters[chr]) {
              properties.quarters[chr] = {};
            }
            properties.quarters[chr][length] = cldr.main([ "dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
          } else {
            formatNumber = true;
          }
          break;

         case "M":
         case "L":
          if (length > 2) {
            if (!properties.months) {
              properties.months = {};
            }
            if (!properties.months[chr]) {
              properties.months[chr] = {};
            }
            properties.months[chr][length] = cldr.main([ "dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
          } else {
            formatNumber = true;
          }
          break;

         case "w":
         case "W":
          properties.firstDay = dateFirstDayOfWeek(cldr);
          properties.minDays = cldr.supplemental.weekData.minDays();
          formatNumber = true;
          break;

         case "d":
         case "D":
         case "F":
          formatNumber = true;
          break;

         case "g":
          throw createErrorUnsupportedFeature({
            feature: "Julian day pattern `g`"
          });

         case "e":
         case "c":
          if (length <= 2) {
            properties.firstDay = dateFirstDayOfWeek(cldr);
            formatNumber = true;
            break;
          }

         case "E":
          if (!properties.days) {
            properties.days = {};
          }
          if (!properties.days[chr]) {
            properties.days[chr] = {};
          }
          if (length === 6) {
            properties.days[chr][length] = cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "short" ]) || cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "abbreviated" ]);
          } else {
            properties.days[chr][length] = cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", widths[length < 3 ? 0 : length - 3] ]);
          }
          break;

         case "a":
          properties.dayPeriods = {
            am: cldr.main("dates/calendars/gregorian/dayPeriods/format/wide/am"),
            pm: cldr.main("dates/calendars/gregorian/dayPeriods/format/wide/pm")
          };
          break;

         case "h":
         case "H":
         case "K":
         case "k":
         case "m":
         case "s":
         case "S":
         case "A":
          formatNumber = true;
          break;

         case "v":
          if (length !== 1 && length !== 4) {
            throw createErrorUnsupportedFeature({
              feature: "timezone pattern `" + pattern + "`"
            });
          }
          properties.genericTzName = genericTzName;
          break;

         case "V":
          if (length === 1) {
            throw createErrorUnsupportedFeature({
              feature: "timezone pattern `" + pattern + "`"
            });
          }
          if (timeZone) {
            if (length === 2) {
              properties.timeZoneName = timeZone;
              break;
            }
            var timeZoneName, exemplarCity = cldr.main([ "dates/timeZoneNames/zone", timeZone, "exemplarCity" ]);
            if (length === 3) {
              if (!exemplarCity) {
                exemplarCity = cldr.main([ "dates/timeZoneNames/zone/Etc/Unknown/exemplarCity" ]);
              }
              timeZoneName = exemplarCity;
            }
            if (exemplarCity && length === 4) {
              timeZoneName = formatMessage(cldr.main("dates/timeZoneNames/regionFormat"), [ exemplarCity ]);
            }
            if (timeZoneName) {
              properties.timeZoneName = timeZoneName;
              break;
            }
          }
          if (current === "v") {
            length = 1;
          }

         case "O":
          properties.gmtFormat = cldr.main("dates/timeZoneNames/gmtFormat");
          properties.gmtZeroFormat = cldr.main("dates/timeZoneNames/gmtZeroFormat");
          aux = cldr.main("dates/timeZoneNames/hourFormat");
          properties.hourFormat = length < 4 ? [ dateTimezoneHourFormatH(aux), dateTimezoneHourFormatHm(aux, "H") ] : dateTimezoneHourFormatHm(aux, "HH");

         case "Z":
         case "X":
         case "x":
          setNumberFormatterPattern(1);
          setNumberFormatterPattern(2);
          break;
        }
        if (formatNumber) {
          setNumberFormatterPattern(length);
        }
      });
      return properties;
    };
    var dateFormatterFn = function(dateToPartsFormatter) {
      return function dateFormatter(value) {
        return dateToPartsFormatter(value).map(function(part) {
          return part.value;
        }).join("");
      };
    };
    var dateParseProperties = function(cldr, timeZone) {
      var properties = {
        preferredTimeData: cldr.supplemental.timeData.preferred()
      };
      if (timeZone) {
        properties.timeZoneData = runtimeCacheDataBind("iana/" + timeZone, {
          offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
          untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
          isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
        });
      }
      return properties;
    };
    var ZonedDateTime = function() {
      function definePrivateProperty(object, property, value) {
        Object.defineProperty(object, property, {
          value: value
        });
      }
      function getUntilsIndex(original, untils) {
        var index = 0;
        var originalTime = original.getTime();
        while (index < untils.length - 1 && originalTime >= untils[index]) {
          index++;
        }
        return index;
      }
      function setWrap(fn) {
        var offset1 = this.getTimezoneOffset();
        var ret = fn();
        this.original.setTime(new Date(this.getTime()));
        var offset2 = this.getTimezoneOffset();
        if (offset2 - offset1) {
          this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);
        }
        return ret;
      }
      var ZonedDateTime = function(date, timeZoneData) {
        definePrivateProperty(this, "original", new Date(date.getTime()));
        definePrivateProperty(this, "local", new Date(date.getTime()));
        definePrivateProperty(this, "timeZoneData", timeZoneData);
        definePrivateProperty(this, "setWrap", setWrap);
        if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {
          throw new Error("Invalid IANA data");
        }
        this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1e3);
      };
      ZonedDateTime.prototype.clone = function() {
        return new ZonedDateTime(this.original, this.timeZoneData);
      };
      [ "getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes", "getSeconds", "getMilliseconds" ].forEach(function(method) {
        var utcMethod = "getUTC" + method.substr(3);
        ZonedDateTime.prototype[method] = function() {
          return this.local[utcMethod]();
        };
      });
      ZonedDateTime.prototype.valueOf = ZonedDateTime.prototype.getTime = function() {
        return this.local.getTime() + this.getTimezoneOffset() * 60 * 1e3;
      };
      ZonedDateTime.prototype.getTimezoneOffset = function() {
        var index = getUntilsIndex(this.original, this.timeZoneData.untils);
        return this.timeZoneData.offsets[index];
      };
      [ "setFullYear", "setMonth", "setDate", "setHours", "setMinutes", "setSeconds", "setMilliseconds" ].forEach(function(method) {
        var utcMethod = "setUTC" + method.substr(3);
        ZonedDateTime.prototype[method] = function(value) {
          var local = this.local;
          return this.setWrap(function() {
            return local[utcMethod](value);
          });
        };
      });
      ZonedDateTime.prototype.setTime = function(time) {
        return this.local.setTime(time);
      };
      ZonedDateTime.prototype.isDST = function() {
        var index = getUntilsIndex(this.original, this.timeZoneData.untils);
        return Boolean(this.timeZoneData.isdsts[index]);
      };
      ZonedDateTime.prototype.inspect = function() {
        var index = getUntilsIndex(this.original, this.timeZoneData.untils);
        var abbrs = this.timeZoneData.abbrs;
        return this.local.toISOString().replace(/Z$/, "") + " " + (abbrs && abbrs[index] + " " || this.getTimezoneOffset() * -1 + " ") + (this.isDST() ? "(daylight savings)" : "");
      };
      ZonedDateTime.prototype.toDate = function() {
        return new Date(this.getTime());
      };
      [ "toISOString", "toJSON", "toUTCString" ].forEach(function(method) {
        ZonedDateTime.prototype[method] = function() {
          return this.toDate()[method]();
        };
      });
      return ZonedDateTime;
    }();
    var dateIsLeapYear = function(year) {
      return new Date(year, 1, 29).getMonth() === 1;
    };
    var dateLastDayOfMonth = function(date) {
      return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    };
    var dateStartOf = function(date, unit) {
      date = date instanceof ZonedDateTime ? date.clone() : new Date(date.getTime());
      switch (unit) {
       case "year":
        date.setMonth(0);

       case "month":
        date.setDate(1);

       case "day":
        date.setHours(0);

       case "hour":
        date.setMinutes(0);

       case "minute":
        date.setSeconds(0);

       case "second":
        date.setMilliseconds(0);
      }
      return date;
    };
    var dateSetDate = function(date, day) {
      var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
      date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay);
    };
    var dateSetMonth = function(date, month) {
      var originalDate = date.getDate();
      date.setDate(1);
      date.setMonth(month);
      dateSetDate(date, originalDate);
    };
    var outOfRange = function(value, low, high) {
      return value < low || value > high;
    };
    var dateParse = function(value, tokens, properties) {
      var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid, YEAR = 0, MONTH = 1, DAY = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECONDS = 6, date = new Date(), truncateAt = [], units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];
      if (properties.timeZoneData) {
        date = new ZonedDateTime(date, properties.timeZoneData());
      }
      if (!tokens.length) {
        return null;
      }
      valid = tokens.every(function(token) {
        var century, chr, value, length;
        if (token.type === "literal") {
          return true;
        }
        chr = token.type.charAt(0);
        length = token.type.length;
        if (chr === "j") {
          chr = properties.preferredTimeData;
        }
        switch (chr) {
         case "G":
          truncateAt.push(YEAR);
          era = +token.value;
          break;

         case "y":
          value = token.value;
          if (length === 2) {
            if (outOfRange(value, 0, 99)) {
              return false;
            }
            century = Math.floor(date.getFullYear() / 100) * 100;
            value += century;
            if (value > date.getFullYear() + 20) {
              value -= 100;
            }
          }
          date.setFullYear(value);
          truncateAt.push(YEAR);
          break;

         case "Y":
          throw createErrorUnsupportedFeature({
            feature: "year pattern `" + chr + "`"
          });

         case "Q":
         case "q":
          break;

         case "M":
         case "L":
          if (length <= 2) {
            value = token.value;
          } else {
            value = +token.value;
          }
          if (outOfRange(value, 1, 12)) {
            return false;
          }
          month = value;
          truncateAt.push(MONTH);
          break;

         case "w":
         case "W":
          break;

         case "d":
          day = token.value;
          truncateAt.push(DAY);
          break;

         case "D":
          daysOfYear = token.value;
          truncateAt.push(DAY);
          break;

         case "F":
          break;

         case "e":
         case "c":
         case "E":
          break;

         case "a":
          amPm = token.value;
          break;

         case "h":
          value = token.value;
          if (outOfRange(value, 1, 12)) {
            return false;
          }
          hour = hour12 = true;
          date.setHours(value === 12 ? 0 : value);
          truncateAt.push(HOUR);
          break;

         case "K":
          value = token.value;
          if (outOfRange(value, 0, 11)) {
            return false;
          }
          hour = hour12 = true;
          date.setHours(value);
          truncateAt.push(HOUR);
          break;

         case "k":
          value = token.value;
          if (outOfRange(value, 1, 24)) {
            return false;
          }
          hour = true;
          date.setHours(value === 24 ? 0 : value);
          truncateAt.push(HOUR);
          break;

         case "H":
          value = token.value;
          if (outOfRange(value, 0, 23)) {
            return false;
          }
          hour = true;
          date.setHours(value);
          truncateAt.push(HOUR);
          break;

         case "m":
          value = token.value;
          if (outOfRange(value, 0, 59)) {
            return false;
          }
          date.setMinutes(value);
          truncateAt.push(MINUTE);
          break;

         case "s":
          value = token.value;
          if (outOfRange(value, 0, 59)) {
            return false;
          }
          date.setSeconds(value);
          truncateAt.push(SECOND);
          break;

         case "A":
          date.setHours(0);
          date.setMinutes(0);
          date.setSeconds(0);

         case "S":
          value = Math.round(token.value * Math.pow(10, 3 - length));
          date.setMilliseconds(value);
          truncateAt.push(MILLISECONDS);
          break;

         case "z":
         case "Z":
         case "O":
         case "v":
         case "V":
         case "X":
         case "x":
          if (typeof token.value === "number") {
            timezoneOffset = token.value;
          }
          break;
        }
        return true;
      });
      if (!valid) {
        return null;
      }
      if (hour && !(!amPm ^ hour12)) {
        return null;
      }
      if (era === 0) {
        date.setFullYear(date.getFullYear() * -1 + 1);
      }
      if (month !== undefined) {
        dateSetMonth(date, month - 1);
      }
      if (day !== undefined) {
        if (outOfRange(day, 1, dateLastDayOfMonth(date))) {
          return null;
        }
        date.setDate(day);
      } else if (daysOfYear !== undefined) {
        if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) {
          return null;
        }
        date.setMonth(0);
        date.setDate(daysOfYear);
      }
      if (hour12 && amPm === "pm") {
        date.setHours(date.getHours() + 12);
      }
      if (timezoneOffset !== undefined) {
        date.setMinutes(date.getMinutes() + timezoneOffset - date.getTimezoneOffset());
      }
      truncateAt = Math.max.apply(null, truncateAt);
      date = dateStartOf(date, units[truncateAt]);
      if (date instanceof ZonedDateTime) {
        date = date.toDate();
      }
      return date;
    };
    var dateTokenizer = function(value, numberParser, properties) {
      var digitsRe, valid, tokens = [], widths = [ "abbreviated", "wide", "narrow" ];
      digitsRe = properties.digitsRe;
      value = looseMatching(value);
      valid = properties.pattern.match(datePatternRe).every(function(current) {
        var aux, chr, length, numeric, tokenRe, token = {};
        function hourFormatParse(tokenRe, numberParser) {
          var aux, isPositive, match = value.match(tokenRe);
          numberParser = numberParser || function(value) {
            return +value;
          };
          if (!match) {
            return false;
          }
          isPositive = match[1];
          if (match.length < 6) {
            aux = isPositive ? 1 : 3;
            token.value = numberParser(match[aux]) * 60;
          } else if (match.length < 10) {
            aux = isPositive ? [ 1, 3 ] : [ 5, 7 ];
            token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]);
          } else {
            aux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];
            token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]) + numberParser(match[aux[2]]) / 60;
          }
          if (isPositive) {
            token.value *= -1;
          }
          return true;
        }
        function oneDigitIfLengthOne() {
          if (length === 1) {
            numeric = true;
            return tokenRe = digitsRe;
          }
        }
        function oneOrTwoDigitsIfLengthOne() {
          if (length === 1) {
            numeric = true;
            return tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
          }
        }
        function oneOrTwoDigitsIfLengthOneOrTwo() {
          if (length === 1 || length === 2) {
            numeric = true;
            return tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
          }
        }
        function twoDigitsIfLengthTwo() {
          if (length === 2) {
            numeric = true;
            return tokenRe = new RegExp("^(" + digitsRe.source + "){2}");
          }
        }
        function lookup(path) {
          var array = properties[path.join("/")];
          if (!array) {
            return null;
          }
          array.some(function(item) {
            var valueRe = item[1];
            if (valueRe.test(value)) {
              token.value = item[0];
              tokenRe = item[1];
              return true;
            }
          });
          return null;
        }
        token.type = current;
        chr = current.charAt(0);
        length = current.length;
        if (chr === "Z") {
          if (length < 4) {
            chr = "x";
            length = 4;
          } else if (length < 5) {
            chr = "O";
            length = 4;
          } else {
            chr = "X";
            length = 5;
          }
        }
        if (chr === "z") {
          if (properties.standardOrDaylightTzName) {
            token.value = null;
            tokenRe = properties.standardOrDaylightTzName;
          }
        }
        if (chr === "v") {
          if (properties.genericTzName) {
            token.value = null;
            tokenRe = properties.genericTzName;
          } else {
            chr = "V";
            length = 4;
          }
        }
        if (chr === "V" && properties.timeZoneName) {
          token.value = length === 2 ? properties.timeZoneName : null;
          tokenRe = properties.timeZoneNameRe;
        }
        switch (chr) {
         case "G":
          lookup([ "gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
          break;

         case "y":
         case "Y":
          numeric = true;
          if (length === 1) {
            tokenRe = new RegExp("^(" + digitsRe.source + ")+");
          } else if (length === 2) {
            tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
          } else {
            tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + ",}");
          }
          break;

         case "Q":
         case "q":
          oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([ "gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
          break;

         case "M":
         case "L":
          oneOrTwoDigitsIfLengthOneOrTwo() || lookup([ "gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
          break;

         case "D":
          if (length <= 3) {
            numeric = true;
            tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + ",3}");
          }
          break;

         case "W":
         case "F":
          oneDigitIfLengthOne();
          break;

         case "e":
         case "c":
          if (length <= 2) {
            oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
            break;
          }

         case "E":
          if (length === 6) {
            lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "short" ]) || lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "abbreviated" ]);
          } else {
            lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], widths[length < 3 ? 0 : length - 3] ]);
          }
          break;

         case "a":
          lookup([ "gregorian/dayPeriods/format/wide" ]);
          break;

         case "w":
          oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
          break;

         case "d":
         case "h":
         case "H":
         case "K":
         case "k":
         case "j":
         case "m":
         case "s":
          oneOrTwoDigitsIfLengthOneOrTwo();
          break;

         case "S":
          numeric = true;
          tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + "}");
          break;

         case "A":
          numeric = true;
          tokenRe = new RegExp("^(" + digitsRe.source + "){" + (length + 5) + "}");
          break;

         case "v":
         case "V":
         case "z":
          if (tokenRe && tokenRe.test(value)) {
            break;
          }
          if (chr === "V" && length === 2) {
            break;
          }

         case "O":
          if (value === properties["timeZoneNames/gmtZeroFormat"]) {
            token.value = 0;
            tokenRe = properties["timeZoneNames/gmtZeroFormatRe"];
          } else {
            aux = properties["timeZoneNames/hourFormat"].some(function(hourFormatRe) {
              if (hourFormatParse(hourFormatRe, numberParser)) {
                tokenRe = hourFormatRe;
                return true;
              }
            });
            if (!aux) {
              return null;
            }
          }
          break;

         case "X":
          if (value === "Z") {
            token.value = 0;
            tokenRe = /^Z/;
            break;
          }

         case "x":
          aux = properties.x.some(function(hourFormatRe) {
            if (hourFormatParse(hourFormatRe)) {
              tokenRe = hourFormatRe;
              return true;
            }
          });
          if (!aux) {
            return null;
          }
          break;

         case "'":
          token.type = "literal";
          tokenRe = new RegExp("^" + regexpEscape(removeLiteralQuotes(current)));
          break;

         default:
          token.type = "literal";
          tokenRe = new RegExp("^" + regexpEscape(current));
        }
        if (!tokenRe) {
          return false;
        }
        value = value.replace(tokenRe, function(lexeme) {
          token.lexeme = lexeme;
          if (numeric) {
            token.value = numberParser(lexeme);
          }
          return "";
        });
        if (!token.lexeme) {
          return false;
        }
        if (numeric && isNaN(token.value)) {
          return false;
        }
        tokens.push(token);
        return true;
      });
      if (value !== "") {
        valid = false;
      }
      return valid ? tokens : [];
    };
    var dateParserFn = function(numberParser, parseProperties, tokenizerProperties) {
      return function dateParser(value) {
        var tokens;
        validateParameterPresence(value, "value");
        validateParameterTypeString(value, "value");
        tokens = dateTokenizer(value, numberParser, tokenizerProperties);
        return dateParse(value, tokens, parseProperties) || null;
      };
    };
    var objectFilter = function(object, testRe) {
      var key, copy = {};
      for (key in object) {
        if (testRe.test(key)) {
          copy[key] = object[key];
        }
      }
      return copy;
    };
    var dateTokenizerProperties = function(pattern, cldr, timeZone) {
      var digitsReSource, properties = {
        pattern: looseMatching(pattern)
      }, timeSeparator = numberSymbol("timeSeparator", cldr), widths = [ "abbreviated", "wide", "narrow" ];
      digitsReSource = numberNumberingSystemDigitsMap(cldr);
      digitsReSource = digitsReSource ? "[" + digitsReSource + "]" : "\\d";
      properties.digitsRe = new RegExp(digitsReSource);
      function hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator) {
        var re;
        if (!digitsReSource) {
          digitsReSource = "\\d";
        }
        if (!gmtFormat) {
          gmtFormat = "{0}";
        }
        re = hourFormat.replace("+", "\\+").replace(/HH|mm|ss/g, "((" + digitsReSource + "){2})").replace(/H|m/g, "((" + digitsReSource + "){1,2})");
        if (timeSeparator) {
          re = re.replace(/:/g, timeSeparator);
        }
        re = re.split(";").map(function(part) {
          return gmtFormat.replace("{0}", part);
        }).join("|");
        return new RegExp("^" + re);
      }
      function populateProperties(path, value) {
        var skipRe = /(timeZoneNames\/zone|supplemental\/metaZones|timeZoneNames\/metazone|timeZoneNames\/regionFormat|timeZoneNames\/gmtFormat)/;
        if (skipRe.test(path)) {
          return;
        }
        if (!value) {
          return;
        }
        path = path.replace(/^.*\/dates\//, "").replace(/calendars\//, "");
        if (path === "gregorian/dayPeriods/format/wide") {
          value = objectFilter(value, /^am|^pm/);
        }
        if (isPlainObject(value)) {
          value = Object.keys(value).map(function(key) {
            return [ key, new RegExp("^" + regexpEscape(looseMatching(value[key]))) ];
          }).sort(function(a, b) {
            return b[1].source.length - a[1].source.length;
          });
        } else {
          value = looseMatching(value);
        }
        properties[path] = value;
      }
      function regexpSourceSomeTerm(terms) {
        return "(" + terms.filter(function(item) {
          return item;
        }).reduce(function(memo, item) {
          return memo + "|" + item;
        }) + ")";
      }
      cldr.on("get", populateProperties);
      pattern.match(datePatternRe).forEach(function(current) {
        var aux, chr, daylightTzName, gmtFormat, length, standardTzName;
        chr = current.charAt(0);
        length = current.length;
        if (chr === "Z") {
          if (length < 5) {
            chr = "O";
            length = 4;
          } else {
            chr = "X";
            length = 5;
          }
        }
        if (chr === "z") {
          standardTzName = dateGetTimeZoneName(length, "standard", timeZone, cldr);
          daylightTzName = dateGetTimeZoneName(length, "daylight", timeZone, cldr);
          if (standardTzName) {
            standardTzName = regexpEscape(looseMatching(standardTzName));
          }
          if (daylightTzName) {
            daylightTzName = regexpEscape(looseMatching(daylightTzName));
          }
          if (standardTzName || daylightTzName) {
            properties.standardOrDaylightTzName = new RegExp("^" + regexpSourceSomeTerm([ standardTzName, daylightTzName ]));
          }
          if (!standardTzName || !daylightTzName) {
            chr = "O";
            if (length < 4) {
              length = 1;
            }
          }
        }
        if (chr === "v") {
          if (length !== 1 && length !== 4) {
            throw createErrorUnsupportedFeature({
              feature: "timezone pattern `" + pattern + "`"
            });
          }
          var genericTzName = dateGetTimeZoneName(length, "generic", timeZone, cldr);
          if (genericTzName) {
            properties.genericTzName = new RegExp("^" + regexpEscape(looseMatching(genericTzName)));
            chr = "O";
          } else {
            chr = "V";
            length = 4;
          }
        }
        switch (chr) {
         case "G":
          cldr.main([ "dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
          break;

         case "u":
         case "U":
          throw createErrorUnsupportedFeature({
            feature: "year pattern `" + chr + "`"
          });

         case "Q":
         case "q":
          if (length > 2) {
            cldr.main([ "dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
          }
          break;

         case "M":
         case "L":
          if (length > 2) {
            cldr.main([ "dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
          }
          break;

         case "g":
          throw createErrorUnsupportedFeature({
            feature: "Julian day pattern `g`"
          });

         case "e":
         case "c":
          if (length <= 2) {
            break;
          }

         case "E":
          if (length === 6) {
            cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "short" ]) || cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "abbreviated" ]);
          } else {
            cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], widths[length < 3 ? 0 : length - 3] ]);
          }
          break;

         case "a":
          cldr.main("dates/calendars/gregorian/dayPeriods/format/wide");
          break;

         case "V":
          if (length === 1) {
            throw createErrorUnsupportedFeature({
              feature: "timezone pattern `" + pattern + "`"
            });
          }
          if (timeZone) {
            if (length === 2) {
              properties.timeZoneName = timeZone;
              properties.timeZoneNameRe = new RegExp("^" + regexpEscape(timeZone));
              break;
            }
            var timeZoneName, exemplarCity = cldr.main([ "dates/timeZoneNames/zone", timeZone, "exemplarCity" ]);
            if (length === 3) {
              if (!exemplarCity) {
                exemplarCity = cldr.main([ "dates/timeZoneNames/zone/Etc/Unknown/exemplarCity" ]);
              }
              timeZoneName = exemplarCity;
            }
            if (exemplarCity && length === 4) {
              timeZoneName = formatMessage(cldr.main("dates/timeZoneNames/regionFormat"), [ exemplarCity ]);
            }
            if (timeZoneName) {
              timeZoneName = looseMatching(timeZoneName);
              properties.timeZoneName = timeZoneName;
              properties.timeZoneNameRe = new RegExp("^" + regexpEscape(timeZoneName));
            }
          }
          if (current === "v") {
            length = 1;
          }

         case "z":
         case "O":
          gmtFormat = cldr.main("dates/timeZoneNames/gmtFormat");
          cldr.main("dates/timeZoneNames/gmtZeroFormat");
          cldr.main("dates/timeZoneNames/hourFormat");
          properties["timeZoneNames/gmtZeroFormatRe"] = new RegExp("^" + regexpEscape(properties["timeZoneNames/gmtZeroFormat"]));
          aux = properties["timeZoneNames/hourFormat"];
          properties["timeZoneNames/hourFormat"] = (length < 4 ? [ dateTimezoneHourFormatHm(aux, "H"), dateTimezoneHourFormatH(aux) ] : [ dateTimezoneHourFormatHm(aux, "HH") ]).map(function(hourFormat) {
            return hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator);
          });

         case "X":
         case "x":
          properties.x = [ [ "+HHmm;-HHmm", "+HH;-HH" ], [ "+HHmm;-HHmm" ], [ "+HH:mm;-HH:mm" ], [ "+HHmmss;-HHmmss", "+HHmm;-HHmm" ], [ "+HH:mm:ss;-HH:mm:ss", "+HH:mm;-HH:mm" ] ][length - 1].map(function(hourFormat) {
            return hourFormatRe(hourFormat);
          });
        }
      });
      cldr.off("get", populateProperties);
      return properties;
    };
    var dateDayOfWeek = function(date, firstDay) {
      return (date.getDay() - firstDay + 7) % 7;
    };
    var dateDistanceInDays = function(from, to) {
      var inDays = 864e5;
      return (to.getTime() - from.getTime()) / inDays;
    };
    var dateDayOfYear = function(date) {
      return Math.floor(dateDistanceInDays(dateStartOf(date, "year"), date));
    };
    var dateFieldsMap = objectInvert({
      era: "G",
      year: "yY",
      quarter: "qQ",
      month: "ML",
      week: "wW",
      day: "dDF",
      weekday: "ecE",
      dayperiod: "a",
      hour: "hHkK",
      minute: "m",
      second: "sSA",
      zone: "zvVOxX"
    }, function(object, key, value) {
      value.split("").forEach(function(symbol) {
        object[symbol] = key;
      });
      return object;
    });
    var dateMillisecondsInDay = function(date) {
      return date - dateStartOf(date, "day");
    };
    var dateTimezoneHourFormat = function(date, format, timeSeparator, formatNumber) {
      var absOffset, offset = date.getTimezoneOffset();
      absOffset = Math.abs(offset);
      formatNumber = formatNumber || {
        1: function(value) {
          return stringPad(value, 1);
        },
        2: function(value) {
          return stringPad(value, 2);
        }
      };
      return format.split(";")[offset > 0 ? 1 : 0].replace(":", timeSeparator).replace(/HH?/, function(match) {
        return formatNumber[match.length](Math.floor(absOffset / 60));
      }).replace(/mm/, function() {
        return formatNumber[2](Math.floor(absOffset % 60));
      }).replace(/ss/, function() {
        return formatNumber[2](Math.floor(absOffset % 1 * 60));
      });
    };
    var dateFormat = function(date, numberFormatters, properties) {
      var parts = [];
      var timeSeparator = properties.timeSeparator;
      if (properties.timeZoneData) {
        date = new ZonedDateTime(date, properties.timeZoneData());
      }
      properties.pattern.replace(datePatternRe, function(current) {
        var aux, dateField, type, value, chr = current.charAt(0), length = current.length;
        if (chr === "j") {
          chr = properties.preferredTime;
        }
        if (chr === "Z") {
          if (length < 4) {
            chr = "x";
            length = 4;
          } else if (length < 5) {
            chr = "O";
            length = 4;
          } else {
            chr = "X";
            length = 5;
          }
        }
        if (chr === "z") {
          if (date.isDST) {
            value = date.isDST() ? properties.daylightTzName : properties.standardTzName;
          }
          if (!value) {
            chr = "O";
            if (length < 4) {
              length = 1;
            }
          }
        }
        switch (chr) {
         case "G":
          value = properties.eras[date.getFullYear() < 0 ? 0 : 1];
          break;

         case "y":
          value = date.getFullYear();
          if (length === 2) {
            value = String(value);
            value = +value.substr(value.length - 2);
          }
          break;

         case "Y":
          value = new Date(date.getTime());
          value.setDate(value.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays);
          value = value.getFullYear();
          if (length === 2) {
            value = String(value);
            value = +value.substr(value.length - 2);
          }
          break;

         case "Q":
         case "q":
          value = Math.ceil((date.getMonth() + 1) / 3);
          if (length > 2) {
            value = properties.quarters[chr][length][value];
          }
          break;

         case "M":
         case "L":
          value = date.getMonth() + 1;
          if (length > 2) {
            value = properties.months[chr][length][value];
          }
          break;

         case "w":
          value = dateDayOfWeek(dateStartOf(date, "year"), properties.firstDay);
          value = Math.ceil((dateDayOfYear(date) + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);
          break;

         case "W":
          value = dateDayOfWeek(dateStartOf(date, "month"), properties.firstDay);
          value = Math.ceil((date.getDate() + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);
          break;

         case "d":
          value = date.getDate();
          break;

         case "D":
          value = dateDayOfYear(date) + 1;
          break;

         case "F":
          value = Math.floor(date.getDate() / 7) + 1;
          break;

         case "e":
         case "c":
          if (length <= 2) {
            value = dateDayOfWeek(date, properties.firstDay) + 1;
            break;
          }

         case "E":
          value = dateWeekDays[date.getDay()];
          value = properties.days[chr][length][value];
          break;

         case "a":
          value = properties.dayPeriods[date.getHours() < 12 ? "am" : "pm"];
          break;

         case "h":
          value = date.getHours() % 12 || 12;
          break;

         case "H":
          value = date.getHours();
          break;

         case "K":
          value = date.getHours() % 12;
          break;

         case "k":
          value = date.getHours() || 24;
          break;

         case "m":
          value = date.getMinutes();
          break;

         case "s":
          value = date.getSeconds();
          break;

         case "S":
          value = Math.round(date.getMilliseconds() * Math.pow(10, length - 3));
          break;

         case "A":
          value = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3));
          break;

         case "z":
          break;

         case "v":
          if (properties.genericTzName) {
            value = properties.genericTzName;
            break;
          }

         case "V":
          if (properties.timeZoneName) {
            value = properties.timeZoneName;
            break;
          }
          if (current === "v") {
            length = 1;
          }

         case "O":
          if (date.getTimezoneOffset() === 0) {
            value = properties.gmtZeroFormat;
          } else {
            if (length < 4) {
              aux = date.getTimezoneOffset();
              aux = properties.hourFormat[aux % 60 - aux % 1 === 0 ? 0 : 1];
            } else {
              aux = properties.hourFormat;
            }
            value = dateTimezoneHourFormat(date, aux, timeSeparator, numberFormatters);
            value = properties.gmtFormat.replace(/\{0\}/, value);
          }
          break;

         case "X":
          if (date.getTimezoneOffset() === 0) {
            value = "Z";
            break;
          }

         case "x":
          aux = date.getTimezoneOffset();
          if (length === 1 && aux % 60 - aux % 1 !== 0) {
            length += 1;
          }
          if ((length === 4 || length === 5) && aux % 1 === 0) {
            length -= 2;
          }
          value = [ "+HH;-HH", "+HHmm;-HHmm", "+HH:mm;-HH:mm", "+HHmmss;-HHmmss", "+HH:mm:ss;-HH:mm:ss" ][length - 1];
          value = dateTimezoneHourFormat(date, value, ":");
          break;

         case ":":
          value = timeSeparator;
          break;

         case "'":
          value = removeLiteralQuotes(current);
          break;

         default:
          value = current;
        }
        if (typeof value === "number") {
          value = numberFormatters[length](value);
        }
        dateField = dateFieldsMap[chr];
        type = dateField ? dateField : "literal";
        if (type === "literal" && parts.length && parts[parts.length - 1].type === "literal") {
          parts[parts.length - 1].value += value;
          return;
        }
        parts.push({
          type: type,
          value: value
        });
      });
      return parts;
    };
    var dateToPartsFormatterFn = function(numberFormatters, properties) {
      return function dateToPartsFormatter(value) {
        validateParameterPresence(value, "value");
        validateParameterTypeDate(value, "value");
        return dateFormat(value, numberFormatters, properties);
      };
    };
    function optionsHasStyle(options) {
      return options.skeleton !== undefined || options.date !== undefined || options.time !== undefined || options.datetime !== undefined || options.raw !== undefined;
    }
    function validateRequiredCldr(path, value) {
      validateCldr(path, value, {
        skip: [ /dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/, /dates\/calendars\/gregorian\/days\/.*\/short/, /dates\/timeZoneNames\/zone/, /dates\/timeZoneNames\/metazone/, /globalize-iana/, /supplemental\/metaZones/, /supplemental\/timeData\/(?!001)/, /supplemental\/weekData\/(?!001)/ ]
      });
    }
    function validateOptionsPreset(options) {
      validateOptionsPresetEach("date", options);
      validateOptionsPresetEach("time", options);
      validateOptionsPresetEach("datetime", options);
    }
    function validateOptionsPresetEach(type, options) {
      var value = options[type];
      validate("E_INVALID_OPTIONS", 'Invalid `{{type}: "{value}"}`.', value === undefined || [ "short", "medium", "long", "full" ].indexOf(value) !== -1, {
        type: type,
        value: value
      });
    }
    function validateOptionsSkeleton(pattern, skeleton) {
      validate("E_INVALID_OPTIONS", 'Invalid `{skeleton: "{value}"}` based on provided CLDR.', skeleton === undefined || typeof pattern === "string" && pattern, {
        type: "skeleton",
        value: skeleton
      });
    }
    function validateRequiredIana(timeZone) {
      return function(path, value) {
        if (!/globalize-iana/.test(path)) {
          return;
        }
        validate("E_MISSING_IANA_TZ", "Missing required IANA timezone content for `{timeZone}`: `{path}`.", value, {
          path: path.replace(/globalize-iana\//, ""),
          timeZone: timeZone
        });
      };
    }
    Globalize.loadTimeZone = function(json) {
      var customData = {
        "globalize-iana": json
      };
      validateParameterPresence(json, "json");
      validateParameterTypePlainObject(json, "json");
      Cldr.load(customData);
    };
    Globalize.dateFormatter = Globalize.prototype.dateFormatter = function(options) {
      var args, dateToPartsFormatter, returnFn;
      validateParameterTypePlainObject(options, "options");
      options = options || {};
      if (!optionsHasStyle(options)) {
        options.skeleton = "yMd";
      }
      args = [ options ];
      dateToPartsFormatter = this.dateToPartsFormatter(options);
      returnFn = dateFormatterFn(dateToPartsFormatter);
      runtimeBind(args, this.cldr, returnFn, [ dateToPartsFormatter ]);
      return returnFn;
    };
    Globalize.dateToPartsFormatter = Globalize.prototype.dateToPartsFormatter = function(options) {
      var args, cldr, numberFormatters, pad, pattern, properties, returnFn, timeZone, ianaListener;
      validateParameterTypePlainObject(options, "options");
      cldr = this.cldr;
      options = options || {};
      if (!optionsHasStyle(options)) {
        options.skeleton = "yMd";
      }
      validateOptionsPreset(options);
      validateDefaultLocale(cldr);
      timeZone = options.timeZone;
      validateParameterTypeString(timeZone, "options.timeZone");
      args = [ options ];
      cldr.on("get", validateRequiredCldr);
      if (timeZone) {
        ianaListener = validateRequiredIana(timeZone);
        cldr.on("get", ianaListener);
      }
      pattern = dateExpandPattern(options, cldr);
      validateOptionsSkeleton(pattern, options.skeleton);
      properties = dateFormatProperties(pattern, cldr, timeZone);
      cldr.off("get", validateRequiredCldr);
      if (ianaListener) {
        cldr.off("get", ianaListener);
      }
      numberFormatters = properties.numberFormatters;
      delete properties.numberFormatters;
      for (pad in numberFormatters) {
        numberFormatters[pad] = this.numberFormatter({
          raw: numberFormatters[pad]
        });
      }
      returnFn = dateToPartsFormatterFn(numberFormatters, properties);
      runtimeBind(args, cldr, returnFn, [ numberFormatters, properties ]);
      return returnFn;
    };
    Globalize.dateParser = Globalize.prototype.dateParser = function(options) {
      var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone, tokenizerProperties;
      validateParameterTypePlainObject(options, "options");
      cldr = this.cldr;
      options = options || {};
      if (!optionsHasStyle(options)) {
        options.skeleton = "yMd";
      }
      validateOptionsPreset(options);
      validateDefaultLocale(cldr);
      timeZone = options.timeZone;
      validateParameterTypeString(timeZone, "options.timeZone");
      args = [ options ];
      cldr.on("get", validateRequiredCldr);
      if (timeZone) {
        cldr.on("get", validateRequiredIana(timeZone));
      }
      pattern = dateExpandPattern(options, cldr);
      validateOptionsSkeleton(pattern, options.skeleton);
      tokenizerProperties = dateTokenizerProperties(pattern, cldr, timeZone);
      parseProperties = dateParseProperties(cldr, timeZone);
      cldr.off("get", validateRequiredCldr);
      if (timeZone) {
        cldr.off("get", validateRequiredIana(timeZone));
      }
      numberParser = this.numberParser({
        raw: "0"
      });
      returnFn = dateParserFn(numberParser, parseProperties, tokenizerProperties);
      runtimeBind(args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ]);
      return returnFn;
    };
    Globalize.formatDate = Globalize.prototype.formatDate = function(value, options) {
      validateParameterPresence(value, "value");
      validateParameterTypeDate(value, "value");
      return this.dateFormatter(options)(value);
    };
    Globalize.formatDateToParts = Globalize.prototype.formatDateToParts = function(value, options) {
      validateParameterPresence(value, "value");
      validateParameterTypeDate(value, "value");
      return this.dateToPartsFormatter(options)(value);
    };
    Globalize.parseDate = Globalize.prototype.parseDate = function(value, options) {
      validateParameterPresence(value, "value");
      validateParameterTypeString(value, "value");
      return this.dateParser(options)(value);
    };
    return Globalize;
  });
}, function(module, exports, __webpack_require__) {
  !(module.exports = {
    APP_NAME: "Web Banking",
    DEFAULT_CURRENCY: "RUR",
    ADD_AUTH_METHODS: [ "otp_sms", "otp_list", "otp_mma" ],
    BANNER_ROTATION_INTERVAL_SECONDS: 10,
    LOGGER_NAME: "wb_client",
    POSTAL_CODE_LENGTH: 6,
    PAYMENTS_MENU_ITEMS_DEFAULT_LENGTH: 15,
    DEFAULT_LIMIT: 5e4,
    LOCALE_OPTIONS: [ {
      id: "ru",
      name: ""
    }, {
      id: "en",
      name: "English"
    } ],
    MOBILE_PAYMENTS_SERVICES: [ "MEGAFONE_KZ", "BEELINE", "MEGAFONE_MSK", "MEGAFONE_URAL", "TELE2", "MEGAFONE_FAR_EAST", "MEGAFONE_SZ", "MTS", "MOBILE_PAY", "MEGAFONE_SIB", "SKYLINK", "MWB_MOBILE_PAYMENT", "MOBILE" ],
    INVOICE_SERVICES: [ "INVOICE_PAY_TABLE" ],
    LOGIN_PATTERN: /^[A-Za-z0-9]*$/,
    USE_TILED_PAYMENTS_PAGE: false,
    AUTH_OTP_SMS_MAXLENGTH: 7,
    AUTH_OTP_SMS_IS_NUMERIC: false,
    AUTH_OTP_LIST_IS_NUMERIC: false,
    AUTH_OTP_MMA_MAXLENGTH: 6,
    USE_REST_APPLICATION_HISTORY: false,
    USE_REST_TRANSACTION_WINDOW: false,
    DEPOSIT_CALCULATOR: {},
    INFORMATION_SERVICES: [],
    EGW_WINDOW_WIDTH: 960,
    EGW_WINDOW_HEIGHT: 350
  });
}, function(module, exports, __webpack_require__) {
  (function($, _) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      __webpack_require__(0);
      __webpack_require__(6);
      var moment = __webpack_require__(7), requireConfig = __webpack_require__(9);
      var exports = {};
      if (!Modernizr.localstorage) {
        console.warn("localStorage not available.  This is most likely caused by iOS Safari Private mode");
      }
      exports.initDefaultSettings = function(settings) {
        settings.loadPromise = new $.Deferred();
        var mainConf = settings.API_URL + "/conf/main.js";
        requireConfig(mainConf).done(function() {
          console.assert(window.OW.mainConfig, "Missing conf/main.js configuration file");
          _.extend(settings, window.OW.mainConfig);
          settings.loadPromise.resolve();
        }).fail(settings.loadPromise.resolve);
      };
      return exports;
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(1), __webpack_require__(0));
}, function(module, exports) {
  function webpackEmptyContext(req) {
    throw new Error("Cannot find module '" + req + "'.");
  }
  webpackEmptyContext.keys = function() {
    return [];
  };
  webpackEmptyContext.resolve = webpackEmptyContext;
  module.exports = webpackEmptyContext;
  webpackEmptyContext.id = 34;
}, function(module, exports) {
  module.exports = {
    supplemental: {
      version: {
        _cldrVersion: "28",
        _unicodeVersion: "8.0.0",
        _number: "$Revision: 11965 $"
      },
      likelySubtags: {
        aa: "aa-Latn-ET",
        ab: "ab-Cyrl-GE",
        abr: "abr-Latn-GH",
        ace: "ace-Latn-ID",
        ach: "ach-Latn-UG",
        ada: "ada-Latn-GH",
        ady: "ady-Cyrl-RU",
        ae: "ae-Avst-IR",
        aeb: "aeb-Arab-TN",
        af: "af-Latn-ZA",
        agq: "agq-Latn-CM",
        aho: "aho-Ahom-IN",
        ak: "ak-Latn-GH",
        akk: "akk-Xsux-IQ",
        aln: "aln-Latn-XK",
        alt: "alt-Cyrl-RU",
        am: "am-Ethi-ET",
        amo: "amo-Latn-NG",
        aoz: "aoz-Latn-ID",
        ar: "ar-Arab-EG",
        arc: "arc-Armi-IR",
        "arc-Nbat": "arc-Nbat-JO",
        "arc-Palm": "arc-Palm-SY",
        arn: "arn-Latn-CL",
        aro: "aro-Latn-BO",
        arq: "arq-Arab-DZ",
        ary: "ary-Arab-MA",
        arz: "arz-Arab-EG",
        as: "as-Beng-IN",
        asa: "asa-Latn-TZ",
        ase: "ase-Sgnw-US",
        ast: "ast-Latn-ES",
        atj: "atj-Latn-CA",
        av: "av-Cyrl-RU",
        awa: "awa-Deva-IN",
        ay: "ay-Latn-BO",
        az: "az-Latn-AZ",
        "az-Arab": "az-Arab-IR",
        "az-IQ": "az-Arab-IQ",
        "az-IR": "az-Arab-IR",
        "az-RU": "az-Cyrl-RU",
        ba: "ba-Cyrl-RU",
        bal: "bal-Arab-PK",
        ban: "ban-Latn-ID",
        bap: "bap-Deva-NP",
        bar: "bar-Latn-AT",
        bas: "bas-Latn-CM",
        bax: "bax-Bamu-CM",
        bbc: "bbc-Latn-ID",
        bbj: "bbj-Latn-CM",
        bci: "bci-Latn-CI",
        be: "be-Cyrl-BY",
        bej: "bej-Arab-SD",
        bem: "bem-Latn-ZM",
        bew: "bew-Latn-ID",
        bez: "bez-Latn-TZ",
        bfd: "bfd-Latn-CM",
        bfq: "bfq-Taml-IN",
        bft: "bft-Arab-PK",
        bfy: "bfy-Deva-IN",
        bg: "bg-Cyrl-BG",
        bgc: "bgc-Deva-IN",
        bgn: "bgn-Arab-PK",
        bgx: "bgx-Grek-TR",
        bh: "bh-Kthi-IN",
        bhb: "bhb-Deva-IN",
        bhi: "bhi-Deva-IN",
        bhk: "bhk-Latn-PH",
        bho: "bho-Deva-IN",
        bi: "bi-Latn-VU",
        bik: "bik-Latn-PH",
        bin: "bin-Latn-NG",
        bjj: "bjj-Deva-IN",
        bjn: "bjn-Latn-ID",
        bkm: "bkm-Latn-CM",
        bku: "bku-Latn-PH",
        blt: "blt-Tavt-VN",
        bm: "bm-Latn-ML",
        bmq: "bmq-Latn-ML",
        bn: "bn-Beng-BD",
        bo: "bo-Tibt-CN",
        bpy: "bpy-Beng-IN",
        bqi: "bqi-Arab-IR",
        bqv: "bqv-Latn-CI",
        br: "br-Latn-FR",
        bra: "bra-Deva-IN",
        brh: "brh-Arab-PK",
        brx: "brx-Deva-IN",
        bs: "bs-Latn-BA",
        bsq: "bsq-Bass-LR",
        bss: "bss-Latn-CM",
        bto: "bto-Latn-PH",
        btv: "btv-Deva-PK",
        bua: "bua-Cyrl-RU",
        buc: "buc-Latn-YT",
        bug: "bug-Latn-ID",
        bum: "bum-Latn-CM",
        bvb: "bvb-Latn-GQ",
        byn: "byn-Ethi-ER",
        byv: "byv-Latn-CM",
        bze: "bze-Latn-ML",
        ca: "ca-Latn-ES",
        cch: "cch-Latn-NG",
        ccp: "ccp-Beng-IN",
        "ccp-Cakm": "ccp-Cakm-BD",
        ce: "ce-Cyrl-RU",
        ceb: "ceb-Latn-PH",
        cgg: "cgg-Latn-UG",
        ch: "ch-Latn-GU",
        chk: "chk-Latn-FM",
        chm: "chm-Cyrl-RU",
        cho: "cho-Latn-US",
        chp: "chp-Latn-CA",
        chr: "chr-Cher-US",
        cja: "cja-Arab-KH",
        cjm: "cjm-Cham-VN",
        ckb: "ckb-Arab-IQ",
        co: "co-Latn-FR",
        cop: "cop-Copt-EG",
        cps: "cps-Latn-PH",
        cr: "cr-Cans-CA",
        crj: "crj-Cans-CA",
        crk: "crk-Cans-CA",
        crl: "crl-Cans-CA",
        crm: "crm-Cans-CA",
        crs: "crs-Latn-SC",
        cs: "cs-Latn-CZ",
        csb: "csb-Latn-PL",
        csw: "csw-Cans-CA",
        ctd: "ctd-Pauc-MM",
        cu: "cu-Cyrl-RU",
        "cu-Glag": "cu-Glag-BG",
        cv: "cv-Cyrl-RU",
        cy: "cy-Latn-GB",
        da: "da-Latn-DK",
        dak: "dak-Latn-US",
        dar: "dar-Cyrl-RU",
        dav: "dav-Latn-KE",
        dcc: "dcc-Arab-IN",
        de: "de-Latn-DE",
        den: "den-Latn-CA",
        dgr: "dgr-Latn-CA",
        dje: "dje-Latn-NE",
        dnj: "dnj-Latn-CI",
        doi: "doi-Arab-IN",
        dsb: "dsb-Latn-DE",
        dtm: "dtm-Latn-ML",
        dtp: "dtp-Latn-MY",
        dua: "dua-Latn-CM",
        dv: "dv-Thaa-MV",
        dyo: "dyo-Latn-SN",
        dyu: "dyu-Latn-BF",
        dz: "dz-Tibt-BT",
        ebu: "ebu-Latn-KE",
        ee: "ee-Latn-GH",
        efi: "efi-Latn-NG",
        egl: "egl-Latn-IT",
        egy: "egy-Egyp-EG",
        eky: "eky-Kali-MM",
        el: "el-Grek-GR",
        en: "en-Latn-US",
        "en-Shaw": "en-Shaw-GB",
        eo: "eo-Latn-001",
        es: "es-Latn-ES",
        esu: "esu-Latn-US",
        et: "et-Latn-EE",
        ett: "ett-Ital-IT",
        eu: "eu-Latn-ES",
        ewo: "ewo-Latn-CM",
        ext: "ext-Latn-ES",
        fa: "fa-Arab-IR",
        fan: "fan-Latn-GQ",
        ff: "ff-Latn-SN",
        ffm: "ffm-Latn-ML",
        fi: "fi-Latn-FI",
        fia: "fia-Arab-SD",
        fil: "fil-Latn-PH",
        fit: "fit-Latn-SE",
        fj: "fj-Latn-FJ",
        fo: "fo-Latn-FO",
        fon: "fon-Latn-BJ",
        fr: "fr-Latn-FR",
        frc: "frc-Latn-US",
        frp: "frp-Latn-FR",
        frr: "frr-Latn-DE",
        frs: "frs-Latn-DE",
        fud: "fud-Latn-WF",
        fuq: "fuq-Latn-NE",
        fur: "fur-Latn-IT",
        fuv: "fuv-Latn-NG",
        fvr: "fvr-Latn-SD",
        fy: "fy-Latn-NL",
        ga: "ga-Latn-IE",
        gaa: "gaa-Latn-GH",
        gag: "gag-Latn-MD",
        gan: "gan-Hans-CN",
        gay: "gay-Latn-ID",
        gbm: "gbm-Deva-IN",
        gbz: "gbz-Arab-IR",
        gcr: "gcr-Latn-GF",
        gd: "gd-Latn-GB",
        gez: "gez-Ethi-ET",
        ggn: "ggn-Deva-NP",
        gil: "gil-Latn-KI",
        gjk: "gjk-Arab-PK",
        gju: "gju-Arab-PK",
        gl: "gl-Latn-ES",
        glk: "glk-Arab-IR",
        gn: "gn-Latn-PY",
        gom: "gom-Deva-IN",
        gon: "gon-Telu-IN",
        gor: "gor-Latn-ID",
        gos: "gos-Latn-NL",
        got: "got-Goth-UA",
        grc: "grc-Cprt-CY",
        "grc-Linb": "grc-Linb-GR",
        grt: "grt-Beng-IN",
        gsw: "gsw-Latn-CH",
        gu: "gu-Gujr-IN",
        gub: "gub-Latn-BR",
        guc: "guc-Latn-CO",
        gur: "gur-Latn-GH",
        guz: "guz-Latn-KE",
        gv: "gv-Latn-IM",
        gvr: "gvr-Deva-NP",
        gwi: "gwi-Latn-CA",
        ha: "ha-Latn-NG",
        "ha-CM": "ha-Arab-CM",
        "ha-SD": "ha-Arab-SD",
        hak: "hak-Hans-CN",
        haw: "haw-Latn-US",
        haz: "haz-Arab-AF",
        he: "he-Hebr-IL",
        hi: "hi-Deva-IN",
        hif: "hif-Latn-FJ",
        hil: "hil-Latn-PH",
        hlu: "hlu-Hluw-TR",
        hmd: "hmd-Plrd-CN",
        hnd: "hnd-Arab-PK",
        hne: "hne-Deva-IN",
        hnj: "hnj-Hmng-LA",
        hnn: "hnn-Latn-PH",
        hno: "hno-Arab-PK",
        ho: "ho-Latn-PG",
        hoc: "hoc-Deva-IN",
        hoj: "hoj-Deva-IN",
        hr: "hr-Latn-HR",
        hsb: "hsb-Latn-DE",
        hsn: "hsn-Hans-CN",
        ht: "ht-Latn-HT",
        hu: "hu-Latn-HU",
        hy: "hy-Armn-AM",
        hz: "hz-Latn-NA",
        ia: "ia-Latn-FR",
        iba: "iba-Latn-MY",
        ibb: "ibb-Latn-NG",
        id: "id-Latn-ID",
        ig: "ig-Latn-NG",
        ii: "ii-Yiii-CN",
        ik: "ik-Latn-US",
        ikt: "ikt-Latn-CA",
        ilo: "ilo-Latn-PH",
        in: "in-Latn-ID",
        inh: "inh-Cyrl-RU",
        is: "is-Latn-IS",
        it: "it-Latn-IT",
        iu: "iu-Cans-CA",
        iw: "iw-Hebr-IL",
        izh: "izh-Latn-RU",
        ja: "ja-Jpan-JP",
        jam: "jam-Latn-JM",
        jgo: "jgo-Latn-CM",
        ji: "ji-Hebr-UA",
        jmc: "jmc-Latn-TZ",
        jml: "jml-Deva-NP",
        jut: "jut-Latn-DK",
        jv: "jv-Latn-ID",
        jw: "jw-Latn-ID",
        ka: "ka-Geor-GE",
        kaa: "kaa-Cyrl-UZ",
        kab: "kab-Latn-DZ",
        kac: "kac-Latn-MM",
        kaj: "kaj-Latn-NG",
        kam: "kam-Latn-KE",
        kao: "kao-Latn-ML",
        kbd: "kbd-Cyrl-RU",
        kcg: "kcg-Latn-NG",
        kck: "kck-Latn-ZW",
        kde: "kde-Latn-TZ",
        kdt: "kdt-Thai-TH",
        kea: "kea-Latn-CV",
        ken: "ken-Latn-CM",
        kfo: "kfo-Latn-CI",
        kfr: "kfr-Deva-IN",
        kfy: "kfy-Deva-IN",
        kg: "kg-Latn-CD",
        kge: "kge-Latn-ID",
        kgp: "kgp-Latn-BR",
        kha: "kha-Latn-IN",
        khb: "khb-Talu-CN",
        khn: "khn-Deva-IN",
        khq: "khq-Latn-ML",
        kht: "kht-Mymr-IN",
        khw: "khw-Arab-PK",
        ki: "ki-Latn-KE",
        kiu: "kiu-Latn-TR",
        kj: "kj-Latn-NA",
        kjg: "kjg-Laoo-LA",
        kk: "kk-Cyrl-KZ",
        "kk-AF": "kk-Arab-AF",
        "kk-Arab": "kk-Arab-CN",
        "kk-CN": "kk-Arab-CN",
        "kk-IR": "kk-Arab-IR",
        "kk-MN": "kk-Arab-MN",
        kkj: "kkj-Latn-CM",
        kl: "kl-Latn-GL",
        kln: "kln-Latn-KE",
        km: "km-Khmr-KH",
        kmb: "kmb-Latn-AO",
        kn: "kn-Knda-IN",
        ko: "ko-Kore-KR",
        koi: "koi-Cyrl-RU",
        kok: "kok-Deva-IN",
        kos: "kos-Latn-FM",
        kpe: "kpe-Latn-LR",
        krc: "krc-Cyrl-RU",
        kri: "kri-Latn-SL",
        krj: "krj-Latn-PH",
        krl: "krl-Latn-RU",
        kru: "kru-Deva-IN",
        ks: "ks-Arab-IN",
        ksb: "ksb-Latn-TZ",
        ksf: "ksf-Latn-CM",
        ksh: "ksh-Latn-DE",
        ku: "ku-Latn-TR",
        "ku-Arab": "ku-Arab-IQ",
        "ku-LB": "ku-Arab-LB",
        kum: "kum-Cyrl-RU",
        kv: "kv-Cyrl-RU",
        kvr: "kvr-Latn-ID",
        kvx: "kvx-Arab-PK",
        kw: "kw-Latn-GB",
        kxm: "kxm-Thai-TH",
        kxp: "kxp-Arab-PK",
        ky: "ky-Cyrl-KG",
        "ky-Arab": "ky-Arab-CN",
        "ky-CN": "ky-Arab-CN",
        "ky-Latn": "ky-Latn-TR",
        "ky-TR": "ky-Latn-TR",
        la: "la-Latn-VA",
        lab: "lab-Lina-GR",
        lad: "lad-Hebr-IL",
        lag: "lag-Latn-TZ",
        lah: "lah-Arab-PK",
        laj: "laj-Latn-UG",
        lb: "lb-Latn-LU",
        lbe: "lbe-Cyrl-RU",
        lbw: "lbw-Latn-ID",
        lcp: "lcp-Thai-CN",
        lep: "lep-Lepc-IN",
        lez: "lez-Cyrl-RU",
        lg: "lg-Latn-UG",
        li: "li-Latn-NL",
        lif: "lif-Deva-NP",
        "lif-Limb": "lif-Limb-IN",
        lij: "lij-Latn-IT",
        lis: "lis-Lisu-CN",
        ljp: "ljp-Latn-ID",
        lki: "lki-Arab-IR",
        lkt: "lkt-Latn-US",
        lmn: "lmn-Telu-IN",
        lmo: "lmo-Latn-IT",
        ln: "ln-Latn-CD",
        lo: "lo-Laoo-LA",
        lol: "lol-Latn-CD",
        loz: "loz-Latn-ZM",
        lrc: "lrc-Arab-IR",
        lt: "lt-Latn-LT",
        ltg: "ltg-Latn-LV",
        lu: "lu-Latn-CD",
        lua: "lua-Latn-CD",
        luo: "luo-Latn-KE",
        luy: "luy-Latn-KE",
        luz: "luz-Arab-IR",
        lv: "lv-Latn-LV",
        lwl: "lwl-Thai-TH",
        lzh: "lzh-Hans-CN",
        lzz: "lzz-Latn-TR",
        mad: "mad-Latn-ID",
        maf: "maf-Latn-CM",
        mag: "mag-Deva-IN",
        mai: "mai-Deva-IN",
        mak: "mak-Latn-ID",
        man: "man-Latn-GM",
        "man-GN": "man-Nkoo-GN",
        "man-Nkoo": "man-Nkoo-GN",
        mas: "mas-Latn-KE",
        maz: "maz-Latn-MX",
        mdf: "mdf-Cyrl-RU",
        mdh: "mdh-Latn-PH",
        mdr: "mdr-Latn-ID",
        men: "men-Latn-SL",
        mer: "mer-Latn-KE",
        mfa: "mfa-Arab-TH",
        mfe: "mfe-Latn-MU",
        mg: "mg-Latn-MG",
        mgh: "mgh-Latn-MZ",
        mgo: "mgo-Latn-CM",
        mgp: "mgp-Deva-NP",
        mgy: "mgy-Latn-TZ",
        mh: "mh-Latn-MH",
        mi: "mi-Latn-NZ",
        min: "min-Latn-ID",
        mis: "mis-Hatr-IQ",
        mk: "mk-Cyrl-MK",
        ml: "ml-Mlym-IN",
        mls: "mls-Latn-SD",
        mn: "mn-Cyrl-MN",
        "mn-CN": "mn-Mong-CN",
        "mn-Mong": "mn-Mong-CN",
        mni: "mni-Beng-IN",
        mnw: "mnw-Mymr-MM",
        moe: "moe-Latn-CA",
        moh: "moh-Latn-CA",
        mos: "mos-Latn-BF",
        mr: "mr-Deva-IN",
        mrd: "mrd-Deva-NP",
        mrj: "mrj-Cyrl-RU",
        mru: "mru-Mroo-BD",
        ms: "ms-Latn-MY",
        "ms-CC": "ms-Arab-CC",
        "ms-ID": "ms-Arab-ID",
        mt: "mt-Latn-MT",
        mtr: "mtr-Deva-IN",
        mua: "mua-Latn-CM",
        mus: "mus-Latn-US",
        mvy: "mvy-Arab-PK",
        mwk: "mwk-Latn-ML",
        mwr: "mwr-Deva-IN",
        mwv: "mwv-Latn-ID",
        mxc: "mxc-Latn-ZW",
        my: "my-Mymr-MM",
        myv: "myv-Cyrl-RU",
        myx: "myx-Latn-UG",
        myz: "myz-Mand-IR",
        mzn: "mzn-Arab-IR",
        na: "na-Latn-NR",
        nan: "nan-Hans-CN",
        nap: "nap-Latn-IT",
        naq: "naq-Latn-NA",
        nb: "nb-Latn-NO",
        nch: "nch-Latn-MX",
        nd: "nd-Latn-ZW",
        ndc: "ndc-Latn-MZ",
        nds: "nds-Latn-DE",
        ne: "ne-Deva-NP",
        new: "new-Deva-NP",
        ng: "ng-Latn-NA",
        ngl: "ngl-Latn-MZ",
        nhe: "nhe-Latn-MX",
        nhw: "nhw-Latn-MX",
        nij: "nij-Latn-ID",
        niu: "niu-Latn-NU",
        njo: "njo-Latn-IN",
        nl: "nl-Latn-NL",
        nmg: "nmg-Latn-CM",
        nn: "nn-Latn-NO",
        nnh: "nnh-Latn-CM",
        no: "no-Latn-NO",
        nod: "nod-Lana-TH",
        noe: "noe-Deva-IN",
        non: "non-Runr-SE",
        nqo: "nqo-Nkoo-GN",
        nr: "nr-Latn-ZA",
        nsk: "nsk-Cans-CA",
        nso: "nso-Latn-ZA",
        nus: "nus-Latn-SS",
        nv: "nv-Latn-US",
        nxq: "nxq-Latn-CN",
        ny: "ny-Latn-MW",
        nym: "nym-Latn-TZ",
        nyn: "nyn-Latn-UG",
        nzi: "nzi-Latn-GH",
        oc: "oc-Latn-FR",
        om: "om-Latn-ET",
        or: "or-Orya-IN",
        os: "os-Cyrl-GE",
        otk: "otk-Orkh-MN",
        pa: "pa-Guru-IN",
        "pa-Arab": "pa-Arab-PK",
        "pa-PK": "pa-Arab-PK",
        pag: "pag-Latn-PH",
        pal: "pal-Phli-IR",
        "pal-Phlp": "pal-Phlp-CN",
        pam: "pam-Latn-PH",
        pap: "pap-Latn-AW",
        pau: "pau-Latn-PW",
        pcd: "pcd-Latn-FR",
        pcm: "pcm-Latn-NG",
        pdc: "pdc-Latn-US",
        pdt: "pdt-Latn-CA",
        peo: "peo-Xpeo-IR",
        pfl: "pfl-Latn-DE",
        phn: "phn-Phnx-LB",
        pka: "pka-Brah-IN",
        pko: "pko-Latn-KE",
        pl: "pl-Latn-PL",
        pms: "pms-Latn-IT",
        pnt: "pnt-Grek-GR",
        pon: "pon-Latn-FM",
        pra: "pra-Khar-PK",
        prd: "prd-Arab-IR",
        prg: "prg-Latn-001",
        ps: "ps-Arab-AF",
        pt: "pt-Latn-BR",
        puu: "puu-Latn-GA",
        qu: "qu-Latn-PE",
        quc: "quc-Latn-GT",
        qug: "qug-Latn-EC",
        raj: "raj-Deva-IN",
        rcf: "rcf-Latn-RE",
        rej: "rej-Latn-ID",
        rgn: "rgn-Latn-IT",
        ria: "ria-Latn-IN",
        rif: "rif-Tfng-MA",
        "rif-NL": "rif-Latn-NL",
        rjs: "rjs-Deva-NP",
        rkt: "rkt-Beng-BD",
        rm: "rm-Latn-CH",
        rmf: "rmf-Latn-FI",
        rmo: "rmo-Latn-CH",
        rmt: "rmt-Arab-IR",
        rmu: "rmu-Latn-SE",
        rn: "rn-Latn-BI",
        rng: "rng-Latn-MZ",
        ro: "ro-Latn-RO",
        rob: "rob-Latn-ID",
        rof: "rof-Latn-TZ",
        rtm: "rtm-Latn-FJ",
        ru: "ru-Cyrl-RU",
        rue: "rue-Cyrl-UA",
        rug: "rug-Latn-SB",
        rw: "rw-Latn-RW",
        rwk: "rwk-Latn-TZ",
        ryu: "ryu-Kana-JP",
        sa: "sa-Deva-IN",
        saf: "saf-Latn-GH",
        sah: "sah-Cyrl-RU",
        saq: "saq-Latn-KE",
        sas: "sas-Latn-ID",
        sat: "sat-Latn-IN",
        saz: "saz-Saur-IN",
        sbp: "sbp-Latn-TZ",
        sc: "sc-Latn-IT",
        sck: "sck-Deva-IN",
        scn: "scn-Latn-IT",
        sco: "sco-Latn-GB",
        scs: "scs-Latn-CA",
        sd: "sd-Arab-PK",
        "sd-Deva": "sd-Deva-IN",
        "sd-Khoj": "sd-Khoj-IN",
        "sd-Sind": "sd-Sind-IN",
        sdc: "sdc-Latn-IT",
        sdh: "sdh-Arab-IR",
        se: "se-Latn-NO",
        sef: "sef-Latn-CI",
        seh: "seh-Latn-MZ",
        sei: "sei-Latn-MX",
        ses: "ses-Latn-ML",
        sg: "sg-Latn-CF",
        sga: "sga-Ogam-IE",
        sgs: "sgs-Latn-LT",
        shi: "shi-Tfng-MA",
        shn: "shn-Mymr-MM",
        si: "si-Sinh-LK",
        sid: "sid-Latn-ET",
        sk: "sk-Latn-SK",
        skr: "skr-Arab-PK",
        sl: "sl-Latn-SI",
        sli: "sli-Latn-PL",
        sly: "sly-Latn-ID",
        sm: "sm-Latn-WS",
        sma: "sma-Latn-SE",
        smj: "smj-Latn-SE",
        smn: "smn-Latn-FI",
        smp: "smp-Samr-IL",
        sms: "sms-Latn-FI",
        sn: "sn-Latn-ZW",
        snk: "snk-Latn-ML",
        so: "so-Latn-SO",
        sou: "sou-Thai-TH",
        sq: "sq-Latn-AL",
        sr: "sr-Cyrl-RS",
        "sr-ME": "sr-Latn-ME",
        "sr-RO": "sr-Latn-RO",
        "sr-RU": "sr-Latn-RU",
        "sr-TR": "sr-Latn-TR",
        srb: "srb-Sora-IN",
        srn: "srn-Latn-SR",
        srr: "srr-Latn-SN",
        srx: "srx-Deva-IN",
        ss: "ss-Latn-ZA",
        ssy: "ssy-Latn-ER",
        st: "st-Latn-ZA",
        stq: "stq-Latn-DE",
        su: "su-Latn-ID",
        suk: "suk-Latn-TZ",
        sus: "sus-Latn-GN",
        sv: "sv-Latn-SE",
        sw: "sw-Latn-TZ",
        swb: "swb-Arab-YT",
        swc: "swc-Latn-CD",
        swg: "swg-Latn-DE",
        swv: "swv-Deva-IN",
        sxn: "sxn-Latn-ID",
        syl: "syl-Beng-BD",
        syr: "syr-Syrc-IQ",
        szl: "szl-Latn-PL",
        ta: "ta-Taml-IN",
        taj: "taj-Deva-NP",
        tbw: "tbw-Latn-PH",
        tcy: "tcy-Knda-IN",
        tdd: "tdd-Tale-CN",
        tdg: "tdg-Deva-NP",
        tdh: "tdh-Deva-NP",
        te: "te-Telu-IN",
        tem: "tem-Latn-SL",
        teo: "teo-Latn-UG",
        tet: "tet-Latn-TL",
        tg: "tg-Cyrl-TJ",
        "tg-Arab": "tg-Arab-PK",
        "tg-PK": "tg-Arab-PK",
        th: "th-Thai-TH",
        thl: "thl-Deva-NP",
        thq: "thq-Deva-NP",
        thr: "thr-Deva-NP",
        ti: "ti-Ethi-ET",
        tig: "tig-Ethi-ER",
        tiv: "tiv-Latn-NG",
        tk: "tk-Latn-TM",
        tkl: "tkl-Latn-TK",
        tkr: "tkr-Latn-AZ",
        tkt: "tkt-Deva-NP",
        tl: "tl-Latn-PH",
        tly: "tly-Latn-AZ",
        tmh: "tmh-Latn-NE",
        tn: "tn-Latn-ZA",
        to: "to-Latn-TO",
        tog: "tog-Latn-MW",
        tpi: "tpi-Latn-PG",
        tr: "tr-Latn-TR",
        tru: "tru-Latn-TR",
        trv: "trv-Latn-TW",
        ts: "ts-Latn-ZA",
        tsd: "tsd-Grek-GR",
        tsf: "tsf-Deva-NP",
        tsg: "tsg-Latn-PH",
        tsj: "tsj-Tibt-BT",
        tt: "tt-Cyrl-RU",
        ttj: "ttj-Latn-UG",
        tts: "tts-Thai-TH",
        ttt: "ttt-Latn-AZ",
        tum: "tum-Latn-MW",
        tvl: "tvl-Latn-TV",
        twq: "twq-Latn-NE",
        ty: "ty-Latn-PF",
        tyv: "tyv-Cyrl-RU",
        tzm: "tzm-Latn-MA",
        udm: "udm-Cyrl-RU",
        ug: "ug-Arab-CN",
        "ug-Cyrl": "ug-Cyrl-KZ",
        "ug-KZ": "ug-Cyrl-KZ",
        "ug-MN": "ug-Cyrl-MN",
        uga: "uga-Ugar-SY",
        uk: "uk-Cyrl-UA",
        uli: "uli-Latn-FM",
        umb: "umb-Latn-AO",
        und: "en-Latn-US",
        "und-002": "en-Latn-NG",
        "und-003": "en-Latn-US",
        "und-005": "pt-Latn-BR",
        "und-009": "en-Latn-AU",
        "und-011": "en-Latn-NG",
        "und-013": "es-Latn-MX",
        "und-014": "sw-Latn-TZ",
        "und-015": "ar-Arab-EG",
        "und-017": "sw-Latn-CD",
        "und-018": "en-Latn-ZA",
        "und-019": "en-Latn-US",
        "und-021": "en-Latn-US",
        "und-029": "es-Latn-CU",
        "und-030": "zh-Hans-CN",
        "und-034": "hi-Deva-IN",
        "und-035": "id-Latn-ID",
        "und-039": "it-Latn-IT",
        "und-053": "en-Latn-AU",
        "und-054": "en-Latn-PG",
        "und-057": "en-Latn-GU",
        "und-061": "sm-Latn-WS",
        "und-142": "zh-Hans-CN",
        "und-143": "uz-Latn-UZ",
        "und-145": "ar-Arab-SA",
        "und-150": "ru-Cyrl-RU",
        "und-151": "ru-Cyrl-RU",
        "und-154": "en-Latn-GB",
        "und-155": "de-Latn-DE",
        "und-419": "es-Latn-419",
        "und-AD": "ca-Latn-AD",
        "und-AE": "ar-Arab-AE",
        "und-AF": "fa-Arab-AF",
        "und-Aghb": "lez-Aghb-RU",
        "und-Ahom": "aho-Ahom-IN",
        "und-AL": "sq-Latn-AL",
        "und-AM": "hy-Armn-AM",
        "und-AO": "pt-Latn-AO",
        "und-AQ": "und-Latn-AQ",
        "und-AR": "es-Latn-AR",
        "und-Arab": "ar-Arab-EG",
        "und-Arab-CC": "ms-Arab-CC",
        "und-Arab-CN": "ug-Arab-CN",
        "und-Arab-GB": "ks-Arab-GB",
        "und-Arab-ID": "ms-Arab-ID",
        "und-Arab-IN": "ur-Arab-IN",
        "und-Arab-KH": "cja-Arab-KH",
        "und-Arab-MN": "kk-Arab-MN",
        "und-Arab-MU": "ur-Arab-MU",
        "und-Arab-NG": "ha-Arab-NG",
        "und-Arab-PK": "ur-Arab-PK",
        "und-Arab-TH": "mfa-Arab-TH",
        "und-Arab-TJ": "fa-Arab-TJ",
        "und-Arab-TR": "az-Arab-TR",
        "und-Arab-YT": "swb-Arab-YT",
        "und-Armi": "arc-Armi-IR",
        "und-Armn": "hy-Armn-AM",
        "und-AS": "sm-Latn-AS",
        "und-AT": "de-Latn-AT",
        "und-Avst": "ae-Avst-IR",
        "und-AW": "nl-Latn-AW",
        "und-AX": "sv-Latn-AX",
        "und-AZ": "az-Latn-AZ",
        "und-BA": "bs-Latn-BA",
        "und-Bali": "ban-Bali-ID",
        "und-Bamu": "bax-Bamu-CM",
        "und-Bass": "bsq-Bass-LR",
        "und-Batk": "bbc-Batk-ID",
        "und-BD": "bn-Beng-BD",
        "und-BE": "nl-Latn-BE",
        "und-Beng": "bn-Beng-BD",
        "und-BF": "fr-Latn-BF",
        "und-BG": "bg-Cyrl-BG",
        "und-BH": "ar-Arab-BH",
        "und-BI": "rn-Latn-BI",
        "und-BJ": "fr-Latn-BJ",
        "und-BL": "fr-Latn-BL",
        "und-BN": "ms-Latn-BN",
        "und-BO": "es-Latn-BO",
        "und-Bopo": "zh-Bopo-TW",
        "und-BQ": "pap-Latn-BQ",
        "und-BR": "pt-Latn-BR",
        "und-Brah": "pka-Brah-IN",
        "und-Brai": "fr-Brai-FR",
        "und-BT": "dz-Tibt-BT",
        "und-Bugi": "bug-Bugi-ID",
        "und-Buhd": "bku-Buhd-PH",
        "und-BV": "und-Latn-BV",
        "und-BY": "be-Cyrl-BY",
        "und-Cakm": "ccp-Cakm-BD",
        "und-Cans": "cr-Cans-CA",
        "und-Cari": "xcr-Cari-TR",
        "und-CD": "sw-Latn-CD",
        "und-CF": "fr-Latn-CF",
        "und-CG": "fr-Latn-CG",
        "und-CH": "de-Latn-CH",
        "und-Cham": "cjm-Cham-VN",
        "und-Cher": "chr-Cher-US",
        "und-CI": "fr-Latn-CI",
        "und-CL": "es-Latn-CL",
        "und-CM": "fr-Latn-CM",
        "und-CN": "zh-Hans-CN",
        "und-CO": "es-Latn-CO",
        "und-Copt": "cop-Copt-EG",
        "und-CP": "und-Latn-CP",
        "und-Cprt": "grc-Cprt-CY",
        "und-CR": "es-Latn-CR",
        "und-CU": "es-Latn-CU",
        "und-CV": "pt-Latn-CV",
        "und-CW": "pap-Latn-CW",
        "und-CY": "el-Grek-CY",
        "und-Cyrl": "ru-Cyrl-RU",
        "und-Cyrl-AL": "mk-Cyrl-AL",
        "und-Cyrl-BA": "sr-Cyrl-BA",
        "und-Cyrl-GE": "ab-Cyrl-GE",
        "und-Cyrl-GR": "mk-Cyrl-GR",
        "und-Cyrl-MD": "uk-Cyrl-MD",
        "und-Cyrl-PL": "be-Cyrl-PL",
        "und-Cyrl-RO": "bg-Cyrl-RO",
        "und-Cyrl-SK": "uk-Cyrl-SK",
        "und-Cyrl-TR": "kbd-Cyrl-TR",
        "und-Cyrl-XK": "sr-Cyrl-XK",
        "und-CZ": "cs-Latn-CZ",
        "und-DE": "de-Latn-DE",
        "und-Deva": "hi-Deva-IN",
        "und-Deva-BT": "ne-Deva-BT",
        "und-Deva-FJ": "hif-Deva-FJ",
        "und-Deva-MU": "bho-Deva-MU",
        "und-Deva-PK": "btv-Deva-PK",
        "und-DJ": "aa-Latn-DJ",
        "und-DK": "da-Latn-DK",
        "und-DO": "es-Latn-DO",
        "und-Dupl": "fr-Dupl-FR",
        "und-DZ": "ar-Arab-DZ",
        "und-EA": "es-Latn-EA",
        "und-EC": "es-Latn-EC",
        "und-EE": "et-Latn-EE",
        "und-EG": "ar-Arab-EG",
        "und-Egyp": "egy-Egyp-EG",
        "und-EH": "ar-Arab-EH",
        "und-Elba": "sq-Elba-AL",
        "und-ER": "ti-Ethi-ER",
        "und-ES": "es-Latn-ES",
        "und-ET": "am-Ethi-ET",
        "und-Ethi": "am-Ethi-ET",
        "und-EU": "en-Latn-GB",
        "und-FI": "fi-Latn-FI",
        "und-FO": "fo-Latn-FO",
        "und-FR": "fr-Latn-FR",
        "und-GA": "fr-Latn-GA",
        "und-GE": "ka-Geor-GE",
        "und-Geor": "ka-Geor-GE",
        "und-GF": "fr-Latn-GF",
        "und-GH": "ak-Latn-GH",
        "und-GL": "kl-Latn-GL",
        "und-Glag": "cu-Glag-BG",
        "und-GN": "fr-Latn-GN",
        "und-Goth": "got-Goth-UA",
        "und-GP": "fr-Latn-GP",
        "und-GQ": "es-Latn-GQ",
        "und-GR": "el-Grek-GR",
        "und-Gran": "sa-Gran-IN",
        "und-Grek": "el-Grek-GR",
        "und-Grek-TR": "bgx-Grek-TR",
        "und-GS": "und-Latn-GS",
        "und-GT": "es-Latn-GT",
        "und-Gujr": "gu-Gujr-IN",
        "und-Guru": "pa-Guru-IN",
        "und-GW": "pt-Latn-GW",
        "und-Hang": "ko-Hang-KR",
        "und-Hani": "zh-Hani-CN",
        "und-Hano": "hnn-Hano-PH",
        "und-Hans": "zh-Hans-CN",
        "und-Hant": "zh-Hant-TW",
        "und-Hatr": "mis-Hatr-IQ",
        "und-Hebr": "he-Hebr-IL",
        "und-Hebr-CA": "yi-Hebr-CA",
        "und-Hebr-GB": "yi-Hebr-GB",
        "und-Hebr-SE": "yi-Hebr-SE",
        "und-Hebr-UA": "yi-Hebr-UA",
        "und-Hebr-US": "yi-Hebr-US",
        "und-Hira": "ja-Hira-JP",
        "und-HK": "zh-Hant-HK",
        "und-Hluw": "hlu-Hluw-TR",
        "und-HM": "und-Latn-HM",
        "und-Hmng": "hnj-Hmng-LA",
        "und-HN": "es-Latn-HN",
        "und-HR": "hr-Latn-HR",
        "und-HT": "ht-Latn-HT",
        "und-HU": "hu-Latn-HU",
        "und-Hung": "hu-Hung-HU",
        "und-IC": "es-Latn-IC",
        "und-ID": "id-Latn-ID",
        "und-IL": "he-Hebr-IL",
        "und-IN": "hi-Deva-IN",
        "und-IQ": "ar-Arab-IQ",
        "und-IR": "fa-Arab-IR",
        "und-IS": "is-Latn-IS",
        "und-IT": "it-Latn-IT",
        "und-Ital": "ett-Ital-IT",
        "und-Java": "jv-Java-ID",
        "und-JO": "ar-Arab-JO",
        "und-JP": "ja-Jpan-JP",
        "und-Jpan": "ja-Jpan-JP",
        "und-Kali": "eky-Kali-MM",
        "und-Kana": "ja-Kana-JP",
        "und-KE": "sw-Latn-KE",
        "und-KG": "ky-Cyrl-KG",
        "und-KH": "km-Khmr-KH",
        "und-Khar": "pra-Khar-PK",
        "und-Khmr": "km-Khmr-KH",
        "und-Khoj": "sd-Khoj-IN",
        "und-KM": "ar-Arab-KM",
        "und-Knda": "kn-Knda-IN",
        "und-Kore": "ko-Kore-KR",
        "und-KP": "ko-Kore-KP",
        "und-KR": "ko-Kore-KR",
        "und-Kthi": "bh-Kthi-IN",
        "und-KW": "ar-Arab-KW",
        "und-KZ": "ru-Cyrl-KZ",
        "und-LA": "lo-Laoo-LA",
        "und-Lana": "nod-Lana-TH",
        "und-Laoo": "lo-Laoo-LA",
        "und-Latn-AF": "tk-Latn-AF",
        "und-Latn-AM": "ku-Latn-AM",
        "und-Latn-CN": "za-Latn-CN",
        "und-Latn-CY": "tr-Latn-CY",
        "und-Latn-DZ": "fr-Latn-DZ",
        "und-Latn-ET": "en-Latn-ET",
        "und-Latn-GE": "ku-Latn-GE",
        "und-Latn-IR": "tk-Latn-IR",
        "und-Latn-KM": "fr-Latn-KM",
        "und-Latn-MA": "fr-Latn-MA",
        "und-Latn-MK": "sq-Latn-MK",
        "und-Latn-MM": "kac-Latn-MM",
        "und-Latn-MO": "pt-Latn-MO",
        "und-Latn-MR": "fr-Latn-MR",
        "und-Latn-RU": "krl-Latn-RU",
        "und-Latn-SY": "fr-Latn-SY",
        "und-Latn-TN": "fr-Latn-TN",
        "und-Latn-TW": "trv-Latn-TW",
        "und-Latn-UA": "pl-Latn-UA",
        "und-LB": "ar-Arab-LB",
        "und-Lepc": "lep-Lepc-IN",
        "und-LI": "de-Latn-LI",
        "und-Limb": "lif-Limb-IN",
        "und-Lina": "lab-Lina-GR",
        "und-Linb": "grc-Linb-GR",
        "und-Lisu": "lis-Lisu-CN",
        "und-LK": "si-Sinh-LK",
        "und-LS": "st-Latn-LS",
        "und-LT": "lt-Latn-LT",
        "und-LU": "fr-Latn-LU",
        "und-LV": "lv-Latn-LV",
        "und-LY": "ar-Arab-LY",
        "und-Lyci": "xlc-Lyci-TR",
        "und-Lydi": "xld-Lydi-TR",
        "und-MA": "ar-Arab-MA",
        "und-Mahj": "hi-Mahj-IN",
        "und-Mand": "myz-Mand-IR",
        "und-Mani": "xmn-Mani-CN",
        "und-MC": "fr-Latn-MC",
        "und-MD": "ro-Latn-MD",
        "und-ME": "sr-Latn-ME",
        "und-Mend": "men-Mend-SL",
        "und-Merc": "xmr-Merc-SD",
        "und-Mero": "xmr-Mero-SD",
        "und-MF": "fr-Latn-MF",
        "und-MG": "mg-Latn-MG",
        "und-MK": "mk-Cyrl-MK",
        "und-ML": "bm-Latn-ML",
        "und-Mlym": "ml-Mlym-IN",
        "und-MM": "my-Mymr-MM",
        "und-MN": "mn-Cyrl-MN",
        "und-MO": "zh-Hant-MO",
        "und-Modi": "mr-Modi-IN",
        "und-Mong": "mn-Mong-CN",
        "und-MQ": "fr-Latn-MQ",
        "und-MR": "ar-Arab-MR",
        "und-Mroo": "mru-Mroo-BD",
        "und-MT": "mt-Latn-MT",
        "und-Mtei": "mni-Mtei-IN",
        "und-MU": "mfe-Latn-MU",
        "und-Mult": "skr-Mult-PK",
        "und-MV": "dv-Thaa-MV",
        "und-MX": "es-Latn-MX",
        "und-MY": "ms-Latn-MY",
        "und-Mymr": "my-Mymr-MM",
        "und-Mymr-IN": "kht-Mymr-IN",
        "und-Mymr-TH": "mnw-Mymr-TH",
        "und-MZ": "pt-Latn-MZ",
        "und-NA": "af-Latn-NA",
        "und-Narb": "xna-Narb-SA",
        "und-Nbat": "arc-Nbat-JO",
        "und-NC": "fr-Latn-NC",
        "und-NE": "ha-Latn-NE",
        "und-NI": "es-Latn-NI",
        "und-Nkoo": "man-Nkoo-GN",
        "und-NL": "nl-Latn-NL",
        "und-NO": "nb-Latn-NO",
        "und-NP": "ne-Deva-NP",
        "und-Ogam": "sga-Ogam-IE",
        "und-Olck": "sat-Olck-IN",
        "und-OM": "ar-Arab-OM",
        "und-Orkh": "otk-Orkh-MN",
        "und-Orya": "or-Orya-IN",
        "und-Osma": "so-Osma-SO",
        "und-PA": "es-Latn-PA",
        "und-Palm": "arc-Palm-SY",
        "und-Pauc": "ctd-Pauc-MM",
        "und-PE": "es-Latn-PE",
        "und-Perm": "kv-Perm-RU",
        "und-PF": "fr-Latn-PF",
        "und-PG": "tpi-Latn-PG",
        "und-PH": "fil-Latn-PH",
        "und-Phag": "lzh-Phag-CN",
        "und-Phli": "pal-Phli-IR",
        "und-Phlp": "pal-Phlp-CN",
        "und-Phnx": "phn-Phnx-LB",
        "und-PK": "ur-Arab-PK",
        "und-PL": "pl-Latn-PL",
        "und-Plrd": "hmd-Plrd-CN",
        "und-PM": "fr-Latn-PM",
        "und-PR": "es-Latn-PR",
        "und-Prti": "xpr-Prti-IR",
        "und-PS": "ar-Arab-PS",
        "und-PT": "pt-Latn-PT",
        "und-PW": "pau-Latn-PW",
        "und-PY": "gn-Latn-PY",
        "und-QA": "ar-Arab-QA",
        "und-QO": "en-Latn-IO",
        "und-RE": "fr-Latn-RE",
        "und-Rjng": "rej-Rjng-ID",
        "und-RO": "ro-Latn-RO",
        "und-RS": "sr-Cyrl-RS",
        "und-RU": "ru-Cyrl-RU",
        "und-Runr": "non-Runr-SE",
        "und-RW": "rw-Latn-RW",
        "und-SA": "ar-Arab-SA",
        "und-Samr": "smp-Samr-IL",
        "und-Sarb": "xsa-Sarb-YE",
        "und-Saur": "saz-Saur-IN",
        "und-SC": "fr-Latn-SC",
        "und-SD": "ar-Arab-SD",
        "und-SE": "sv-Latn-SE",
        "und-Sgnw": "ase-Sgnw-US",
        "und-Shaw": "en-Shaw-GB",
        "und-Shrd": "sa-Shrd-IN",
        "und-SI": "sl-Latn-SI",
        "und-Sidd": "sa-Sidd-IN",
        "und-Sind": "sd-Sind-IN",
        "und-Sinh": "si-Sinh-LK",
        "und-SJ": "nb-Latn-SJ",
        "und-SK": "sk-Latn-SK",
        "und-SM": "it-Latn-SM",
        "und-SN": "fr-Latn-SN",
        "und-SO": "so-Latn-SO",
        "und-Sora": "srb-Sora-IN",
        "und-SR": "nl-Latn-SR",
        "und-ST": "pt-Latn-ST",
        "und-Sund": "su-Sund-ID",
        "und-SV": "es-Latn-SV",
        "und-SY": "ar-Arab-SY",
        "und-Sylo": "syl-Sylo-BD",
        "und-Syrc": "syr-Syrc-IQ",
        "und-Tagb": "tbw-Tagb-PH",
        "und-Takr": "doi-Takr-IN",
        "und-Tale": "tdd-Tale-CN",
        "und-Talu": "khb-Talu-CN",
        "und-Taml": "ta-Taml-IN",
        "und-Tavt": "blt-Tavt-VN",
        "und-TD": "fr-Latn-TD",
        "und-Telu": "te-Telu-IN",
        "und-TF": "fr-Latn-TF",
        "und-Tfng": "zgh-Tfng-MA",
        "und-TG": "fr-Latn-TG",
        "und-Tglg": "fil-Tglg-PH",
        "und-TH": "th-Thai-TH",
        "und-Thaa": "dv-Thaa-MV",
        "und-Thai": "th-Thai-TH",
        "und-Thai-CN": "lcp-Thai-CN",
        "und-Thai-KH": "kdt-Thai-KH",
        "und-Thai-LA": "kdt-Thai-LA",
        "und-Tibt": "bo-Tibt-CN",
        "und-Tirh": "mai-Tirh-IN",
        "und-TJ": "tg-Cyrl-TJ",
        "und-TK": "tkl-Latn-TK",
        "und-TL": "pt-Latn-TL",
        "und-TM": "tk-Latn-TM",
        "und-TN": "ar-Arab-TN",
        "und-TO": "to-Latn-TO",
        "und-TR": "tr-Latn-TR",
        "und-TV": "tvl-Latn-TV",
        "und-TW": "zh-Hant-TW",
        "und-TZ": "sw-Latn-TZ",
        "und-UA": "uk-Cyrl-UA",
        "und-UG": "sw-Latn-UG",
        "und-Ugar": "uga-Ugar-SY",
        "und-UY": "es-Latn-UY",
        "und-UZ": "uz-Latn-UZ",
        "und-VA": "it-Latn-VA",
        "und-Vaii": "vai-Vaii-LR",
        "und-VE": "es-Latn-VE",
        "und-VN": "vi-Latn-VN",
        "und-VU": "bi-Latn-VU",
        "und-Wara": "hoc-Wara-IN",
        "und-WF": "fr-Latn-WF",
        "und-WS": "sm-Latn-WS",
        "und-XK": "sq-Latn-XK",
        "und-Xpeo": "peo-Xpeo-IR",
        "und-Xsux": "akk-Xsux-IQ",
        "und-YE": "ar-Arab-YE",
        "und-Yiii": "ii-Yiii-CN",
        "und-YT": "fr-Latn-YT",
        "und-ZW": "sn-Latn-ZW",
        unr: "unr-Beng-IN",
        "unr-Deva": "unr-Deva-NP",
        "unr-NP": "unr-Deva-NP",
        unx: "unx-Beng-IN",
        ur: "ur-Arab-PK",
        uz: "uz-Latn-UZ",
        "uz-AF": "uz-Arab-AF",
        "uz-Arab": "uz-Arab-AF",
        "uz-CN": "uz-Cyrl-CN",
        vai: "vai-Vaii-LR",
        ve: "ve-Latn-ZA",
        vec: "vec-Latn-IT",
        vep: "vep-Latn-RU",
        vi: "vi-Latn-VN",
        vic: "vic-Latn-SX",
        vls: "vls-Latn-BE",
        vmf: "vmf-Latn-DE",
        vmw: "vmw-Latn-MZ",
        vo: "vo-Latn-001",
        vot: "vot-Latn-RU",
        vro: "vro-Latn-EE",
        vun: "vun-Latn-TZ",
        wa: "wa-Latn-BE",
        wae: "wae-Latn-CH",
        wal: "wal-Ethi-ET",
        war: "war-Latn-PH",
        wbp: "wbp-Latn-AU",
        wbq: "wbq-Telu-IN",
        wbr: "wbr-Deva-IN",
        wls: "wls-Latn-WF",
        wni: "wni-Arab-KM",
        wo: "wo-Latn-SN",
        wtm: "wtm-Deva-IN",
        wuu: "wuu-Hans-CN",
        xav: "xav-Latn-BR",
        xcr: "xcr-Cari-TR",
        xh: "xh-Latn-ZA",
        xlc: "xlc-Lyci-TR",
        xld: "xld-Lydi-TR",
        xmf: "xmf-Geor-GE",
        xmn: "xmn-Mani-CN",
        xmr: "xmr-Merc-SD",
        xna: "xna-Narb-SA",
        xnr: "xnr-Deva-IN",
        xog: "xog-Latn-UG",
        xpr: "xpr-Prti-IR",
        xsa: "xsa-Sarb-YE",
        xsr: "xsr-Deva-NP",
        yao: "yao-Latn-MZ",
        yap: "yap-Latn-FM",
        yav: "yav-Latn-CM",
        ybb: "ybb-Latn-CM",
        yi: "yi-Hebr-001",
        yo: "yo-Latn-NG",
        yrl: "yrl-Latn-BR",
        yua: "yua-Latn-MX",
        za: "za-Latn-CN",
        zag: "zag-Latn-SD",
        zdj: "zdj-Arab-KM",
        zea: "zea-Latn-NL",
        zgh: "zgh-Tfng-MA",
        zh: "zh-Hans-CN",
        "zh-AU": "zh-Hant-AU",
        "zh-BN": "zh-Hant-BN",
        "zh-Bopo": "zh-Bopo-TW",
        "zh-GB": "zh-Hant-GB",
        "zh-GF": "zh-Hant-GF",
        "zh-Hant": "zh-Hant-TW",
        "zh-HK": "zh-Hant-HK",
        "zh-ID": "zh-Hant-ID",
        "zh-MO": "zh-Hant-MO",
        "zh-MY": "zh-Hant-MY",
        "zh-PA": "zh-Hant-PA",
        "zh-PF": "zh-Hant-PF",
        "zh-PH": "zh-Hant-PH",
        "zh-SR": "zh-Hant-SR",
        "zh-TH": "zh-Hant-TH",
        "zh-TW": "zh-Hant-TW",
        "zh-US": "zh-Hant-US",
        "zh-VN": "zh-Hant-VN",
        zmi: "zmi-Latn-MY",
        zu: "zu-Latn-ZA",
        zza: "zza-Latn-TR"
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    supplemental: {
      version: {
        _cldrVersion: "28",
        _unicodeVersion: "8.0.0",
        _number: "$Revision: 11966 $"
      },
      numberingSystems: {
        ahom: {
          _digits: "",
          _type: "numeric"
        },
        arab: {
          _digits: "",
          _type: "numeric"
        },
        arabext: {
          _digits: "",
          _type: "numeric"
        },
        armn: {
          _type: "algorithmic",
          _rules: "armenian-upper"
        },
        armnlow: {
          _type: "algorithmic",
          _rules: "armenian-lower"
        },
        bali: {
          _digits: "",
          _type: "numeric"
        },
        beng: {
          _digits: "",
          _type: "numeric"
        },
        brah: {
          _digits: "",
          _type: "numeric"
        },
        cakm: {
          _digits: "",
          _type: "numeric"
        },
        cham: {
          _digits: "",
          _type: "numeric"
        },
        cyrl: {
          _type: "algorithmic",
          _rules: "cyrillic-lower"
        },
        deva: {
          _digits: "",
          _type: "numeric"
        },
        ethi: {
          _type: "algorithmic",
          _rules: "ethiopic"
        },
        fullwide: {
          _digits: "",
          _type: "numeric"
        },
        geor: {
          _type: "algorithmic",
          _rules: "georgian"
        },
        grek: {
          _type: "algorithmic",
          _rules: "greek-upper"
        },
        greklow: {
          _type: "algorithmic",
          _rules: "greek-lower"
        },
        gujr: {
          _digits: "",
          _type: "numeric"
        },
        guru: {
          _digits: "",
          _type: "numeric"
        },
        hanidays: {
          _type: "algorithmic",
          _rules: "zh/SpelloutRules/spellout-numbering-days"
        },
        hanidec: {
          _digits: "",
          _type: "numeric"
        },
        hans: {
          _type: "algorithmic",
          _rules: "zh/SpelloutRules/spellout-cardinal"
        },
        hansfin: {
          _type: "algorithmic",
          _rules: "zh/SpelloutRules/spellout-cardinal-financial"
        },
        hant: {
          _type: "algorithmic",
          _rules: "zh_Hant/SpelloutRules/spellout-cardinal"
        },
        hantfin: {
          _type: "algorithmic",
          _rules: "zh_Hant/SpelloutRules/spellout-cardinal-financial"
        },
        hebr: {
          _type: "algorithmic",
          _rules: "hebrew"
        },
        hmng: {
          _digits: "",
          _type: "numeric"
        },
        java: {
          _digits: "",
          _type: "numeric"
        },
        jpan: {
          _type: "algorithmic",
          _rules: "ja/SpelloutRules/spellout-cardinal"
        },
        jpanfin: {
          _type: "algorithmic",
          _rules: "ja/SpelloutRules/spellout-cardinal-financial"
        },
        kali: {
          _digits: "",
          _type: "numeric"
        },
        khmr: {
          _digits: "",
          _type: "numeric"
        },
        knda: {
          _digits: "",
          _type: "numeric"
        },
        lana: {
          _digits: "",
          _type: "numeric"
        },
        lanatham: {
          _digits: "",
          _type: "numeric"
        },
        laoo: {
          _digits: "",
          _type: "numeric"
        },
        latn: {
          _digits: "0123456789",
          _type: "numeric"
        },
        lepc: {
          _digits: "",
          _type: "numeric"
        },
        limb: {
          _digits: "",
          _type: "numeric"
        },
        mathbold: {
          _digits: "",
          _type: "numeric"
        },
        mathdbl: {
          _digits: "",
          _type: "numeric"
        },
        mathmono: {
          _digits: "",
          _type: "numeric"
        },
        mathsanb: {
          _digits: "",
          _type: "numeric"
        },
        mathsans: {
          _digits: "",
          _type: "numeric"
        },
        mlym: {
          _digits: "",
          _type: "numeric"
        },
        modi: {
          _digits: "",
          _type: "numeric"
        },
        mong: {
          _digits: "",
          _type: "numeric"
        },
        mroo: {
          _digits: "",
          _type: "numeric"
        },
        mtei: {
          _digits: "",
          _type: "numeric"
        },
        mymr: {
          _digits: "",
          _type: "numeric"
        },
        mymrshan: {
          _digits: "",
          _type: "numeric"
        },
        mymrtlng: {
          _digits: "",
          _type: "numeric"
        },
        nkoo: {
          _digits: "",
          _type: "numeric"
        },
        olck: {
          _digits: "",
          _type: "numeric"
        },
        orya: {
          _digits: "",
          _type: "numeric"
        },
        osma: {
          _digits: "",
          _type: "numeric"
        },
        roman: {
          _type: "algorithmic",
          _rules: "roman-upper"
        },
        romanlow: {
          _type: "algorithmic",
          _rules: "roman-lower"
        },
        saur: {
          _digits: "",
          _type: "numeric"
        },
        shrd: {
          _digits: "",
          _type: "numeric"
        },
        sind: {
          _digits: "",
          _type: "numeric"
        },
        sinh: {
          _digits: "",
          _type: "numeric"
        },
        sora: {
          _digits: "",
          _type: "numeric"
        },
        sund: {
          _digits: "",
          _type: "numeric"
        },
        takr: {
          _digits: "",
          _type: "numeric"
        },
        talu: {
          _digits: "",
          _type: "numeric"
        },
        taml: {
          _type: "algorithmic",
          _rules: "tamil"
        },
        tamldec: {
          _digits: "",
          _type: "numeric"
        },
        telu: {
          _digits: "",
          _type: "numeric"
        },
        thai: {
          _digits: "",
          _type: "numeric"
        },
        tibt: {
          _digits: "",
          _type: "numeric"
        },
        tirh: {
          _digits: "",
          _type: "numeric"
        },
        vaii: {
          _digits: "",
          _type: "numeric"
        },
        wara: {
          _digits: "",
          _type: "numeric"
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    supplemental: {
      version: {
        _cldrVersion: "28",
        _unicodeVersion: "8.0.0",
        _number: "$Revision: 11969 $"
      },
      timeData: {
        "001": {
          _allowed: "H h",
          _preferred: "H"
        },
        AD: {
          _allowed: "H",
          _preferred: "H"
        },
        AE: {
          _allowed: "H h",
          _preferred: "h"
        },
        AG: {
          _allowed: "H h",
          _preferred: "h"
        },
        AL: {
          _allowed: "H h",
          _preferred: "h"
        },
        AM: {
          _allowed: "H",
          _preferred: "H"
        },
        AO: {
          _allowed: "H",
          _preferred: "H"
        },
        AS: {
          _allowed: "H h",
          _preferred: "h"
        },
        AT: {
          _allowed: "H",
          _preferred: "H"
        },
        AU: {
          _allowed: "H h",
          _preferred: "h"
        },
        AW: {
          _allowed: "H",
          _preferred: "H"
        },
        AX: {
          _allowed: "H",
          _preferred: "H"
        },
        BB: {
          _allowed: "H h",
          _preferred: "h"
        },
        BD: {
          _allowed: "H h",
          _preferred: "h"
        },
        BE: {
          _allowed: "H",
          _preferred: "H"
        },
        BF: {
          _allowed: "H",
          _preferred: "H"
        },
        BH: {
          _allowed: "H h",
          _preferred: "h"
        },
        BJ: {
          _allowed: "H",
          _preferred: "H"
        },
        BL: {
          _allowed: "H",
          _preferred: "H"
        },
        BM: {
          _allowed: "H h",
          _preferred: "h"
        },
        BN: {
          _allowed: "H h",
          _preferred: "h"
        },
        BQ: {
          _allowed: "H",
          _preferred: "H"
        },
        BR: {
          _allowed: "H",
          _preferred: "H"
        },
        BS: {
          _allowed: "H h",
          _preferred: "h"
        },
        BT: {
          _allowed: "H h",
          _preferred: "h"
        },
        BW: {
          _allowed: "H h",
          _preferred: "h"
        },
        CA: {
          _allowed: "H h",
          _preferred: "h"
        },
        CD: {
          _allowed: "H",
          _preferred: "H"
        },
        CG: {
          _allowed: "H",
          _preferred: "H"
        },
        CI: {
          _allowed: "H",
          _preferred: "H"
        },
        CN: {
          _allowed: "H h",
          _preferred: "h"
        },
        CO: {
          _allowed: "H h",
          _preferred: "h"
        },
        CP: {
          _allowed: "H",
          _preferred: "H"
        },
        CV: {
          _allowed: "H",
          _preferred: "H"
        },
        CY: {
          _allowed: "H h",
          _preferred: "h"
        },
        CZ: {
          _allowed: "H",
          _preferred: "H"
        },
        DE: {
          _allowed: "H",
          _preferred: "H"
        },
        DJ: {
          _allowed: "H h",
          _preferred: "h"
        },
        DK: {
          _allowed: "H",
          _preferred: "H"
        },
        DM: {
          _allowed: "H h",
          _preferred: "h"
        },
        DO: {
          _allowed: "H h",
          _preferred: "h"
        },
        DZ: {
          _allowed: "H h",
          _preferred: "h"
        },
        EE: {
          _allowed: "H",
          _preferred: "H"
        },
        EG: {
          _allowed: "H h",
          _preferred: "h"
        },
        EH: {
          _allowed: "H h",
          _preferred: "h"
        },
        ER: {
          _allowed: "H h",
          _preferred: "h"
        },
        ET: {
          _allowed: "H h",
          _preferred: "h"
        },
        FI: {
          _allowed: "H",
          _preferred: "H"
        },
        FJ: {
          _allowed: "H h",
          _preferred: "h"
        },
        FM: {
          _allowed: "H h",
          _preferred: "h"
        },
        FR: {
          _allowed: "H",
          _preferred: "H"
        },
        GA: {
          _allowed: "H",
          _preferred: "H"
        },
        GD: {
          _allowed: "H h",
          _preferred: "h"
        },
        GF: {
          _allowed: "H",
          _preferred: "H"
        },
        GH: {
          _allowed: "H h",
          _preferred: "h"
        },
        GL: {
          _allowed: "H h",
          _preferred: "h"
        },
        GM: {
          _allowed: "H h",
          _preferred: "h"
        },
        GN: {
          _allowed: "H",
          _preferred: "H"
        },
        GP: {
          _allowed: "H",
          _preferred: "H"
        },
        GR: {
          _allowed: "H h",
          _preferred: "h"
        },
        GU: {
          _allowed: "H h",
          _preferred: "h"
        },
        GW: {
          _allowed: "H",
          _preferred: "H"
        },
        GY: {
          _allowed: "H h",
          _preferred: "h"
        },
        HK: {
          _allowed: "H h",
          _preferred: "h"
        },
        HR: {
          _allowed: "H",
          _preferred: "H"
        },
        ID: {
          _allowed: "H",
          _preferred: "H"
        },
        IL: {
          _allowed: "H",
          _preferred: "H"
        },
        IN: {
          _allowed: "H h",
          _preferred: "h"
        },
        IQ: {
          _allowed: "H h",
          _preferred: "h"
        },
        IS: {
          _allowed: "H",
          _preferred: "H"
        },
        IT: {
          _allowed: "H",
          _preferred: "H"
        },
        JM: {
          _allowed: "H h",
          _preferred: "h"
        },
        JO: {
          _allowed: "H h",
          _preferred: "h"
        },
        JP: {
          _allowed: "H K h",
          _preferred: "H"
        },
        KH: {
          _allowed: "H h",
          _preferred: "h"
        },
        KI: {
          _allowed: "H h",
          _preferred: "h"
        },
        KN: {
          _allowed: "H h",
          _preferred: "h"
        },
        KP: {
          _allowed: "H h",
          _preferred: "h"
        },
        KR: {
          _allowed: "H h",
          _preferred: "h"
        },
        KW: {
          _allowed: "H h",
          _preferred: "h"
        },
        KY: {
          _allowed: "H h",
          _preferred: "h"
        },
        LB: {
          _allowed: "H h",
          _preferred: "h"
        },
        LC: {
          _allowed: "H h",
          _preferred: "h"
        },
        LR: {
          _allowed: "H h",
          _preferred: "h"
        },
        LS: {
          _allowed: "H h",
          _preferred: "h"
        },
        LY: {
          _allowed: "H h",
          _preferred: "h"
        },
        MC: {
          _allowed: "H",
          _preferred: "H"
        },
        MD: {
          _allowed: "H",
          _preferred: "H"
        },
        MF: {
          _allowed: "H",
          _preferred: "H"
        },
        MH: {
          _allowed: "H h",
          _preferred: "h"
        },
        ML: {
          _allowed: "H",
          _preferred: "H"
        },
        MO: {
          _allowed: "H h",
          _preferred: "h"
        },
        MP: {
          _allowed: "H h",
          _preferred: "h"
        },
        MQ: {
          _allowed: "H",
          _preferred: "H"
        },
        MR: {
          _allowed: "H h",
          _preferred: "h"
        },
        MW: {
          _allowed: "H h",
          _preferred: "h"
        },
        MY: {
          _allowed: "H h",
          _preferred: "h"
        },
        MZ: {
          _allowed: "H",
          _preferred: "H"
        },
        NA: {
          _allowed: "H h",
          _preferred: "h"
        },
        NC: {
          _allowed: "H",
          _preferred: "H"
        },
        NE: {
          _allowed: "H",
          _preferred: "H"
        },
        NG: {
          _allowed: "H h",
          _preferred: "h"
        },
        NL: {
          _allowed: "H",
          _preferred: "H"
        },
        NZ: {
          _allowed: "H h",
          _preferred: "h"
        },
        OM: {
          _allowed: "H h",
          _preferred: "h"
        },
        PA: {
          _allowed: "H h",
          _preferred: "h"
        },
        PG: {
          _allowed: "H h",
          _preferred: "h"
        },
        PH: {
          _allowed: "H h",
          _preferred: "h"
        },
        PK: {
          _allowed: "H h",
          _preferred: "h"
        },
        PM: {
          _allowed: "H",
          _preferred: "H"
        },
        PR: {
          _allowed: "H h",
          _preferred: "h"
        },
        PS: {
          _allowed: "H h",
          _preferred: "h"
        },
        PT: {
          _allowed: "H",
          _preferred: "H"
        },
        PW: {
          _allowed: "H h",
          _preferred: "h"
        },
        QA: {
          _allowed: "H h",
          _preferred: "h"
        },
        RE: {
          _allowed: "H",
          _preferred: "H"
        },
        RO: {
          _allowed: "H",
          _preferred: "H"
        },
        RU: {
          _allowed: "H",
          _preferred: "H"
        },
        SA: {
          _allowed: "H h",
          _preferred: "h"
        },
        SB: {
          _allowed: "H h",
          _preferred: "h"
        },
        SD: {
          _allowed: "H h",
          _preferred: "h"
        },
        SE: {
          _allowed: "H",
          _preferred: "H"
        },
        SG: {
          _allowed: "H h",
          _preferred: "h"
        },
        SI: {
          _allowed: "H",
          _preferred: "H"
        },
        SJ: {
          _allowed: "H",
          _preferred: "H"
        },
        SK: {
          _allowed: "H",
          _preferred: "H"
        },
        SL: {
          _allowed: "H h",
          _preferred: "h"
        },
        SM: {
          _allowed: "H",
          _preferred: "H"
        },
        SO: {
          _allowed: "H h",
          _preferred: "h"
        },
        SR: {
          _allowed: "H",
          _preferred: "H"
        },
        SS: {
          _allowed: "H h",
          _preferred: "h"
        },
        ST: {
          _allowed: "H",
          _preferred: "H"
        },
        SY: {
          _allowed: "H h",
          _preferred: "h"
        },
        SZ: {
          _allowed: "H h",
          _preferred: "h"
        },
        TC: {
          _allowed: "H h",
          _preferred: "h"
        },
        TD: {
          _allowed: "H h",
          _preferred: "h"
        },
        TG: {
          _allowed: "H",
          _preferred: "H"
        },
        TN: {
          _allowed: "H h",
          _preferred: "h"
        },
        TO: {
          _allowed: "H h",
          _preferred: "h"
        },
        TR: {
          _allowed: "H",
          _preferred: "H"
        },
        TT: {
          _allowed: "H h",
          _preferred: "h"
        },
        TW: {
          _allowed: "H h",
          _preferred: "h"
        },
        UM: {
          _allowed: "H h",
          _preferred: "h"
        },
        US: {
          _allowed: "H h",
          _preferred: "h"
        },
        VC: {
          _allowed: "H h",
          _preferred: "h"
        },
        VE: {
          _allowed: "H h",
          _preferred: "h"
        },
        VG: {
          _allowed: "H h",
          _preferred: "h"
        },
        VI: {
          _allowed: "H h",
          _preferred: "h"
        },
        VU: {
          _allowed: "H h",
          _preferred: "h"
        },
        WF: {
          _allowed: "H",
          _preferred: "H"
        },
        WS: {
          _allowed: "H h",
          _preferred: "h"
        },
        YE: {
          _allowed: "H h",
          _preferred: "h"
        },
        YT: {
          _allowed: "H",
          _preferred: "H"
        },
        ZA: {
          _allowed: "H h",
          _preferred: "h"
        },
        ZM: {
          _allowed: "H h",
          _preferred: "h"
        },
        ZW: {
          _allowed: "H h",
          _preferred: "h"
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    supplemental: {
      version: {
        _cldrVersion: "28",
        _unicodeVersion: "8.0.0",
        _number: "$Revision: 11969 $"
      },
      weekData: {
        minDays: {
          "001": "1",
          GU: "1",
          UM: "1",
          US: "1",
          VI: "1",
          AD: "4",
          AN: "4",
          AT: "4",
          AX: "4",
          BE: "4",
          BG: "4",
          CH: "4",
          CZ: "4",
          DE: "4",
          DK: "4",
          EE: "4",
          ES: "4",
          FI: "4",
          FJ: "4",
          FO: "4",
          FR: "4",
          GB: "4",
          GF: "4",
          GG: "4",
          GI: "4",
          GP: "4",
          GR: "4",
          HU: "4",
          IE: "4",
          IM: "4",
          IS: "4",
          IT: "4",
          JE: "4",
          LI: "4",
          LT: "4",
          LU: "4",
          MC: "4",
          MQ: "4",
          NL: "4",
          NO: "4",
          PL: "4",
          PT: "4",
          RE: "4",
          SE: "4",
          SJ: "4",
          SK: "4",
          SM: "4",
          VA: "4"
        },
        firstDay: {
          GT: "sun",
          GU: "sun",
          HK: "sun",
          HN: "sun",
          ID: "sun",
          IE: "sun",
          IL: "sun",
          IN: "sun",
          JM: "sun",
          JP: "sun",
          KE: "sun",
          KH: "sun",
          KR: "sun",
          LA: "sun",
          MH: "sun",
          MM: "sun",
          MO: "sun",
          MT: "sun",
          MX: "sun",
          MZ: "sun",
          NI: "sun",
          NP: "sun",
          NZ: "sun",
          PA: "sun",
          PE: "sun",
          PH: "sun",
          PK: "sun",
          PR: "sun",
          PY: "sun",
          SA: "sun",
          SG: "sun",
          SV: "sun",
          TH: "sun",
          TN: "sun",
          TT: "sun",
          TW: "sun",
          UM: "sun",
          US: "sun",
          VE: "sun",
          VI: "sun",
          WS: "sun",
          YE: "sun",
          ZA: "sun",
          ZW: "sun"
        },
        "firstDay-alt-variant": {
          GB: "sun"
        },
        weekendStart: {
          AE: "fri",
          BH: "fri",
          DZ: "fri",
          EG: "fri",
          IL: "fri",
          IQ: "fri",
          IR: "fri",
          JO: "fri",
          KW: "fri",
          LY: "fri",
          MA: "fri",
          OM: "fri",
          QA: "fri",
          SA: "fri",
          SD: "fri",
          SY: "fri",
          TN: "fri",
          YE: "fri",
          "001": "sat",
          IN: "sun",
          AF: "thu"
        },
        weekendEnd: {
          AF: "fri",
          IR: "fri",
          AE: "sat",
          BH: "sat",
          DZ: "sat",
          EG: "sat",
          IL: "sat",
          IQ: "sat",
          JO: "sat",
          KW: "sat",
          LY: "sat",
          MA: "sat",
          OM: "sat",
          QA: "sat",
          SA: "sat",
          SD: "sat",
          SY: "sat",
          TN: "sat",
          YE: "sat",
          "001": "sun"
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      en: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11972 $"
          },
          language: "en"
        },
        dates: {
          calendars: {
            gregorian: {
              months: {
                format: {
                  abbreviated: {
                    "1": "Jan",
                    "2": "Feb",
                    "3": "Mar",
                    "4": "Apr",
                    "5": "May",
                    "6": "Jun",
                    "7": "Jul",
                    "8": "Aug",
                    "9": "Sep",
                    "10": "Oct",
                    "11": "Nov",
                    "12": "Dec"
                  },
                  narrow: {
                    "1": "J",
                    "2": "F",
                    "3": "M",
                    "4": "A",
                    "5": "M",
                    "6": "J",
                    "7": "J",
                    "8": "A",
                    "9": "S",
                    "10": "O",
                    "11": "N",
                    "12": "D"
                  },
                  wide: {
                    "1": "January",
                    "2": "February",
                    "3": "March",
                    "4": "April",
                    "5": "May",
                    "6": "June",
                    "7": "July",
                    "8": "August",
                    "9": "September",
                    "10": "October",
                    "11": "November",
                    "12": "December"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "Jan",
                    "2": "Feb",
                    "3": "Mar",
                    "4": "Apr",
                    "5": "May",
                    "6": "Jun",
                    "7": "Jul",
                    "8": "Aug",
                    "9": "Sep",
                    "10": "Oct",
                    "11": "Nov",
                    "12": "Dec"
                  },
                  narrow: {
                    "1": "J",
                    "2": "F",
                    "3": "M",
                    "4": "A",
                    "5": "M",
                    "6": "J",
                    "7": "J",
                    "8": "A",
                    "9": "S",
                    "10": "O",
                    "11": "N",
                    "12": "D"
                  },
                  wide: {
                    "1": "January",
                    "2": "February",
                    "3": "March",
                    "4": "April",
                    "5": "May",
                    "6": "June",
                    "7": "July",
                    "8": "August",
                    "9": "September",
                    "10": "October",
                    "11": "November",
                    "12": "December"
                  }
                }
              },
              days: {
                format: {
                  abbreviated: {
                    sun: "Sun",
                    mon: "Mon",
                    tue: "Tue",
                    wed: "Wed",
                    thu: "Thu",
                    fri: "Fri",
                    sat: "Sat"
                  },
                  narrow: {
                    sun: "S",
                    mon: "M",
                    tue: "T",
                    wed: "W",
                    thu: "T",
                    fri: "F",
                    sat: "S"
                  },
                  short: {
                    sun: "Su",
                    mon: "Mo",
                    tue: "Tu",
                    wed: "We",
                    thu: "Th",
                    fri: "Fr",
                    sat: "Sa"
                  },
                  wide: {
                    sun: "Sunday",
                    mon: "Monday",
                    tue: "Tuesday",
                    wed: "Wednesday",
                    thu: "Thursday",
                    fri: "Friday",
                    sat: "Saturday"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    sun: "Sun",
                    mon: "Mon",
                    tue: "Tue",
                    wed: "Wed",
                    thu: "Thu",
                    fri: "Fri",
                    sat: "Sat"
                  },
                  narrow: {
                    sun: "S",
                    mon: "M",
                    tue: "T",
                    wed: "W",
                    thu: "T",
                    fri: "F",
                    sat: "S"
                  },
                  short: {
                    sun: "Su",
                    mon: "Mo",
                    tue: "Tu",
                    wed: "We",
                    thu: "Th",
                    fri: "Fr",
                    sat: "Sa"
                  },
                  wide: {
                    sun: "Sunday",
                    mon: "Monday",
                    tue: "Tuesday",
                    wed: "Wednesday",
                    thu: "Thursday",
                    fri: "Friday",
                    sat: "Saturday"
                  }
                }
              },
              quarters: {
                format: {
                  abbreviated: {
                    "1": "Q1",
                    "2": "Q2",
                    "3": "Q3",
                    "4": "Q4"
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "1st quarter",
                    "2": "2nd quarter",
                    "3": "3rd quarter",
                    "4": "4th quarter"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "Q1",
                    "2": "Q2",
                    "3": "Q3",
                    "4": "Q4"
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "1st quarter",
                    "2": "2nd quarter",
                    "3": "3rd quarter",
                    "4": "4th quarter"
                  }
                }
              },
              dayPeriods: {
                format: {
                  abbreviated: {
                    midnight: "midnight",
                    am: "AM",
                    "am-alt-variant": "am",
                    noon: "noon",
                    pm: "PM",
                    "pm-alt-variant": "pm",
                    morning1: "in the morning",
                    afternoon1: "in the afternoon",
                    evening1: "in the evening",
                    night1: "at night"
                  },
                  narrow: {
                    midnight: "mi",
                    am: "a",
                    "am-alt-variant": "am",
                    noon: "n",
                    pm: "p",
                    "pm-alt-variant": "pm",
                    morning1: "in the morning",
                    afternoon1: "in the afternoon",
                    evening1: "in the evening",
                    night1: "at night"
                  },
                  wide: {
                    midnight: "midnight",
                    am: "AM",
                    "am-alt-variant": "am",
                    noon: "noon",
                    pm: "PM",
                    "pm-alt-variant": "pm",
                    morning1: "in the morning",
                    afternoon1: "in the afternoon",
                    evening1: "in the evening",
                    night1: "at night"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    midnight: "midnight",
                    am: "AM",
                    "am-alt-variant": "am",
                    noon: "noon",
                    pm: "PM",
                    "pm-alt-variant": "pm",
                    morning1: "in the morning",
                    afternoon1: "in the afternoon",
                    evening1: "in the evening",
                    night1: "at night"
                  },
                  narrow: {
                    midnight: "midnight",
                    am: "AM",
                    "am-alt-variant": "am",
                    noon: "noon",
                    pm: "PM",
                    "pm-alt-variant": "pm",
                    morning1: "in the morning",
                    afternoon1: "in the afternoon",
                    evening1: "in the evening",
                    night1: "at night"
                  },
                  wide: {
                    midnight: "midnight",
                    am: "AM",
                    "am-alt-variant": "am",
                    noon: "noon",
                    pm: "PM",
                    "pm-alt-variant": "pm",
                    morning1: "morning",
                    afternoon1: "afternoon",
                    evening1: "evening",
                    night1: "night"
                  }
                }
              },
              eras: {
                eraNames: {
                  "0": "Before Christ",
                  "1": "Anno Domini",
                  "0-alt-variant": "Before Common Era",
                  "1-alt-variant": "Common Era"
                },
                eraAbbr: {
                  "0": "BC",
                  "1": "AD",
                  "0-alt-variant": "BCE",
                  "1-alt-variant": "CE"
                },
                eraNarrow: {
                  "0": "B",
                  "1": "A",
                  "0-alt-variant": "BCE",
                  "1-alt-variant": "CE"
                }
              },
              dateFormats: {
                full: "EEEE, MMMM d, y",
                long: "MMMM d, y",
                medium: "MMM d, y",
                short: "M/d/yy"
              },
              timeFormats: {
                full: "h:mm:ss a zzzz",
                long: "h:mm:ss a z",
                medium: "h:mm:ss a",
                short: "h:mm a"
              },
              dateTimeFormats: {
                full: "{1} 'at' {0}",
                long: "{1} 'at' {0}",
                medium: "{1}, {0}",
                short: "{1}, {0}",
                availableFormats: {
                  d: "d",
                  E: "ccc",
                  Ed: "d E",
                  Ehm: "E h:mm a",
                  EHm: "E HH:mm",
                  Ehms: "E h:mm:ss a",
                  EHms: "E HH:mm:ss",
                  Gy: "y G",
                  GyMMM: "MMM y G",
                  GyMMMd: "MMM d, y G",
                  GyMMMEd: "E, MMM d, y G",
                  h: "h a",
                  H: "HH",
                  hm: "h:mm a",
                  Hm: "HH:mm",
                  hms: "h:mm:ss a",
                  Hms: "HH:mm:ss",
                  hmsv: "h:mm:ss a v",
                  Hmsv: "HH:mm:ss v",
                  hmv: "h:mm a v",
                  Hmv: "HH:mm v",
                  M: "L",
                  Md: "M/d",
                  MEd: "E, M/d",
                  MMM: "LLL",
                  MMMd: "MMM d",
                  MMMEd: "E, MMM d",
                  MMMMd: "MMMM d",
                  ms: "mm:ss",
                  y: "y",
                  yM: "M/y",
                  yMd: "M/d/y",
                  yMEd: "E, M/d/y",
                  yMMM: "MMM y",
                  yMMMd: "MMM d, y",
                  yMMMEd: "E, MMM d, y",
                  yMMMM: "MMMM y",
                  yQQQ: "QQQ y",
                  yQQQQ: "QQQQ y"
                },
                appendItems: {
                  Day: "{0} ({2}: {1})",
                  "Day-Of-Week": "{0} {1}",
                  Era: "{0} {1}",
                  Hour: "{0} ({2}: {1})",
                  Minute: "{0} ({2}: {1})",
                  Month: "{0} ({2}: {1})",
                  Quarter: "{0} ({2}: {1})",
                  Second: "{0} ({2}: {1})",
                  Timezone: "{0} {1}",
                  Week: "{0} ({2}: {1})",
                  Year: "{0} {1}"
                },
                intervalFormats: {
                  intervalFormatFallback: "{0}  {1}",
                  d: {
                    d: "d  d"
                  },
                  h: {
                    a: "h a  h a",
                    h: "h  h a"
                  },
                  H: {
                    H: "HH  HH"
                  },
                  hm: {
                    a: "h:mm a  h:mm a",
                    h: "h:mm  h:mm a",
                    m: "h:mm  h:mm a"
                  },
                  Hm: {
                    H: "HH:mm  HH:mm",
                    m: "HH:mm  HH:mm"
                  },
                  hmv: {
                    a: "h:mm a  h:mm a v",
                    h: "h:mm  h:mm a v",
                    m: "h:mm  h:mm a v"
                  },
                  Hmv: {
                    H: "HH:mm  HH:mm v",
                    m: "HH:mm  HH:mm v"
                  },
                  hv: {
                    a: "h a  h a v",
                    h: "h  h a v"
                  },
                  Hv: {
                    H: "HH  HH v"
                  },
                  M: {
                    M: "M  M"
                  },
                  Md: {
                    d: "M/d  M/d",
                    M: "M/d  M/d"
                  },
                  MEd: {
                    d: "E, M/d  E, M/d",
                    M: "E, M/d  E, M/d"
                  },
                  MMM: {
                    M: "MMM  MMM"
                  },
                  MMMd: {
                    d: "MMM d  d",
                    M: "MMM d  MMM d"
                  },
                  MMMEd: {
                    d: "E, MMM d  E, MMM d",
                    M: "E, MMM d  E, MMM d"
                  },
                  y: {
                    y: "y  y"
                  },
                  yM: {
                    M: "M/y  M/y",
                    y: "M/y  M/y"
                  },
                  yMd: {
                    d: "M/d/y  M/d/y",
                    M: "M/d/y  M/d/y",
                    y: "M/d/y  M/d/y"
                  },
                  yMEd: {
                    d: "E, M/d/y  E, M/d/y",
                    M: "E, M/d/y  E, M/d/y",
                    y: "E, M/d/y  E, M/d/y"
                  },
                  yMMM: {
                    M: "MMM  MMM y",
                    y: "MMM y  MMM y"
                  },
                  yMMMd: {
                    d: "MMM d  d, y",
                    M: "MMM d  MMM d, y",
                    y: "MMM d, y  MMM d, y"
                  },
                  yMMMEd: {
                    d: "E, MMM d  E, MMM d, y",
                    M: "E, MMM d  E, MMM d, y",
                    y: "E, MMM d, y  E, MMM d, y"
                  },
                  yMMMM: {
                    M: "MMMM  MMMM y",
                    y: "MMMM y  MMMM y"
                  }
                }
              }
            }
          }
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      en: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11972 $"
          },
          language: "en"
        },
        numbers: {
          defaultNumberingSystem: "latn",
          otherNumberingSystems: {
            native: "latn"
          },
          minimumGroupingDigits: "1",
          "symbols-numberSystem-latn": {
            decimal: ".",
            group: ",",
            list: ";",
            percentSign: "%",
            plusSign: "+",
            minusSign: "-",
            exponential: "E",
            superscriptingExponent: "",
            perMille: "",
            infinity: "",
            nan: "NaN",
            timeSeparator: ":"
          },
          "decimalFormats-numberSystem-latn": {
            standard: "#,##0.###",
            long: {
              decimalFormat: {
                "1000-count-one": "0 thousand",
                "1000-count-other": "0 thousand",
                "10000-count-one": "00 thousand",
                "10000-count-other": "00 thousand",
                "100000-count-one": "000 thousand",
                "100000-count-other": "000 thousand",
                "1000000-count-one": "0 million",
                "1000000-count-other": "0 million",
                "10000000-count-one": "00 million",
                "10000000-count-other": "00 million",
                "100000000-count-one": "000 million",
                "100000000-count-other": "000 million",
                "1000000000-count-one": "0 billion",
                "1000000000-count-other": "0 billion",
                "10000000000-count-one": "00 billion",
                "10000000000-count-other": "00 billion",
                "100000000000-count-one": "000 billion",
                "100000000000-count-other": "000 billion",
                "1000000000000-count-one": "0 trillion",
                "1000000000000-count-other": "0 trillion",
                "10000000000000-count-one": "00 trillion",
                "10000000000000-count-other": "00 trillion",
                "100000000000000-count-one": "000 trillion",
                "100000000000000-count-other": "000 trillion"
              }
            },
            short: {
              decimalFormat: {
                "1000-count-one": "0K",
                "1000-count-other": "0K",
                "10000-count-one": "00K",
                "10000-count-other": "00K",
                "100000-count-one": "000K",
                "100000-count-other": "000K",
                "1000000-count-one": "0M",
                "1000000-count-other": "0M",
                "10000000-count-one": "00M",
                "10000000-count-other": "00M",
                "100000000-count-one": "000M",
                "100000000-count-other": "000M",
                "1000000000-count-one": "0B",
                "1000000000-count-other": "0B",
                "10000000000-count-one": "00B",
                "10000000000-count-other": "00B",
                "100000000000-count-one": "000B",
                "100000000000-count-other": "000B",
                "1000000000000-count-one": "0T",
                "1000000000000-count-other": "0T",
                "10000000000000-count-one": "00T",
                "10000000000000-count-other": "00T",
                "100000000000000-count-one": "000T",
                "100000000000000-count-other": "000T"
              }
            }
          },
          "scientificFormats-numberSystem-latn": {
            standard: "#E0"
          },
          "percentFormats-numberSystem-latn": {
            standard: "#,##0%"
          },
          "currencyFormats-numberSystem-latn": {
            currencySpacing: {
              beforeCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              },
              afterCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              }
            },
            standard: "#,##0.00",
            accounting: "#,##0.00;(#,##0.00)",
            short: {
              standard: {
                "1000-count-one": "0K",
                "1000-count-other": "0K",
                "10000-count-one": "00K",
                "10000-count-other": "00K",
                "100000-count-one": "000K",
                "100000-count-other": "000K",
                "1000000-count-one": "0M",
                "1000000-count-other": "0M",
                "10000000-count-one": "00M",
                "10000000-count-other": "00M",
                "100000000-count-one": "000M",
                "100000000-count-other": "000M",
                "1000000000-count-one": "0B",
                "1000000000-count-other": "0B",
                "10000000000-count-one": "00B",
                "10000000000-count-other": "00B",
                "100000000000-count-one": "000B",
                "100000000000-count-other": "000B",
                "1000000000000-count-one": "0T",
                "1000000000000-count-other": "0T",
                "10000000000000-count-one": "00T",
                "10000000000000-count-other": "00T",
                "100000000000000-count-one": "000T",
                "100000000000000-count-other": "000T"
              }
            },
            "unitPattern-count-one": "{0} {1}",
            "unitPattern-count-other": "{0} {1}"
          },
          "miscPatterns-numberSystem-latn": {
            atLeast: "{0}+",
            range: "{0}{1}"
          }
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      ro: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11917 $"
          },
          language: "ro"
        },
        dates: {
          calendars: {
            gregorian: {
              months: {
                format: {
                  abbreviated: {
                    "1": "ian.",
                    "2": "feb.",
                    "3": "mar.",
                    "4": "apr.",
                    "5": "mai",
                    "6": "iun.",
                    "7": "iul.",
                    "8": "aug.",
                    "9": "sept.",
                    "10": "oct.",
                    "11": "nov.",
                    "12": "dec."
                  },
                  narrow: {
                    "1": "I",
                    "2": "F",
                    "3": "M",
                    "4": "A",
                    "5": "M",
                    "6": "I",
                    "7": "I",
                    "8": "A",
                    "9": "S",
                    "10": "O",
                    "11": "N",
                    "12": "D"
                  },
                  wide: {
                    "1": "ianuarie",
                    "2": "februarie",
                    "3": "martie",
                    "4": "aprilie",
                    "5": "mai",
                    "6": "iunie",
                    "7": "iulie",
                    "8": "august",
                    "9": "septembrie",
                    "10": "octombrie",
                    "11": "noiembrie",
                    "12": "decembrie"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "ian.",
                    "2": "feb.",
                    "3": "mar.",
                    "4": "apr.",
                    "5": "mai",
                    "6": "iun.",
                    "7": "iul.",
                    "8": "aug.",
                    "9": "sept.",
                    "10": "oct.",
                    "11": "nov.",
                    "12": "dec."
                  },
                  narrow: {
                    "1": "I",
                    "2": "F",
                    "3": "M",
                    "4": "A",
                    "5": "M",
                    "6": "I",
                    "7": "I",
                    "8": "A",
                    "9": "S",
                    "10": "O",
                    "11": "N",
                    "12": "D"
                  },
                  wide: {
                    "1": "ianuarie",
                    "2": "februarie",
                    "3": "martie",
                    "4": "aprilie",
                    "5": "mai",
                    "6": "iunie",
                    "7": "iulie",
                    "8": "august",
                    "9": "septembrie",
                    "10": "octombrie",
                    "11": "noiembrie",
                    "12": "decembrie"
                  }
                }
              },
              days: {
                format: {
                  abbreviated: {
                    sun: "dum.",
                    mon: "lun.",
                    tue: "mar.",
                    wed: "mie.",
                    thu: "joi",
                    fri: "vin.",
                    sat: "sm."
                  },
                  narrow: {
                    sun: "D",
                    mon: "L",
                    tue: "M",
                    wed: "M",
                    thu: "J",
                    fri: "V",
                    sat: "S"
                  },
                  short: {
                    sun: "du.",
                    mon: "lu.",
                    tue: "ma.",
                    wed: "mi.",
                    thu: "jo.",
                    fri: "vi.",
                    sat: "s."
                  },
                  wide: {
                    sun: "duminic",
                    mon: "luni",
                    tue: "mari",
                    wed: "miercuri",
                    thu: "joi",
                    fri: "vineri",
                    sat: "smbt"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    sun: "dum.",
                    mon: "lun.",
                    tue: "mar.",
                    wed: "mie.",
                    thu: "joi",
                    fri: "vin.",
                    sat: "sm."
                  },
                  narrow: {
                    sun: "D",
                    mon: "L",
                    tue: "M",
                    wed: "M",
                    thu: "J",
                    fri: "V",
                    sat: "S"
                  },
                  short: {
                    sun: "du",
                    mon: "lu",
                    tue: "ma",
                    wed: "mi",
                    thu: "jo",
                    fri: "vi",
                    sat: "s"
                  },
                  wide: {
                    sun: "duminic",
                    mon: "luni",
                    tue: "mari",
                    wed: "miercuri",
                    thu: "joi",
                    fri: "vineri",
                    sat: "smbt"
                  }
                }
              },
              quarters: {
                format: {
                  abbreviated: {
                    "1": "trim. I",
                    "2": "trim. II",
                    "3": "trim. III",
                    "4": "trim. IV"
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "trimestrul I",
                    "2": "trimestrul al II-lea",
                    "3": "trimestrul al III-lea",
                    "4": "trimestrul al IV-lea"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "Trim. I",
                    "2": "Trim. II",
                    "3": "Trim. III",
                    "4": "Trim. IV"
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "Trimestrul I",
                    "2": "Trimestrul al II-lea",
                    "3": "Trimestrul al III-lea",
                    "4": "Trimestrul al IV-lea"
                  }
                }
              },
              dayPeriods: {
                format: {
                  abbreviated: {
                    midnight: "miezul nopii",
                    am: "a.m.",
                    noon: "amiaz",
                    pm: "p.m.",
                    morning1: "dimineaa",
                    afternoon1: "dup-amiaza",
                    evening1: "seara",
                    night1: "noaptea"
                  },
                  narrow: {
                    midnight: "miezul nopii",
                    am: "a.m.",
                    noon: "prnz",
                    pm: "p.m.",
                    morning1: "diminea",
                    afternoon1: "dup-amiaz",
                    evening1: "sear",
                    night1: "noapte"
                  },
                  wide: {
                    midnight: "la miezul nopii",
                    am: "a.m.",
                    noon: "la amiaz",
                    pm: "p.m.",
                    morning1: "dimineaa",
                    afternoon1: "dup-amiaza",
                    evening1: "seara",
                    night1: "noaptea"
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    midnight: "miezul nopii",
                    am: "a.m.",
                    noon: "amiaz",
                    pm: "p.m.",
                    morning1: "dimineaa",
                    afternoon1: "dup-amiaza",
                    evening1: "seara",
                    night1: "noaptea"
                  },
                  narrow: {
                    midnight: "miezul nopii",
                    am: "a.m.",
                    noon: "amiaz",
                    pm: "p.m.",
                    morning1: "dimineaa",
                    afternoon1: "dup-amiaza",
                    evening1: "seara",
                    night1: "noaptea"
                  },
                  wide: {
                    midnight: "la miezul nopii",
                    am: "a.m.",
                    noon: "la amiaz",
                    pm: "p.m.",
                    morning1: "diminea",
                    afternoon1: "dup-amiaz",
                    evening1: "sear",
                    night1: "noapte"
                  }
                }
              },
              eras: {
                eraNames: {
                  "0": "nainte de Hristos",
                  "1": "dup Hristos",
                  "0-alt-variant": "naintea erei noastre",
                  "1-alt-variant": "era noastr"
                },
                eraAbbr: {
                  "0": ".Hr.",
                  "1": "d.Hr.",
                  "0-alt-variant": ".e.n",
                  "1-alt-variant": "e.n."
                },
                eraNarrow: {
                  "0": ".Hr.",
                  "1": "d.Hr.",
                  "0-alt-variant": ".e.n",
                  "1-alt-variant": "e.n."
                }
              },
              dateFormats: {
                full: "EEEE, d MMMM y",
                long: "d MMMM y",
                medium: "d MMM y",
                short: "dd.MM.y"
              },
              timeFormats: {
                full: "HH:mm:ss zzzz",
                long: "HH:mm:ss z",
                medium: "HH:mm:ss",
                short: "HH:mm"
              },
              dateTimeFormats: {
                full: "{1}, {0}",
                long: "{1}, {0}",
                medium: "{1}, {0}",
                short: "{1}, {0}",
                availableFormats: {
                  d: "d",
                  E: "ccc",
                  Ed: "E d",
                  Ehm: "E h:mm a",
                  EHm: "E HH:mm",
                  Ehms: "E h:mm:ss a",
                  EHms: "E HH:mm:ss",
                  Gy: "y G",
                  GyMMM: "MMM y G",
                  GyMMMd: "d MMM y G",
                  GyMMMEd: "E, d MMM y G",
                  h: "h a",
                  H: "HH",
                  hm: "h:mm a",
                  Hm: "HH:mm",
                  hms: "h:mm:ss a",
                  Hms: "HH:mm:ss",
                  hmsv: "h:mm:ss a v",
                  Hmsv: "HH:mm:ss v",
                  hmv: "h:mm a v",
                  Hmv: "HH:mm v",
                  M: "L",
                  Md: "dd.MM",
                  MEd: "E, dd.MM",
                  MMdd: "dd.MM",
                  MMM: "LLL",
                  MMMd: "d MMM",
                  MMMEd: "E, d MMM",
                  MMMMd: "d MMMM",
                  MMMMEd: "E, d MMMM",
                  ms: "mm:ss",
                  y: "y",
                  yM: "MM.y",
                  yMd: "dd.MM.y",
                  yMEd: "E, dd.MM.y",
                  yMM: "MM.y",
                  yMMM: "MMM y",
                  yMMMd: "d MMM y",
                  yMMMEd: "E, d MMM y",
                  yMMMM: "MMMM y",
                  yQQQ: "QQQ y",
                  yQQQQ: "QQQQ y"
                },
                appendItems: {
                  Day: "{0} ({2}: {1})",
                  "Day-Of-Week": "{0} {1}",
                  Era: "{1} {0}",
                  Hour: "{0} ({2}: {1})",
                  Minute: "{0} ({2}: {1})",
                  Month: "{0} ({2}: {1})",
                  Quarter: "{0} ({2}: {1})",
                  Second: "{0} ({2}: {1})",
                  Timezone: "{0} {1}",
                  Week: "{0} ({2}: {1})",
                  Year: "{1} {0}"
                },
                intervalFormats: {
                  intervalFormatFallback: "{0}  {1}",
                  d: {
                    d: "dd"
                  },
                  h: {
                    a: "h a  h a",
                    h: "hh a"
                  },
                  H: {
                    H: "HHHH"
                  },
                  hm: {
                    a: "h:mm a  h:mm a",
                    h: "h:mmh:mm a",
                    m: "h:mmh:mm a"
                  },
                  Hm: {
                    H: "HH:mmHH:mm",
                    m: "HH:mmHH:mm"
                  },
                  hmv: {
                    a: "h:mm a  h:mm a v",
                    h: "h:mmh:mm a v",
                    m: "h:mmh:mm a v"
                  },
                  Hmv: {
                    H: "HH:mmHH:mm v",
                    m: "HH:mmHH:mm v"
                  },
                  hv: {
                    a: "h a  h a v",
                    h: "hh a v"
                  },
                  Hv: {
                    H: "HHHH v"
                  },
                  M: {
                    M: "MM"
                  },
                  Md: {
                    d: "dd.MM  dd.MM",
                    M: "dd.MM  dd.MM"
                  },
                  MEd: {
                    d: "E, dd.MM  E, dd.MM",
                    M: "E, dd.MM  E, dd.MM"
                  },
                  MMM: {
                    M: "MMMMMM"
                  },
                  MMMd: {
                    d: "dd MMM",
                    M: "d MMM  d MMM"
                  },
                  MMMEd: {
                    d: "E, d MMM  E, d MMM",
                    M: "E, d MMM  E, d MMM"
                  },
                  y: {
                    y: "yy"
                  },
                  yM: {
                    M: "MM.y  MM.y",
                    y: "MM.y  MM.y"
                  },
                  yMd: {
                    d: "dd.MM.y  dd.MM.y",
                    M: "dd.MM.y  dd.MM.y",
                    y: "dd.MM.y  dd.MM.y"
                  },
                  yMEd: {
                    d: "E, dd.MM.y  E, dd.MM.y",
                    M: "E, dd.MM.y  E, dd.MM.y",
                    y: "E, dd.MM.y  E, dd.MM.y"
                  },
                  yMMM: {
                    M: "MMMMMM y",
                    y: "MMM y  MMM y"
                  },
                  yMMMd: {
                    d: "dd MMM y",
                    M: "d MMM  d MMM y",
                    y: "d MMM y  d MMM y"
                  },
                  yMMMEd: {
                    d: "E, d MMM  E, d MMM y",
                    M: "E, d MMM  E, d MMM y",
                    y: "E, d MMM y  E, d MMM y"
                  },
                  yMMMM: {
                    M: "MMMM  MMMM y",
                    y: "MMMM y  MMMM y"
                  }
                }
              }
            }
          }
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      ro: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11917 $"
          },
          language: "ro"
        },
        numbers: {
          defaultNumberingSystem: "latn",
          otherNumberingSystems: {
            native: "latn"
          },
          minimumGroupingDigits: "1",
          "symbols-numberSystem-latn": {
            decimal: ",",
            group: ".",
            list: ";",
            percentSign: "%",
            plusSign: "+",
            minusSign: "-",
            exponential: "E",
            superscriptingExponent: "",
            perMille: "",
            infinity: "",
            nan: "NaN",
            timeSeparator: ":"
          },
          "decimalFormats-numberSystem-latn": {
            standard: "#,##0.###",
            long: {
              decimalFormat: {
                "1000-count-one": "0 mie",
                "1000-count-few": "0 mii",
                "1000-count-other": "0 de mii",
                "10000-count-one": "00 mie",
                "10000-count-few": "00 mii",
                "10000-count-other": "00 de mii",
                "100000-count-one": "000 mie",
                "100000-count-few": "000 mii",
                "100000-count-other": "000 de mii",
                "1000000-count-one": "0 milion",
                "1000000-count-few": "0 milioane",
                "1000000-count-other": "0 de milioane",
                "10000000-count-one": "00 milion",
                "10000000-count-few": "00 milioane",
                "10000000-count-other": "00 de milioane",
                "100000000-count-one": "000 milion",
                "100000000-count-few": "000 milioane",
                "100000000-count-other": "000 de milioane",
                "1000000000-count-one": "0 miliard",
                "1000000000-count-few": "0 miliarde",
                "1000000000-count-other": "0 de miliarde",
                "10000000000-count-one": "00 miliard",
                "10000000000-count-few": "00 miliarde",
                "10000000000-count-other": "00 de miliarde",
                "100000000000-count-one": "000 miliard",
                "100000000000-count-few": "000 miliarde",
                "100000000000-count-other": "000 de miliarde",
                "1000000000000-count-one": "0 trilion",
                "1000000000000-count-few": "0 trilioane",
                "1000000000000-count-other": "0 de trilioane",
                "10000000000000-count-one": "00 trilion",
                "10000000000000-count-few": "00 trilioane",
                "10000000000000-count-other": "00 de trilioane",
                "100000000000000-count-one": "000 trilion",
                "100000000000000-count-few": "000 trilioane",
                "100000000000000-count-other": "000 de trilioane"
              }
            },
            short: {
              decimalFormat: {
                "1000-count-one": "0K",
                "1000-count-few": "0K",
                "1000-count-other": "0K",
                "10000-count-one": "00K",
                "10000-count-few": "00K",
                "10000-count-other": "00K",
                "100000-count-one": "000K",
                "100000-count-few": "000K",
                "100000-count-other": "000K",
                "1000000-count-one": "0mil'.'",
                "1000000-count-few": "0mil'.'",
                "1000000-count-other": "0mil'.'",
                "10000000-count-one": "00mil'.'",
                "10000000-count-few": "00mil'.'",
                "10000000-count-other": "00mil'.'",
                "100000000-count-one": "000mil'.'",
                "100000000-count-few": "000mil'.'",
                "100000000-count-other": "000mil'.'",
                "1000000000-count-one": "0mld'.'",
                "1000000000-count-few": "0mld'.'",
                "1000000000-count-other": "0mld'.'",
                "10000000000-count-one": "00mld'.'",
                "10000000000-count-few": "00mld'.'",
                "10000000000-count-other": "00mld'.'",
                "100000000000-count-one": "000mld'.'",
                "100000000000-count-few": "000mld'.'",
                "100000000000-count-other": "000mld'.'",
                "1000000000000-count-one": "0tril'.'",
                "1000000000000-count-few": "0tril'.'",
                "1000000000000-count-other": "0tril'.'",
                "10000000000000-count-one": "00tril'.'",
                "10000000000000-count-few": "00tril'.'",
                "10000000000000-count-other": "00tril'.'",
                "100000000000000-count-one": "000tril'.'",
                "100000000000000-count-few": "000tril'.'",
                "100000000000000-count-other": "000tril'.'"
              }
            }
          },
          "scientificFormats-numberSystem-latn": {
            standard: "#E0"
          },
          "percentFormats-numberSystem-latn": {
            standard: "#,##0%"
          },
          "currencyFormats-numberSystem-latn": {
            currencySpacing: {
              beforeCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              },
              afterCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              }
            },
            standard: "#,##0.00",
            accounting: "#,##0.00;(#,##0.00)",
            short: {
              standard: {
                "1000-count-one": "0mie",
                "1000-count-few": "0mii",
                "1000-count-other": "0mii",
                "10000-count-one": "00mii",
                "10000-count-few": "00mii",
                "10000-count-other": "00mii",
                "100000-count-one": "000mii",
                "100000-count-few": "000mii",
                "100000-count-other": "000mii",
                "1000000-count-one": "0mil'.'",
                "1000000-count-few": "0mil'.'",
                "1000000-count-other": "0mil'.'",
                "10000000-count-one": "00mil'.'",
                "10000000-count-few": "00mil'.'",
                "10000000-count-other": "00mil'.'",
                "100000000-count-one": "000mil'.'",
                "100000000-count-few": "000mil'.'",
                "100000000-count-other": "000mil'.'",
                "1000000000-count-one": "0mld'.'",
                "1000000000-count-few": "0mld'.'",
                "1000000000-count-other": "0mld'.'",
                "10000000000-count-one": "00mld'.'",
                "10000000000-count-few": "00mld'.'",
                "10000000000-count-other": "00mld'.'",
                "100000000000-count-one": "000mld'.'",
                "100000000000-count-few": "000mld'.'",
                "100000000000-count-other": "000mld'.'",
                "1000000000000-count-one": "0tril'.'",
                "1000000000000-count-few": "0tril'.'",
                "1000000000000-count-other": "0tril'.'",
                "10000000000000-count-one": "00tril'.'",
                "10000000000000-count-few": "00tril'.'",
                "10000000000000-count-other": "00tril'.'",
                "100000000000000-count-one": "000tril'.'",
                "100000000000000-count-few": "000tril'.'",
                "100000000000000-count-other": "000tril'.'"
              }
            },
            "unitPattern-count-one": "{0} {1}",
            "unitPattern-count-few": "{0} {1}",
            "unitPattern-count-other": "{0} de {1}"
          },
          "miscPatterns-numberSystem-latn": {
            atLeast: ">{0}",
            range: "{0} - {1}"
          }
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      ru: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11974 $"
          },
          language: "ru"
        },
        dates: {
          calendars: {
            gregorian: {
              months: {
                format: {
                  abbreviated: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  },
                  narrow: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  },
                  wide: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  },
                  narrow: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  },
                  wide: {
                    "1": "",
                    "2": "",
                    "3": "",
                    "4": "",
                    "5": "",
                    "6": "",
                    "7": "",
                    "8": "",
                    "9": "",
                    "10": "",
                    "11": "",
                    "12": ""
                  }
                }
              },
              days: {
                format: {
                  abbreviated: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  narrow: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  short: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  wide: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  narrow: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  short: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  },
                  wide: {
                    sun: "",
                    mon: "",
                    tue: "",
                    wed: "",
                    thu: "",
                    fri: "",
                    sat: ""
                  }
                }
              },
              quarters: {
                format: {
                  abbreviated: {
                    "1": "1- .",
                    "2": "2- .",
                    "3": "3- .",
                    "4": "4- ."
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "1- ",
                    "2": "2- ",
                    "3": "3- ",
                    "4": "4- "
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    "1": "1- .",
                    "2": "2- .",
                    "3": "3- .",
                    "4": "4- ."
                  },
                  narrow: {
                    "1": "1",
                    "2": "2",
                    "3": "3",
                    "4": "4"
                  },
                  wide: {
                    "1": "1- ",
                    "2": "2- ",
                    "3": "3- ",
                    "4": "4- "
                  }
                }
              },
              dayPeriods: {
                format: {
                  abbreviated: {
                    midnight: "",
                    am: "",
                    noon: "",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: "",
                    night1: ""
                  },
                  narrow: {
                    midnight: "",
                    am: "",
                    noon: "",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: "",
                    night1: ""
                  },
                  wide: {
                    midnight: "",
                    am: "",
                    noon: "",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: "",
                    night1: ""
                  }
                },
                "stand-alone": {
                  abbreviated: {
                    midnight: ".",
                    am: "",
                    noon: ".",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: ".",
                    night1: ""
                  },
                  narrow: {
                    midnight: ".",
                    am: "",
                    noon: ".",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: ".",
                    night1: ""
                  },
                  wide: {
                    midnight: "",
                    am: "",
                    noon: "",
                    pm: "",
                    morning1: "",
                    afternoon1: "",
                    evening1: "",
                    night1: ""
                  }
                }
              },
              eras: {
                eraNames: {
                  "0": "  ",
                  "1": "  ",
                  "0-alt-variant": "  ",
                  "1-alt-variant": " "
                },
                eraAbbr: {
                  "0": " . .",
                  "1": ". .",
                  "0-alt-variant": "BCE",
                  "1-alt-variant": "CE"
                },
                eraNarrow: {
                  "0": " ..",
                  "1": "..",
                  "0-alt-variant": "BCE",
                  "1-alt-variant": "CE"
                }
              },
              dateFormats: {
                full: "EEEE, d MMMM y ''.",
                long: "d MMMM y ''.",
                medium: "d MMM y ''.",
                short: "dd.MM.yy"
              },
              timeFormats: {
                full: "H:mm:ss zzzz",
                long: "H:mm:ss z",
                medium: "H:mm:ss",
                short: "H:mm"
              },
              dateTimeFormats: {
                full: "{1}, {0}",
                long: "{1}, {0}",
                medium: "{1}, {0}",
                short: "{1}, {0}",
                availableFormats: {
                  d: "d",
                  E: "ccc",
                  Ed: "ccc, d",
                  Ehm: "E h:mm a",
                  EHm: "E HH:mm",
                  Ehms: "E h:mm:ss a",
                  EHms: "E HH:mm:ss",
                  Gy: "y ''. G",
                  GyMMM: "LLL y G",
                  GyMMMd: "d MMM y ''. G",
                  GyMMMEd: "E, d MMM y ''. G",
                  h: "h a",
                  H: "H",
                  hm: "h:mm a",
                  Hm: "H:mm",
                  hms: "h:mm:ss a",
                  Hms: "H:mm:ss",
                  hmsv: "h:mm:ss a v",
                  Hmsv: "H:mm:ss v",
                  hmv: "h:mm a v",
                  Hmv: "H:mm v",
                  M: "L",
                  Md: "dd.MM",
                  MEd: "E, dd.MM",
                  MMdd: "dd.MM",
                  MMM: "LLL",
                  MMMd: "d MMM",
                  MMMEd: "ccc, d MMM",
                  MMMMd: "d MMMM",
                  ms: "mm:ss",
                  y: "y",
                  yM: "MM.y",
                  yMd: "dd.MM.y",
                  yMEd: "ccc, d.MM.y ''.",
                  yMM: "MM.y",
                  yMMM: "LLL y ''.",
                  yMMMd: "d MMM y ''.",
                  yMMMEd: "E, d MMM y ''.",
                  yMMMM: "LLLL y ''.",
                  yQQQ: "QQQ y ''.",
                  yQQQQ: "QQQQ y ''."
                },
                appendItems: {
                  Day: "{0} ({2}: {1})",
                  "Day-Of-Week": "{0} {1}",
                  Era: "{1} {0}",
                  Hour: "{0} ({2}: {1})",
                  Minute: "{0} ({2}: {1})",
                  Month: "{0} ({2}: {1})",
                  Quarter: "{0} ({2}: {1})",
                  Second: "{0} ({2}: {1})",
                  Timezone: "{0} {1}",
                  Week: "{0} ({2}: {1})",
                  Year: "{1} {0}"
                },
                intervalFormats: {
                  intervalFormatFallback: "{0} - {1}",
                  d: {
                    d: "dd"
                  },
                  h: {
                    a: "h a  h a",
                    h: "hh a"
                  },
                  H: {
                    H: "HH"
                  },
                  hm: {
                    a: "h:mm a  h:mm a",
                    h: "h:mmh:mm a",
                    m: "h:mmh:mm a"
                  },
                  Hm: {
                    H: "H:mmH:mm",
                    m: "H:mmH:mm"
                  },
                  hmv: {
                    a: "h:mm a  h:mm a v",
                    h: "h:mmh:mm a v",
                    m: "h:mmh:mm a v"
                  },
                  Hmv: {
                    H: "H:mmH:mm v",
                    m: "H:mmH:mm v"
                  },
                  hv: {
                    a: "h a  h a v",
                    h: "hh a v"
                  },
                  Hv: {
                    H: "HH v"
                  },
                  M: {
                    M: "MM"
                  },
                  Md: {
                    d: "dd.MM  dd.MM",
                    M: "dd.MM  dd.MM"
                  },
                  MEd: {
                    d: "E, dd.MM  E, dd.MM",
                    M: "E, dd.MM  E, dd.MM"
                  },
                  MMM: {
                    M: "LLL  LLL"
                  },
                  MMMd: {
                    d: "dd MMM",
                    M: "d MMM  d MMM"
                  },
                  MMMEd: {
                    d: "E, d MMM  E, d MMM",
                    M: "E, d MMM  E, d MMM"
                  },
                  MMMM: {
                    M: "LLLL  LLLL"
                  },
                  y: {
                    y: "yy"
                  },
                  yM: {
                    M: "MM.y  MM.y",
                    y: "MM.y  MM.y"
                  },
                  yMd: {
                    d: "dd.MM.y  dd.MM.y",
                    M: "dd.MM.y  dd.MM.y",
                    y: "dd.MM.y  dd.MM.y"
                  },
                  yMEd: {
                    d: "ccc, dd.MM.y  ccc, dd.MM.y",
                    M: "ccc, dd.MM.y  ccc, dd.MM.y",
                    y: "ccc, dd.MM.y  ccc, dd.MM.y"
                  },
                  yMMM: {
                    M: "LLLLLL y ''.",
                    y: "LLL y  LLL y ''."
                  },
                  yMMMd: {
                    d: "dd MMM y ''.",
                    M: "d MMM  d MMM y ''.",
                    y: "d MMM y  d MMM y ''."
                  },
                  yMMMEd: {
                    d: "ccc, d  ccc, d MMM y ''.",
                    M: "ccc, d MMM  ccc, d MMM y ''.",
                    y: "ccc, d MMM y  ccc, d MMM y ''."
                  },
                  yMMMM: {
                    M: "LLLLLLLL y ''.",
                    y: "LLLL y  LLLL y ''."
                  }
                }
              }
            }
          }
        }
      }
    }
  };
}, function(module, exports) {
  module.exports = {
    main: {
      ru: {
        identity: {
          version: {
            _cldrVersion: "28",
            _number: "$Revision: 11974 $"
          },
          language: "ru"
        },
        numbers: {
          defaultNumberingSystem: "latn",
          otherNumberingSystems: {
            native: "latn"
          },
          minimumGroupingDigits: "1",
          "symbols-numberSystem-latn": {
            decimal: ",",
            group: "",
            list: ";",
            percentSign: "%",
            plusSign: "+",
            minusSign: "-",
            exponential: "E",
            superscriptingExponent: "",
            perMille: "",
            infinity: "",
            nan: "",
            timeSeparator: ":"
          },
          "decimalFormats-numberSystem-latn": {
            standard: "#,##0.###",
            long: {
              decimalFormat: {
                "1000-count-one": "0 ",
                "1000-count-few": "0 ",
                "1000-count-many": "0 ",
                "1000-count-other": "0 ",
                "10000-count-one": "00 ",
                "10000-count-few": "00 ",
                "10000-count-many": "00 ",
                "10000-count-other": "00 ",
                "100000-count-one": "000 ",
                "100000-count-few": "000 ",
                "100000-count-many": "000 ",
                "100000-count-other": "000 ",
                "1000000-count-one": "0 ",
                "1000000-count-few": "0 ",
                "1000000-count-many": "0 ",
                "1000000-count-other": "0 ",
                "10000000-count-one": "00 ",
                "10000000-count-few": "00 ",
                "10000000-count-many": "00 ",
                "10000000-count-other": "00 ",
                "100000000-count-one": "000 ",
                "100000000-count-few": "000 ",
                "100000000-count-many": "000 ",
                "100000000-count-other": "000 ",
                "1000000000-count-one": "0 ",
                "1000000000-count-few": "0 ",
                "1000000000-count-many": "0 ",
                "1000000000-count-other": "0 ",
                "10000000000-count-one": "00 ",
                "10000000000-count-few": "00 ",
                "10000000000-count-many": "00 ",
                "10000000000-count-other": "00 ",
                "100000000000-count-one": "000 ",
                "100000000000-count-few": "000 ",
                "100000000000-count-many": "000 ",
                "100000000000-count-other": "000 ",
                "1000000000000-count-one": "0 ",
                "1000000000000-count-few": "0 ",
                "1000000000000-count-many": "0 ",
                "1000000000000-count-other": "0 ",
                "10000000000000-count-one": "00 ",
                "10000000000000-count-few": "00 ",
                "10000000000000-count-many": "00 ",
                "10000000000000-count-other": "00 ",
                "100000000000000-count-one": "000 ",
                "100000000000000-count-few": "000 ",
                "100000000000000-count-many": "000 ",
                "100000000000000-count-other": "000 "
              }
            },
            short: {
              decimalFormat: {
                "1000-count-one": "0'.'",
                "1000-count-few": "0'.'",
                "1000-count-many": "0'.'",
                "1000-count-other": "0'.'",
                "10000-count-one": "00'.'",
                "10000-count-few": "00'.'",
                "10000-count-many": "00'.'",
                "10000-count-other": "00'.'",
                "100000-count-one": "000'.'",
                "100000-count-few": "000'.'",
                "100000-count-many": "000'.'",
                "100000-count-other": "000'.'",
                "1000000-count-one": "0",
                "1000000-count-few": "0",
                "1000000-count-many": "0",
                "1000000-count-other": "0",
                "10000000-count-one": "00",
                "10000000-count-few": "00",
                "10000000-count-many": "00",
                "10000000-count-other": "00",
                "100000000-count-one": "000",
                "100000000-count-few": "000",
                "100000000-count-many": "000",
                "100000000-count-other": "000",
                "1000000000-count-one": "0",
                "1000000000-count-few": "0",
                "1000000000-count-many": "0",
                "1000000000-count-other": "0",
                "10000000000-count-one": "00",
                "10000000000-count-few": "00",
                "10000000000-count-many": "00",
                "10000000000-count-other": "00",
                "100000000000-count-one": "000",
                "100000000000-count-few": "000",
                "100000000000-count-many": "000",
                "100000000000-count-other": "000",
                "1000000000000-count-one": "0",
                "1000000000000-count-few": "0",
                "1000000000000-count-many": "0",
                "1000000000000-count-other": "0",
                "10000000000000-count-one": "00",
                "10000000000000-count-few": "00",
                "10000000000000-count-many": "00",
                "10000000000000-count-other": "00",
                "100000000000000-count-one": "000",
                "100000000000000-count-few": "000",
                "100000000000000-count-many": "000",
                "100000000000000-count-other": "000"
              }
            }
          },
          "scientificFormats-numberSystem-latn": {
            standard: "#E0"
          },
          "percentFormats-numberSystem-latn": {
            standard: "#,##0%"
          },
          "currencyFormats-numberSystem-latn": {
            currencySpacing: {
              beforeCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              },
              afterCurrency: {
                currencyMatch: "[:^S:]",
                surroundingMatch: "[:digit:]",
                insertBetween: ""
              }
            },
            standard: "#,##0.00",
            accounting: "#,##0.00",
            short: {
              standard: {
                "1000-count-one": "0'.'",
                "1000-count-few": "0'.'",
                "1000-count-many": "0'.'",
                "1000-count-other": "0'.'",
                "10000-count-one": "00'.'",
                "10000-count-few": "00'.'",
                "10000-count-many": "00'.'",
                "10000-count-other": "00'.'",
                "100000-count-one": "000'.'",
                "100000-count-few": "000'.'",
                "100000-count-many": "000'.'",
                "100000-count-other": "000'.'",
                "1000000-count-one": "0",
                "1000000-count-few": "0",
                "1000000-count-many": "0",
                "1000000-count-other": "0",
                "10000000-count-one": "00",
                "10000000-count-few": "00",
                "10000000-count-many": "00",
                "10000000-count-other": "00",
                "100000000-count-one": "000",
                "100000000-count-few": "000",
                "100000000-count-many": "000",
                "100000000-count-other": "000",
                "1000000000-count-one": "0",
                "1000000000-count-few": "0",
                "1000000000-count-many": "0",
                "1000000000-count-other": "0",
                "10000000000-count-one": "00",
                "10000000000-count-few": "00",
                "10000000000-count-many": "00",
                "10000000000-count-other": "00",
                "100000000000-count-one": "000",
                "100000000000-count-few": "000",
                "100000000000-count-many": "000",
                "100000000000-count-other": "000",
                "1000000000000-count-one": "0",
                "1000000000000-count-few": "0",
                "1000000000000-count-many": "0",
                "1000000000000-count-other": "0",
                "10000000000000-count-one": "00",
                "10000000000000-count-few": "00",
                "10000000000000-count-many": "00",
                "10000000000000-count-other": "00",
                "100000000000000-count-one": "000",
                "100000000000000-count-few": "000",
                "100000000000000-count-many": "000",
                "100000000000000-count-other": "000"
              }
            },
            "unitPattern-count-one": "{0} {1}",
            "unitPattern-count-few": "{0} {1}",
            "unitPattern-count-many": "{0} {1}",
            "unitPattern-count-other": "{0} {1}"
          },
          "miscPatterns-numberSystem-latn": {
            atLeast: "{0}+",
            range: "{0}-{1}"
          }
        }
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  (function(_) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var defaultMasks, masks;
      defaultMasks = __webpack_require__(46);
      masks = {};
      return _.extend(defaultMasks, masks);
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  (function(_) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var baseMasks;
      __webpack_require__(0);
      baseMasks = __webpack_require__(47);
      return _.extend({}, baseMasks, {
        PHONEALL: {
          mask: "000000000000"
        }
      });
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  !(module.exports = {
    PHONERU: {
      mask: "+0 (000) 000-0000",
      defaultValueOnFocus: "+7"
    },
    PHONEBE: {
      mask: "+00 0000 00 00 00",
      defaultValueOnFocus: "+32"
    },
    PHONE_E164_RU: {
      mask: "+0(000) 000-0000"
    },
    phone: {
      mask: "(000) 000-0000"
    },
    PHONE10: {
      mask: "(000) 000-0000"
    },
    "phone-ua": {
      mask: "+00 000-000-00-00",
      defaultValueOnFocus: "+38"
    },
    postalCode: {
      mask: "#",
      maskOptions: {
        maxlength: false
      }
    },
    INN: {
      mask: "000000000000"
    },
    INN10: {
      mask: "0000000000"
    },
    expiryDate: {
      mask: "00/00"
    },
    cardNumber: {
      mask: "CCCC CCCC CCCC CCCC",
      maskOptions: {
        translation: {
          C: {
            pattern: /[\d\*]/
          }
        }
      }
    },
    birthDateIso: {
      mask: "0000-00-00"
    },
    birthDateNonIso: {
      mask: "00-00-0000"
    },
    cvv: {
      mask: "00000"
    },
    INT: {
      mask: "N",
      maskOptions: {
        translation: {
          N: {
            pattern: /[-\.,\d]/,
            recursive: true
          }
        },
        decimalInput: false,
        allowSign: true
      }
    },
    NONNEGATIVE_INT: {
      mask: "N",
      maskOptions: {
        translation: {
          N: {
            pattern: /[-\.,\d]/,
            recursive: true
          }
        },
        decimalInput: false,
        allowSign: false
      }
    },
    NUMBER: {
      mask: "N",
      maskOptions: {
        translation: {
          N: {
            pattern: /[-\.,\d]/,
            recursive: true
          }
        },
        decimalInput: true,
        allowSign: true
      }
    },
    NONNEGATIVE_NUMBER: {
      mask: "N",
      maskOptions: {
        translation: {
          N: {
            pattern: /[-\.,\d]/,
            recursive: true
          }
        },
        decimalInput: true,
        allowSign: false
      }
    }
  });
}, function(module, exports) {
  (function() {
    function require(e, t, n) {
      t || (t = 0);
      var r = require.resolve(e, t), i = require.m[t][r];
      if (!i) throw new Error('failed to require "' + e + '" from ' + n);
      if (i.c) {
        t = i.c, r = i.m, i = require.m[t][i.m];
        if (!i) throw new Error('failed to require "' + r + '" from ' + t);
      }
      return i.exports || (i.exports = {}, i.call(i.exports, i, i.exports, require.relative(r, t))), 
      i.exports;
    }
    require.resolve = function(e, t) {
      var n = e, r = e + ".js", i = e + "/index.js";
      return require.m[t][r] && r || require.m[t][i] && i || n;
    }, require.relative = function(e, t) {
      return function(n) {
        if ("." != n.charAt(0)) return require(n, t, e);
        var r = e.split("/"), i = n.split("/");
        r.pop();
        for (var s = 0; s < i.length; s++) {
          var o = i[s];
          ".." == o ? r.pop() : "." != o && r.push(o);
        }
        return require(r.join("/"), t, e);
      };
    };
    require.m = [];
    require.m[0] = {
      "lib/web/index.js": function(module, exports, require) {
        var e = require("../common/minilog.js"), t = e.enable, n = e.disable, r = typeof navigator != "undefined" && /chrome/i.test(navigator.userAgent), i = require("./console.js");
        e.defaultBackend = r ? i.minilog : i;
        if (typeof window != "undefined") {
          try {
            e.enable(JSON.parse(window.localStorage.minilogSettings));
          } catch (s) {}
          if (window.location && window.location.search) {
            var o = RegExp("[?&]minilog=([^&]*)").exec(window.location.search);
            o && e.enable(decodeURIComponent(o[1]));
          }
        }
        e.enable = function() {
          t.call(e, !0);
          try {
            window.localStorage.minilogSettings = JSON.stringify(!0);
          } catch (n) {}
          return this;
        }, e.disable = function() {
          n.call(e);
          try {
            delete window.localStorage.minilogSettings;
          } catch (t) {}
          return this;
        }, exports = module.exports = e, exports.backends = {
          array: require("./array.js"),
          browser: e.defaultBackend,
          localStorage: require("./localstorage.js"),
          jQuery: require("./jquery_simple.js")
        };
      },
      "lib/web/array.js": function(module, exports, require) {
        var e = require("../common/transform.js"), t = [], n = new e();
        n.write = function(e, n, r) {
          t.push([ e, n, r ]);
        }, n.get = function() {
          return t;
        }, n.empty = function() {
          t = [];
        }, module.exports = n;
      },
      "lib/web/console.js": function(module, exports, require) {
        var e = require("../common/transform.js"), t = /\n+$/, n = new e();
        n.write = function(e, n, r) {
          var i = r.length - 1;
          if (typeof console == "undefined" || !console.log) return;
          if (console.log.apply) return console.log.apply(console, [ e, n ].concat(r));
          if (JSON && JSON.stringify) {
            r[i] && typeof r[i] == "string" && (r[i] = r[i].replace(t, ""));
            try {
              for (i = 0; i < r.length; i++) r[i] = JSON.stringify(r[i]);
            } catch (s) {}
            console.log(r.join(" "));
          }
        }, n.formatters = [ "color", "minilog" ], n.color = require("./formatters/color.js"), 
        n.minilog = require("./formatters/minilog.js"), module.exports = n;
      },
      "lib/common/filter.js": function(module, exports, require) {
        function n() {
          this.enabled = !0, this.defaultResult = !0, this.clear();
        }
        function r(e, t) {
          return e.n.test ? e.n.test(t) : e.n == t;
        }
        var e = require("./transform.js"), t = {
          debug: 1,
          info: 2,
          warn: 3,
          error: 4
        };
        e.mixin(n), n.prototype.allow = function(e, n) {
          return this._white.push({
            n: e,
            l: t[n]
          }), this;
        }, n.prototype.deny = function(e, n) {
          return this._black.push({
            n: e,
            l: t[n]
          }), this;
        }, n.prototype.clear = function() {
          return this._white = [], this._black = [], this;
        }, n.prototype.test = function(e, n) {
          var i, s = Math.max(this._white.length, this._black.length);
          for (i = 0; i < s; i++) {
            if (this._white[i] && r(this._white[i], e) && t[n] >= this._white[i].l) return !0;
            if (this._black[i] && r(this._black[i], e) && t[n] < this._black[i].l) return !1;
          }
          return this.defaultResult;
        }, n.prototype.write = function(e, t, n) {
          if (!this.enabled || this.test(e, t)) return this.emit("item", e, t, n);
        }, module.exports = n;
      },
      "lib/common/minilog.js": function(module, exports, require) {
        var e = require("./transform.js"), t = require("./filter.js"), n = new e(), r = Array.prototype.slice;
        exports = module.exports = function(t) {
          var i = function() {
            return n.write(t, undefined, r.call(arguments)), i;
          };
          return i.debug = function() {
            return n.write(t, "debug", r.call(arguments)), i;
          }, i.info = function() {
            return n.write(t, "info", r.call(arguments)), i;
          }, i.warn = function() {
            return n.write(t, "warn", r.call(arguments)), i;
          }, i.error = function() {
            return n.write(t, "error", r.call(arguments)), i;
          }, i.suggest = exports.suggest, i.format = n.format, i;
        }, exports.defaultBackend = exports.defaultFormatter = null, exports.pipe = function(e) {
          return n.pipe(e);
        }, exports.end = exports.unpipe = exports.disable = function(e) {
          return n.unpipe(e);
        }, exports.Transform = e, exports.Filter = t, exports.suggest = new t(), exports.enable = function() {
          return exports.defaultFormatter ? n.pipe(exports.suggest).pipe(exports.defaultFormatter).pipe(exports.defaultBackend) : n.pipe(exports.suggest).pipe(exports.defaultBackend);
        };
      },
      "lib/common/transform.js": function(module, exports, require) {
        function t() {}
        var e = require("microee");
        e.mixin(t), t.prototype.write = function(e, t, n) {
          this.emit("item", e, t, n);
        }, t.prototype.end = function() {
          this.emit("end"), this.removeAllListeners();
        }, t.prototype.pipe = function(e) {
          function n() {
            e.write.apply(e, Array.prototype.slice.call(arguments));
          }
          function r() {
            !e._isStdio && e.end();
          }
          var t = this;
          return t.emit("unpipe", e), e.emit("pipe", t), t.on("item", n), t.on("end", r), 
          t.when("unpipe", function(i) {
            var o = i === e || typeof i == "undefined";
            return o && (t.removeListener("item", n), t.removeListener("end", r), e.emit("unpipe")), 
            o;
          }), e;
        }, t.prototype.unpipe = function(e) {
          return this.emit("unpipe", e), this;
        }, t.prototype.format = function(e) {
          throw new Error([ "Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:", "var Minilog = require('minilog');", "Minilog", "  .pipe(Minilog.backends.console.formatClean)", "  .pipe(Minilog.backends.console);" ].join("\n"));
        }, t.mixin = function(e) {
          var n = t.prototype, r;
          for (r in n) n.hasOwnProperty(r) && (e.prototype[r] = n[r]);
        }, module.exports = t;
      },
      "lib/web/localstorage.js": function(module, exports, require) {
        var e = require("../common/transform.js"), t = !1, n = new e();
        n.write = function(e, n, r) {
          if (typeof window == "undefined" || typeof JSON == "undefined" || !JSON.stringify || !JSON.parse) return;
          try {
            t || (t = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []), 
            t.push([ new Date().toString(), e, n, r ]), window.localStorage.minilog = JSON.stringify(t);
          } catch (i) {}
        };
      },
      "lib/web/jquery_simple.js": function(module, exports, require) {
        function n(e) {
          this.url = e.url || "", this.cache = [], this.timer = null, this.interval = e.interval || 3e4, 
          this.enabled = !0, this.jQuery = window.jQuery;
        }
        var e = require("../common/transform.js"), t = new Date().valueOf().toString(36);
        e.mixin(n), n.prototype.write = function(e, t, n) {
          this.timer || this.init(), this.cache.push([ e, t ].concat(n));
        }, n.prototype.init = function() {
          if (!this.enabled || !this.jQuery) return;
          var e = this;
          this.timer = setTimeout(function() {
            var n, r = [];
            if (e.cache.length == 0) return e.init();
            for (n = 0; n < e.cache.length; n++) try {
              r.push(JSON.stringify(e.cache[n]));
            } catch (i) {}
            e.jQuery.ajax(e.url + "?client_id=" + t, {
              type: "POST",
              cache: !1,
              processData: !1,
              data: r.join("\n"),
              contentType: "application/json",
              timeout: 1e4
            }).success(function(t, n, r) {
              t.interval && (e.interval = Math.max(1e3, t.interval));
            }).error(function() {
              e.interval = 3e4;
            }).always(function() {
              e.init();
            }), e.cache = [];
          }, this.interval);
        }, n.prototype.end = function() {}, n.jQueryWait = function(e) {
          if (typeof window != "undefined" && (window.jQuery || window.$)) return e(window.jQuery || window.$);
          typeof window != "undefined" && setTimeout(function() {
            n.jQueryWait(e);
          }, 200);
        }, module.exports = n;
      },
      "lib/web/formatters/util.js": function(module, exports, require) {
        function t(t, n) {
          return n ? "color: #fff; background: " + e[t] + ";" : "color: " + e[t] + ";";
        }
        var e = {
          black: "#000",
          red: "#c23621",
          green: "#25bc26",
          yellow: "#bbbb00",
          blue: "#492ee1",
          magenta: "#d338d3",
          cyan: "#33bbc8",
          gray: "#808080",
          purple: "#708"
        };
        module.exports = t;
      },
      "lib/web/formatters/color.js": function(module, exports, require) {
        var e = require("../../common/transform.js"), t = require("./util.js"), n = {
          debug: [ "cyan" ],
          info: [ "purple" ],
          warn: [ "yellow", !0 ],
          error: [ "red", !0 ]
        }, r = new e();
        r.write = function(e, r, i) {
          var s = console.log;
          console[r] && console[r].apply && (s = console[r], s.apply(console, [ "%c" + e + " %c" + r, t("gray"), t.apply(t, n[r]) ].concat(i)));
        }, r.pipe = function() {}, module.exports = r;
      },
      "lib/web/formatters/minilog.js": function(module, exports, require) {
        var e = require("../../common/transform.js"), t = require("./util.js");
        colors = {
          debug: [ "gray" ],
          info: [ "purple" ],
          warn: [ "yellow", !0 ],
          error: [ "red", !0 ]
        }, logger = new e(), logger.write = function(e, n, r) {
          var i = console.log;
          n != "debug" && console[n] && (i = console[n]);
          var s = [], o = 0;
          if (n != "info") {
            for (;o < r.length; o++) if (typeof r[o] != "string") break;
            i.apply(console, [ "%c" + e + " " + r.slice(0, o).join(" "), t.apply(t, colors[n]) ].concat(r.slice(o)));
          } else i.apply(console, [ "%c" + e, t.apply(t, colors[n]) ].concat(r));
        }, logger.pipe = function() {}, module.exports = logger;
      },
      microee: {
        c: 1,
        m: "index.js"
      }
    };
    require.m[1] = {
      "index.js": function(module, exports, require) {
        function e() {
          this._events = {};
        }
        e.prototype = {
          on: function(e, t) {
            this._events || (this._events = {});
            var n = this._events;
            return (n[e] || (n[e] = [])).push(t), this;
          },
          removeListener: function(e, t) {
            var n = this._events[e] || [], r;
            for (r = n.length - 1; r >= 0 && n[r]; r--) (n[r] === t || n[r].cb === t) && n.splice(r, 1);
          },
          removeAllListeners: function(e) {
            e ? this._events[e] && (this._events[e] = []) : this._events = {};
          },
          emit: function(e) {
            this._events || (this._events = {});
            var t = Array.prototype.slice.call(arguments, 1), n, r = this._events[e] || [];
            for (n = r.length - 1; n >= 0 && r[n]; n--) r[n].apply(this, t);
            return this;
          },
          when: function(e, t) {
            return this.once(e, t, !0);
          },
          once: function(e, t, n) {
            function r() {
              n || this.removeListener(e, r), t.apply(this, arguments) && n && this.removeListener(e, r);
            }
            return t ? (r.cb = t, this.on(e, r), this) : this;
          }
        }, e.mixin = function(t) {
          var n = e.prototype, r;
          for (r in n) n.hasOwnProperty(r) && (t.prototype[r] = n[r]);
        }, module.exports = e;
      }
    };
    Minilog = require("lib/web/index.js");
  })();
}, function(module, exports, __webpack_require__) {
  /**
 * @preserve jed.js https://github.com/SlexAxton/Jed
 */
  /*
-----------
A gettext compatible i18n library for modern JavaScript Applications

by Alex Sexton - AlexSexton [at] gmail - @SlexAxton

MIT License

A jQuery Foundation project - requires CLA to contribute -
https://contribute.jquery.org/CLA/



Jed offers the entire applicable GNU gettext spec'd set of
functions, but also offers some nicer wrappers around them.
The api for gettext was written for a language with no function
overloading, so Jed allows a little more of that.

Many thanks to Joshua I. Miller - unrtst@cpan.org - who wrote
gettext.js back in 2008. I was able to vet a lot of my ideas
against his. I also made sure Jed passed against his tests
in order to offer easy upgrades -- jsgettext.berlios.de
*/
  (function(root, undef) {
    // Underscore 1.3.0 was used to port and is licensed
    // under the MIT License by Jeremy Ashkenas.
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
    var _ = {
      forEach: function(obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function(obj) {
        this.forEach(slice.call(arguments, 1), function(source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
    var Jed = function(options) {
      this.defaults = {
        locale_data: {
          messages: {
            "": {
              domain: "messages",
              lang: "en",
              plural_forms: "nplurals=2; plural=(n != 1);"
            }
          }
        },
        domain: "messages",
        debug: false
      };
      this.options = _.extend({}, this.defaults, options);
      this.textdomain(this.options.domain);
      if (options.domain && !this.options.locale_data[this.options.domain]) {
        throw new Error("Text domain set to non-existent domain: `" + options.domain + "`");
      }
    };
    Jed.context_delimiter = String.fromCharCode(4);
    function getPluralFormFunc(plural_form_string) {
      return Jed.PF.compile(plural_form_string || "nplurals=2; plural=(n != 1);");
    }
    function Chain(key, i18n) {
      this._key = key;
      this._i18n = i18n;
    }
    _.extend(Chain.prototype, {
      onDomain: function(domain) {
        this._domain = domain;
        return this;
      },
      withContext: function(context) {
        this._context = context;
        return this;
      },
      ifPlural: function(num, pkey) {
        this._val = num;
        this._pkey = pkey;
        return this;
      },
      fetch: function(sArr) {
        if ({}.toString.call(sArr) != "[object Array]") {
          sArr = [].slice.call(arguments, 0);
        }
        return (sArr && sArr.length ? Jed.sprintf : function(x) {
          return x;
        })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
      }
    });
    _.extend(Jed.prototype, {
      translate: function(key) {
        return new Chain(key, this);
      },
      textdomain: function(domain) {
        if (!domain) {
          return this._textdomain;
        }
        this._textdomain = domain;
      },
      gettext: function(key) {
        return this.dcnpgettext.call(this, undef, undef, key);
      },
      dgettext: function(domain, key) {
        return this.dcnpgettext.call(this, domain, undef, key);
      },
      dcgettext: function(domain, key) {
        return this.dcnpgettext.call(this, domain, undef, key);
      },
      ngettext: function(skey, pkey, val) {
        return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
      },
      dngettext: function(domain, skey, pkey, val) {
        return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
      },
      dcngettext: function(domain, skey, pkey, val) {
        return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
      },
      pgettext: function(context, key) {
        return this.dcnpgettext.call(this, undef, context, key);
      },
      dpgettext: function(domain, context, key) {
        return this.dcnpgettext.call(this, domain, context, key);
      },
      dcpgettext: function(domain, context, key) {
        return this.dcnpgettext.call(this, domain, context, key);
      },
      npgettext: function(context, skey, pkey, val) {
        return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
      },
      dnpgettext: function(domain, context, skey, pkey, val) {
        return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
      },
      dcnpgettext: function(domain, context, singular_key, plural_key, val) {
        plural_key = plural_key || singular_key;
        domain = domain || this._textdomain;
        var fallback;
        if (!this.options) {
          fallback = new Jed();
          return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
        }
        if (!this.options.locale_data) {
          throw new Error("No locale data provided.");
        }
        if (!this.options.locale_data[domain]) {
          throw new Error("Domain `" + domain + "` was not found.");
        }
        if (!this.options.locale_data[domain][""]) {
          throw new Error("No locale meta information provided.");
        }
        if (!singular_key) {
          throw new Error("No translation key found.");
        }
        var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[""], pluralForms = dict[""].plural_forms || dict[""]["Plural-Forms"] || dict[""]["plural-forms"] || defaultConf.plural_forms || defaultConf["Plural-Forms"] || defaultConf["plural-forms"], val_list, res;
        var val_idx;
        if (val === undefined) {
          val_idx = 0;
        } else {
          if (typeof val != "number") {
            val = parseInt(val, 10);
            if (isNaN(val)) {
              throw new Error("The number that was passed in is not a number.");
            }
          }
          val_idx = getPluralFormFunc(pluralForms)(val);
        }
        if (!dict) {
          throw new Error("No domain named `" + domain + "` could be found.");
        }
        val_list = dict[key];
        if (!val_list || val_idx > val_list.length) {
          if (this.options.missing_key_callback) {
            this.options.missing_key_callback(key, domain);
          }
          res = [ singular_key, plural_key ];
          if (this.options.debug === true) {
            console.log(res[getPluralFormFunc(pluralForms)(val)]);
          }
          return res[getPluralFormFunc()(val)];
        }
        res = val_list[val_idx];
        if (!res) {
          res = [ singular_key, plural_key ];
          return res[getPluralFormFunc()(val)];
        }
        return res;
      }
    });
    /**
   sprintf() for JavaScript 0.7-beta1
   http://www.diveintojavascript.com/projects/javascript-sprintf

   Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
       * Neither the name of sprintf() for JavaScript nor the
         names of its contributors may be used to endorse or promote products
         derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
    var sprintf = function() {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {}
        return output.join("");
      }
      var str_format = function() {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === "string") {
            output.push(parse_tree[i]);
          } else if (node_type === "array") {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != "number") {
              throw sprintf("[sprintf] expecting number but found %s", get_type(arg));
            }
            if (typeof arg == "undefined" || arg === null) {
              arg = "";
            }
            switch (match[8]) {
             case "b":
              arg = arg.toString(2);
              break;

             case "c":
              arg = String.fromCharCode(arg);
              break;

             case "d":
              arg = parseInt(arg, 10);
              break;

             case "e":
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;

             case "f":
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;

             case "o":
              arg = arg.toString(8);
              break;

             case "s":
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;

             case "u":
              arg = Math.abs(arg);
              break;

             case "x":
              arg = arg.toString(16);
              break;

             case "X":
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? "+" + arg : arg;
            pad_character = match[4] ? match[4] == "0" ? "0" : match[4].charAt(1) : " ";
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : "";
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join("");
      };
      str_format.cache = {};
      str_format.parse = function(fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw "[sprintf] huh?";
                  }
                }
              } else {
                throw "[sprintf] huh?";
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
            }
            parse_tree.push(match);
          } else {
            throw "[sprintf] huh?";
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
    var vsprintf = function(fmt, argv) {
      argv.unshift(fmt);
      return sprintf.apply(null, argv);
    };
    Jed.parse_plural = function(plural_forms, n) {
      plural_forms = plural_forms.replace(/n/g, n);
      return Jed.parse_expression(plural_forms);
    };
    Jed.sprintf = function(fmt, args) {
      if ({}.toString.call(args) == "[object Array]") {
        return vsprintf(fmt, [].slice.call(args));
      }
      return sprintf.apply(this, [].slice.call(arguments));
    };
    Jed.prototype.sprintf = function() {
      return Jed.sprintf.apply(this, arguments);
    };
    Jed.PF = {};
    Jed.PF.parse = function(p) {
      var plural_str = Jed.PF.extractPluralExpr(p);
      return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
    };
    Jed.PF.compile = function(p) {
      function imply(val) {
        return val === true ? 1 : val ? val : 0;
      }
      var ast = Jed.PF.parse(p);
      return function(n) {
        return imply(Jed.PF.interpreter(ast)(n));
      };
    };
    Jed.PF.interpreter = function(ast) {
      return function(n) {
        var res;
        switch (ast.type) {
         case "GROUP":
          return Jed.PF.interpreter(ast.expr)(n);

         case "TERNARY":
          if (Jed.PF.interpreter(ast.expr)(n)) {
            return Jed.PF.interpreter(ast.truthy)(n);
          }
          return Jed.PF.interpreter(ast.falsey)(n);

         case "OR":
          return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);

         case "AND":
          return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);

         case "LT":
          return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);

         case "GT":
          return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);

         case "LTE":
          return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);

         case "GTE":
          return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);

         case "EQ":
          return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);

         case "NEQ":
          return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);

         case "MOD":
          return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);

         case "VAR":
          return n;

         case "NUM":
          return ast.val;

         default:
          throw new Error("Invalid Token found.");
        }
      };
    };
    Jed.PF.extractPluralExpr = function(p) {
      p = p.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      if (!/;\s*$/.test(p)) {
        p = p.concat(";");
      }
      var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
      if (nplurals_matches.length > 1) {
        res.nplurals = nplurals_matches[1];
      } else {
        throw new Error("nplurals not found in plural_forms string: " + p);
      }
      p = p.replace(nplurals_re, "");
      plural_matches = p.match(plural_re);
      if (!(plural_matches && plural_matches.length > 1)) {
        throw new Error("`plural` expression not found: " + p);
      }
      return plural_matches[1];
    };
    Jed.PF.parser = function() {
      var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
          error: 2,
          expressions: 3,
          e: 4,
          EOF: 5,
          "?": 6,
          ":": 7,
          "||": 8,
          "&&": 9,
          "<": 10,
          "<=": 11,
          ">": 12,
          ">=": 13,
          "!=": 14,
          "==": 15,
          "%": 16,
          "(": 17,
          ")": 18,
          n: 19,
          NUMBER: 20,
          $accept: 0,
          $end: 1
        },
        terminals_: {
          2: "error",
          5: "EOF",
          6: "?",
          7: ":",
          8: "||",
          9: "&&",
          10: "<",
          11: "<=",
          12: ">",
          13: ">=",
          14: "!=",
          15: "==",
          16: "%",
          17: "(",
          18: ")",
          19: "n",
          20: "NUMBER"
        },
        productions_: [ 0, [ 3, 2 ], [ 4, 5 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 3 ], [ 4, 1 ], [ 4, 1 ] ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
           case 1:
            return {
              type: "GROUP",
              expr: $$[$0 - 1]
            };
            break;

           case 2:
            this.$ = {
              type: "TERNARY",
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;

           case 3:
            this.$ = {
              type: "OR",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 4:
            this.$ = {
              type: "AND",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 5:
            this.$ = {
              type: "LT",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 6:
            this.$ = {
              type: "LTE",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 7:
            this.$ = {
              type: "GT",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 8:
            this.$ = {
              type: "GTE",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 9:
            this.$ = {
              type: "NEQ",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 10:
            this.$ = {
              type: "EQ",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 11:
            this.$ = {
              type: "MOD",
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;

           case 12:
            this.$ = {
              type: "GROUP",
              expr: $$[$0 - 1]
            };
            break;

           case 13:
            this.$ = {
              type: "VAR"
            };
            break;

           case 14:
            this.$ = {
              type: "NUM",
              val: Number(yytext)
            };
            break;
          }
        },
        table: [ {
          3: 1,
          4: 2,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          1: [ 3 ]
        }, {
          5: [ 1, 6 ],
          6: [ 1, 7 ],
          8: [ 1, 8 ],
          9: [ 1, 9 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ]
        }, {
          4: 17,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          5: [ 2, 13 ],
          6: [ 2, 13 ],
          7: [ 2, 13 ],
          8: [ 2, 13 ],
          9: [ 2, 13 ],
          10: [ 2, 13 ],
          11: [ 2, 13 ],
          12: [ 2, 13 ],
          13: [ 2, 13 ],
          14: [ 2, 13 ],
          15: [ 2, 13 ],
          16: [ 2, 13 ],
          18: [ 2, 13 ]
        }, {
          5: [ 2, 14 ],
          6: [ 2, 14 ],
          7: [ 2, 14 ],
          8: [ 2, 14 ],
          9: [ 2, 14 ],
          10: [ 2, 14 ],
          11: [ 2, 14 ],
          12: [ 2, 14 ],
          13: [ 2, 14 ],
          14: [ 2, 14 ],
          15: [ 2, 14 ],
          16: [ 2, 14 ],
          18: [ 2, 14 ]
        }, {
          1: [ 2, 1 ]
        }, {
          4: 18,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 19,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 20,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 21,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 22,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 23,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 24,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 25,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 26,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          4: 27,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          6: [ 1, 7 ],
          8: [ 1, 8 ],
          9: [ 1, 9 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ],
          18: [ 1, 28 ]
        }, {
          6: [ 1, 7 ],
          7: [ 1, 29 ],
          8: [ 1, 8 ],
          9: [ 1, 9 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ]
        }, {
          5: [ 2, 3 ],
          6: [ 2, 3 ],
          7: [ 2, 3 ],
          8: [ 2, 3 ],
          9: [ 1, 9 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ],
          18: [ 2, 3 ]
        }, {
          5: [ 2, 4 ],
          6: [ 2, 4 ],
          7: [ 2, 4 ],
          8: [ 2, 4 ],
          9: [ 2, 4 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ],
          18: [ 2, 4 ]
        }, {
          5: [ 2, 5 ],
          6: [ 2, 5 ],
          7: [ 2, 5 ],
          8: [ 2, 5 ],
          9: [ 2, 5 ],
          10: [ 2, 5 ],
          11: [ 2, 5 ],
          12: [ 2, 5 ],
          13: [ 2, 5 ],
          14: [ 2, 5 ],
          15: [ 2, 5 ],
          16: [ 1, 16 ],
          18: [ 2, 5 ]
        }, {
          5: [ 2, 6 ],
          6: [ 2, 6 ],
          7: [ 2, 6 ],
          8: [ 2, 6 ],
          9: [ 2, 6 ],
          10: [ 2, 6 ],
          11: [ 2, 6 ],
          12: [ 2, 6 ],
          13: [ 2, 6 ],
          14: [ 2, 6 ],
          15: [ 2, 6 ],
          16: [ 1, 16 ],
          18: [ 2, 6 ]
        }, {
          5: [ 2, 7 ],
          6: [ 2, 7 ],
          7: [ 2, 7 ],
          8: [ 2, 7 ],
          9: [ 2, 7 ],
          10: [ 2, 7 ],
          11: [ 2, 7 ],
          12: [ 2, 7 ],
          13: [ 2, 7 ],
          14: [ 2, 7 ],
          15: [ 2, 7 ],
          16: [ 1, 16 ],
          18: [ 2, 7 ]
        }, {
          5: [ 2, 8 ],
          6: [ 2, 8 ],
          7: [ 2, 8 ],
          8: [ 2, 8 ],
          9: [ 2, 8 ],
          10: [ 2, 8 ],
          11: [ 2, 8 ],
          12: [ 2, 8 ],
          13: [ 2, 8 ],
          14: [ 2, 8 ],
          15: [ 2, 8 ],
          16: [ 1, 16 ],
          18: [ 2, 8 ]
        }, {
          5: [ 2, 9 ],
          6: [ 2, 9 ],
          7: [ 2, 9 ],
          8: [ 2, 9 ],
          9: [ 2, 9 ],
          10: [ 2, 9 ],
          11: [ 2, 9 ],
          12: [ 2, 9 ],
          13: [ 2, 9 ],
          14: [ 2, 9 ],
          15: [ 2, 9 ],
          16: [ 1, 16 ],
          18: [ 2, 9 ]
        }, {
          5: [ 2, 10 ],
          6: [ 2, 10 ],
          7: [ 2, 10 ],
          8: [ 2, 10 ],
          9: [ 2, 10 ],
          10: [ 2, 10 ],
          11: [ 2, 10 ],
          12: [ 2, 10 ],
          13: [ 2, 10 ],
          14: [ 2, 10 ],
          15: [ 2, 10 ],
          16: [ 1, 16 ],
          18: [ 2, 10 ]
        }, {
          5: [ 2, 11 ],
          6: [ 2, 11 ],
          7: [ 2, 11 ],
          8: [ 2, 11 ],
          9: [ 2, 11 ],
          10: [ 2, 11 ],
          11: [ 2, 11 ],
          12: [ 2, 11 ],
          13: [ 2, 11 ],
          14: [ 2, 11 ],
          15: [ 2, 11 ],
          16: [ 2, 11 ],
          18: [ 2, 11 ]
        }, {
          5: [ 2, 12 ],
          6: [ 2, 12 ],
          7: [ 2, 12 ],
          8: [ 2, 12 ],
          9: [ 2, 12 ],
          10: [ 2, 12 ],
          11: [ 2, 12 ],
          12: [ 2, 12 ],
          13: [ 2, 12 ],
          14: [ 2, 12 ],
          15: [ 2, 12 ],
          16: [ 2, 12 ],
          18: [ 2, 12 ]
        }, {
          4: 30,
          17: [ 1, 3 ],
          19: [ 1, 4 ],
          20: [ 1, 5 ]
        }, {
          5: [ 2, 2 ],
          6: [ 1, 7 ],
          7: [ 2, 2 ],
          8: [ 1, 8 ],
          9: [ 1, 9 ],
          10: [ 1, 10 ],
          11: [ 1, 11 ],
          12: [ 1, 12 ],
          13: [ 1, 13 ],
          14: [ 1, 14 ],
          15: [ 1, 15 ],
          16: [ 1, 16 ],
          18: [ 2, 2 ]
        } ],
        defaultActions: {
          6: [ 2, 1 ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [ 0 ], vstack = [ null ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== "number") {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null) symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error: if (typeof action === "undefined" || !action.length || !action[0]) {
              if (!recovering) {
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                  expected.push("'" + this.terminals_[p] + "'");
                }
                var errStr = "";
                if (this.lexer.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + this.terminals_[symbol] + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {
                  text: this.lexer.match,
                  token: this.terminals_[symbol] || symbol,
                  line: this.lexer.yylineno,
                  loc: yyloc,
                  expected: expected
                });
              }
              if (recovering == 3) {
                if (symbol == EOF) {
                  throw new Error(errStr || "Parsing halted.");
                }
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                symbol = lex();
              }
              while (1) {
                if (TERROR.toString() in table[state]) {
                  break;
                }
                if (state == 0) {
                  throw new Error(errStr || "Parsing halted.");
                }
                popStack(1);
                state = stack[stack.length - 1];
              }
              preErrorSymbol = symbol;
              symbol = TERROR;
              state = stack[stack.length - 1];
              action = table[state] && table[state][TERROR];
              recovering = 3;
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
            }
            switch (action[0]) {
             case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0) recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;

             case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

             case 3:
              return true;
            }
          }
          return true;
        }
      };
      var lexer = function() {
        var lexer = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parseError) {
              this.yy.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          setInput: function(input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = [ "INITIAL" ];
            this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0
            };
            return this;
          },
          input: function() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/\n/);
            if (lines) this.yylineno++;
            this._input = this._input.slice(1);
            return ch;
          },
          unput: function(ch) {
            this._input = ch + this._input;
            return this;
          },
          more: function() {
            this._more = true;
            return this;
          },
          pastInput: function() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          upcomingInput: function() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          showPosition: function() {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
          },
          next: function() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input) this.done = true;
            var token, match, col, lines;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
              match = this._input.match(this.rules[rules[i]]);
              if (match) {
                lines = match[0].match(/\n.*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                this._more = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                if (token) return token; else return;
              }
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
              });
            }
          },
          lex: function lex() {
            var r = this.next();
            if (typeof r !== "undefined") {
              return r;
            } else {
              return this.lex();
            }
          },
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          popState: function popState() {
            return this.conditionStack.pop();
          },
          _currentRules: function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          },
          topState: function() {
            return this.conditionStack[this.conditionStack.length - 2];
          },
          pushState: function begin(condition) {
            this.begin(condition);
          }
        };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
           case 0:
            break;

           case 1:
            return 20;
            break;

           case 2:
            return 19;
            break;

           case 3:
            return 8;
            break;

           case 4:
            return 9;
            break;

           case 5:
            return 6;
            break;

           case 6:
            return 7;
            break;

           case 7:
            return 11;
            break;

           case 8:
            return 13;
            break;

           case 9:
            return 10;
            break;

           case 10:
            return 12;
            break;

           case 11:
            return 14;
            break;

           case 12:
            return 15;
            break;

           case 13:
            return 16;
            break;

           case 14:
            return 17;
            break;

           case 15:
            return 18;
            break;

           case 16:
            return 5;
            break;

           case 17:
            return "INVALID";
            break;
          }
        };
        lexer.rules = [ /^\s+/, /^[0-9]+(\.[0-9]+)?\b/, /^n\b/, /^\|\|/, /^&&/, /^\?/, /^:/, /^<=/, /^>=/, /^</, /^>/, /^!=/, /^==/, /^%/, /^\(/, /^\)/, /^$/, /^./ ];
        lexer.conditions = {
          INITIAL: {
            rules: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ],
            inclusive: true
          }
        };
        return lexer;
      }();
      parser.lexer = lexer;
      return parser;
    }();
    if (true) {
      if (typeof module !== "undefined" && module.exports) {
        exports = module.exports = Jed;
      }
      exports.Jed = Jed;
    } else {
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Jed;
        });
      }
      root["Jed"] = Jed;
    }
  })(this);
}, function(module, exports, __webpack_require__) {
  (function(_) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    var slice = [].slice;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var contractRestServiceLink, contractServiceLink, getAnalyticsCategoryLocalizedName, isCard, isMainCard, reportLink;
      contractServiceLink = function() {
        var contractField, fieldParts, serviceId;
        serviceId = arguments[0], fieldParts = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        console.assert(!_.isEmpty(serviceId), "serviceId is required");
        console.assert(!_.isEmpty(contractField = fieldParts[0]), "contractField is required");
        return function(contract) {
          return serviceId + "?CONTRACT_PROPERTY_" + contractField + "=" + contract.id;
        };
      };
      contractRestServiceLink = function(serviceId, sourceField) {
        console.assert(!_.isEmpty(serviceId), "serviceId is required");
        return function(contract) {
          if (!sourceField) {
            return serviceId;
          }
          sourceField = sourceField.replace(/\./g, "$");
          return serviceId + "?" + sourceField + ".id=" + contract.id;
        };
      };
      reportLink = function(reportId) {
        return {
          reportId: reportId
        };
      };
      isCard = function(contract) {
        return contract.get("type") === "card";
      };
      isMainCard = function(contract) {
        return isCard(contract) && !contract.get("card.primaryCardId");
      };
      getAnalyticsCategoryLocalizedName = function(categoryName) {
        var categories, i, j, key, len, ref;
        categoryName = categoryName || "";
        categories = window.OW.historyAnalyticsConfig.categories;
        ref = Object.keys(categories);
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          key = ref[i];
          if (key.toLowerCase() === categoryName.toLowerCase()) {
            return categories[key].name;
          }
        }
        return categoryName;
      };
      return {
        contractRestServiceLink: contractRestServiceLink,
        contractServiceLink: contractServiceLink,
        reportLink: reportLink,
        isCard: isCard,
        isMainCard: isMainCard,
        getAnalyticsCategoryLocalizedName: getAnalyticsCategoryLocalizedName
      };
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  (function($, _) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
      var Globalize, _getValueToCompare, settings, validationMethods;
      settings = __webpack_require__(2);
      __webpack_require__(52);
      Globalize = __webpack_require__(3);
      validationMethods = __webpack_require__(53);
      $.validator.addClassRules({
        amount: {
          money: true
        },
        phone: {
          phone: true
        },
        cvv: {
          digits: true,
          minlength: 3,
          maxlength: 5
        },
        PHONE10: {
          PHONE10: true
        },
        PHONERU: {
          PHONERU: true
        },
        PHONE_E164_RU: {
          PHONERU: true
        },
        PHONEUA: {
          PHONEUA: true
        },
        PHONEBE: {
          PHONEBE: true
        },
        SYMBOL30: {
          SYMBOL30: true
        },
        cardNumber: {
          creditcard: true
        },
        IIN: {
          IIN: true
        },
        money: {
          money: true
        },
        licenseAgreement: {
          license: true
        },
        username: {
          username: true
        },
        INN: {
          INN: true
        },
        INN10: {
          INN10: true
        },
        expiryDate: {
          expiryDate: true
        },
        birthDate: {
          datePastNonIso: true
        },
        embossingName: {
          embossingName: true
        },
        INT: {
          integer: true
        },
        NONNEGATIVE_INT: {
          amountOrZero: true,
          integer: true
        },
        NUMBER: {
          number: true
        },
        NONNEGATIVE_NUMBER: {
          positiveAmount: true
        }
      });
      _.extend($.validator.messages, {
        required: t("This field is required"),
        number: t("Please enter a valid number"),
        email: t("Invalid e-mail format"),
        creditcard: t("Invalid card number"),
        digits: t("Please enter only digits"),
        cardNumber: t("Invalid card number"),
        equalTo: t("Confirmation does not match original value"),
        notEqualTo: t("Value should not equal to {0}"),
        minlength: t("Please enter at least {0} characters"),
        maxlength: t("Please enter no more than {0} characters"),
        range: t("Please enter a value between {0} and {1}"),
        dateISO: t("Please enter a valid date (YYYY-MM-DD)"),
        modulus: t("Amount should be divided to {0} without remainder")
      });
      $.validator.addMethod("exactLength", function(value, element, param) {
        var length;
        length = $.isArray(value) ? value.length : this.getLength($.trim(value), element);
        return this.optional(element) || length === param;
      }, function(_this) {
        return function(count) {
          return tn("Please enter %(num)s character", "Please enter %(num)s characters", count);
        };
      }(this));
      $.validator.addMethod("money", function(value, element, param) {
        return this.optional(element) || validationMethods.money(value);
      }, t("Please enter a valid amount"));
      $.validator.addMethod("phone", function(value, element, param) {
        return this.optional(element) || validationMethods.phone(value);
      }, t("Phone number is invalid"));
      $.validator.addMethod("PHONE10", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.PHONE10(val);
      }, t("Enter 10 digit phone number"));
      $.validator.addMethod("PHONERU", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.PHONERU(val);
      }, t("Enter 11 digit phone number which starts with +7"));
      $.validator.addMethod("PHONEUA", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.PHONEUA(val);
      }, t("Enter 12 digit phone number which starts with +38"));
      $.validator.addMethod("PHONEBE", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.PHONEBE(val);
      }, t("Enter 12 digit phone number which starts with +32"));
      $.validator.addMethod("SYMBOL30", function(value, element, param) {
        if (this.optional(element)) {
          return true;
        }
        return validationMethods.SYMBOL30(value);
      }, t("Please enter no more than 30 Latin characters"));
      $.validator.addMethod("INN", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.INN(val);
      }, t("Enter 12 digit INN"));
      $.validator.addMethod("INN10", function(value, element, param) {
        var ref, val;
        if (this.optional(element)) {
          return true;
        }
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return validationMethods.INN10(val);
      }, t("Enter 10 digit INN"));
      $.validator.addMethod("amountOrZero", function(value, element, param) {
        return this.optional(element) || validationMethods.amountOrZero(value);
      }, t("Amount is invalid"));
      $.validator.addMethod("positiveAmount", function(value, element) {
        return this.optional(element) || validationMethods.positiveAmount(value);
      }, t("Amount should be greater than zero"));
      $.validator.addMethod("maxAmount", function(value, element, param) {
        return this.optional(element) || validationMethods.maxAmount(parseFloat(value), parseFloat(String(param)));
      }, t("Please enter amount no larger than {0}"));
      $.validator.addMethod("passwordChars", function(value, element, param) {
        return validationMethods.passwordChars(value, param);
      }, t("Password contains invalid characters"));
      $.validator.addMethod("passwordRegex", function(value, element, param) {
        return this.optional(element) || validationMethods.passwordRegex(value, param);
      }, t("Password does not comply to security policy"));
      $.validator.addMethod("postalCode", function(value, element, param) {
        if (this.optional(element)) {
          return true;
        }
        return validationMethods.postalCode(value);
      }, t("Invalid postal code"));
      $.validator.addMethod("number", function(value, element, param) {
        return this.optional(element) || validationMethods.number(value);
      }, $.validator.messages.number);
      $.validator.addMethod("IIN", function(value, element, param) {
        return validationMethods.IIN(value);
      }, t("IIN number is invalid"));
      $.validator.addMethod("license", function(value, element, param) {
        return element.checked;
      }, t("You should accept license agreement"));
      $.validator.addMethod("alphanumeric", function(value, element, param) {
        return this.optional(element) || validationMethods.alphanumeric(value);
      }, t("Only latin characters and digits are allowed"));
      $.validator.addMethod("username", function(value, element, param) {
        return this.optional(element) || validationMethods.username(value);
      }, t("Username does not comply to security policy"));
      $.validator.addMethod("uniqueTemplateName", function(value, element, param) {
        var filterPredicate, id, rPayments, result, templates, thPayments;
        id = param[0], templates = param[1], rPayments = param[2], thPayments = param[3];
        value = value.toLowerCase();
        filterPredicate = function(t) {
          if (t.id === id) {
            return false;
          }
          return t.get("name").toLowerCase() === value.trim();
        };
        result = templates.filter(filterPredicate).length === 0;
        result = result && rPayments.filter(filterPredicate).length === 0;
        result = result && thPayments.filter(filterPredicate).length === 0;
        return result;
      }, t("There's template with this name already"));
      $.validator.addMethod("validPeriodDay", function(value, element, param) {
        var $target;
        if (this.optional(element)) {
          return true;
        }
        $target = $(param);
        switch ($target.val()) {
         case "MONTHLY":
          return value >= 1 && value <= 31;

         case "WEEKLY":
          return value >= 1 && value <= 7;

         default:
          return console.assert(false, "Can not validate period input: unknown value: ", $target.val());
        }
      }, function(param) {
        var $target, params, theregex;
        $target = $(param);
        if ($target.val() === "MONTHLY") {
          params = [ 1, 31 ];
        } else if ($target.val() === "WEEKLY") {
          params = [ 1, 7 ];
        }
        theregex = /\$?\{(\d+)\}/g;
        return $.validator.format($.validator.messages["range"].replace(theregex, "{$1}"), params);
      });
      $.validator.addMethod("uniqueCollectionItem", function(value, element, param) {
        var ref, val;
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return this.optional(element) || validationMethods.uniqueCollectionItem(val, param);
      }, t("Item already exists"));
      $.validator.addMethod("expiryDate", function(value, element, param) {
        return this.optional(element) || validationMethods.expiryDate(value);
      }, t("Entered expiration date is not valid"));
      $.validator.addMethod("datePast", function(value, element, param) {
        return this.optional(element) || validationMethods.datePast(value);
      }, t("Date must be in the past"));
      $.validator.addMethod("datePastNonIso", function(value, element, param) {
        return this.optional(element) || validationMethods.datePastNonIso(value);
      }, t("Date must be in the past"));
      $.validator.addMethod("dateFuture", function(value, element, param) {
        return this.optional(element) || validationMethods.dateFuture(value);
      }, t("Date must be in the future"));
      $.validator.addMethod("embossingName", function(value, element, param) {
        return this.optional(element) || validationMethods.embossingName(value);
      }, t("This field must contain only letters, dots, apostrophes, dashes and spaces"));
      _getValueToCompare = function(rawValue) {
        var $otherField, parsed, ref;
        parsed = Globalize.parseFloat(rawValue);
        if (!_.isNaN(parsed)) {
          return parsed;
        }
        $otherField = $("[name='" + rawValue + "']");
        if ($otherField.length === 0) {
          console.warn("Field [name=" + rawValue + "] does not exist, treat value as NaN");
          return 0 / 0;
        }
        return Globalize.parseFloat(((ref = $otherField.data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || $otherField.val());
      };
      $.validator.addMethod("greaterOrEqual", function(value, element, param) {
        var otherValue, ref;
        value = Globalize.parseFloat(((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value);
        otherValue = _getValueToCompare(param);
        return this.optional(element) || validationMethods.greaterOrEqual(value, otherValue);
      }, function(param) {
        return t("Value should be greater than or equal to %(value)s", {
          value: _getValueToCompare(param)
        });
      });
      $.validator.addMethod("lessOrEqual", function(value, element, param) {
        var otherValue, ref;
        value = Globalize.parseFloat(((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value);
        otherValue = _getValueToCompare(param);
        return this.optional(element) || validationMethods.lessOrEqual(value, otherValue);
      }, function(param) {
        return t("Value should be less than or equal to %(value)s", {
          value: _getValueToCompare(param)
        });
      });
      $.validator.addMethod("integer", function(value, element, param) {
        return this.optional(element) || validationMethods.integer(value);
      }, t("Entered value should be an integer value"));
      $.validator.addMethod("pattern", function(value, element, param) {
        var ref, val;
        val = ((ref = $(element).data("mask")) != null ? typeof ref.getCleanVal === "function" ? ref.getCleanVal() : void 0 : void 0) || value;
        return this.optional(element) || validationMethods.pattern(val, param);
      }, function(param) {
        console.debug("Entered value is in wrong format. Expected: " + param);
        return t("Entered value does not meet format requirements");
      });
      $.validator.addMethod("modulus", function(value, element, param) {
        return this.optional(element) || validationMethods.modulus(value, param);
      }, function(param) {
        return t("Amount should be divided to %(value)s without remainder", {
          value: param
        });
      });
      $.validator.addMethod("notEqualTo", function(value, element, param) {
        var target;
        target = $(param);
        if (this.settings.onfocusout) {
          target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
            return $(element).valid();
          });
        }
        return validationMethods.notEqualTo(value, target.val());
      }, function(param) {
        var labelValue;
        labelValue = $(param).parents(".ui-field-contain").find(">label:not(.error)").text();
        return $.validator.format(t("Value should not equal to {0}"), labelValue);
      });
      $.validator.addMethod("personalizedDeviceName", function(value, element, param) {
        return validationMethods.personalizedDeviceName(value);
      }, t('Name can not contain characters - ".,:;"'));
      return $.validator.setDefaults({
        highlight: function(element, errorClass, validClass) {
          if (element.type === "radio") {
            return this.findByName(element.name).parent().addClass(errorClass).removeClass(validClass);
          } else {
            return $(element).closest(".ui-field-contain").addClass(errorClass).removeClass(validClass);
          }
        },
        unhighlight: function(element, errorClass, validClass) {
          if (element.type === "radio") {
            return this.findByName(element.name).parent().removeClass(errorClass).addClass(validClass);
          } else {
            return $(element).closest(".ui-field-contain").removeClass(errorClass).addClass(validClass);
          }
        }
      });
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }).call(exports, __webpack_require__(1), __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
  /*!
 * jQuery Validation Plugin v1.13.2-pre
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2015 Jrn Zaefferer
 * Released under the MIT license
 */
  (function(factory) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
      __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
      __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
      factory(jQuery);
    }
  })(function($) {
    $.extend($.fn, {
      validate: function(options) {
        if (!this.length) {
          if (options && options.debug && window.console) {
            console.warn("Nothing selected, can't validate, returning nothing.");
          }
          return;
        }
        var validator = $.data(this[0], "validator");
        if (validator) {
          return validator;
        }
        this.attr("novalidate", "novalidate");
        validator = new $.validator(options, this[0]);
        $.data(this[0], "validator", validator);
        if (validator.settings.onsubmit) {
          this.validateDelegate(":submit", "click", function(event) {
            if (validator.settings.submitHandler) {
              validator.submitButton = event.target;
            }
            if ($(event.target).hasClass("cancel")) {
              validator.cancelSubmit = true;
            }
            if ($(event.target).attr("formnovalidate") !== undefined) {
              validator.cancelSubmit = true;
            }
          });
          this.submit(function(event) {
            if (validator.settings.debug) {
              event.preventDefault();
            }
            function handle() {
              var hidden, result;
              if (validator.settings.submitHandler) {
                if (validator.submitButton) {
                  hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm);
                }
                result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
                if (validator.submitButton) {
                  hidden.remove();
                }
                if (result !== undefined) {
                  return result;
                }
                return false;
              }
              return true;
            }
            if (validator.cancelSubmit) {
              validator.cancelSubmit = false;
              return handle();
            }
            if (validator.form()) {
              if (validator.pendingRequest) {
                validator.formSubmitted = true;
                return false;
              }
              return handle();
            } else {
              validator.focusInvalid();
              return false;
            }
          });
        }
        return validator;
      },
      valid: function() {
        var valid, validator, errorList;
        if ($(this[0]).is("form")) {
          valid = this.validate().form();
        } else {
          errorList = [];
          valid = true;
          validator = $(this[0].form).validate();
          this.each(function() {
            valid = validator.element(this) && valid;
            errorList = errorList.concat(validator.errorList);
          });
          validator.errorList = errorList;
        }
        return valid;
      },
      removeAttrs: function(attributes) {
        var result = {}, $element = this;
        $.each(attributes.split(/\s/), function(index, value) {
          result[value] = $element.attr(value);
          $element.removeAttr(value);
        });
        return result;
      },
      rules: function(command, argument) {
        var element = this[0], settings, staticRules, existingRules, data, param, filtered;
        if (command) {
          settings = $.data(element.form, "validator").settings;
          staticRules = settings.rules;
          existingRules = $.validator.staticRules(element);
          switch (command) {
           case "add":
            $.extend(existingRules, $.validator.normalizeRule(argument));
            delete existingRules.messages;
            staticRules[element.name] = existingRules;
            if (argument.messages) {
              settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
            }
            break;

           case "remove":
            if (!argument) {
              delete staticRules[element.name];
              return existingRules;
            }
            filtered = {};
            $.each(argument.split(/\s/), function(index, method) {
              filtered[method] = existingRules[method];
              delete existingRules[method];
              if (method === "required") {
                $(element).removeAttr("aria-required");
              }
            });
            return filtered;
          }
        }
        data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element);
        if (data.required) {
          param = data.required;
          delete data.required;
          data = $.extend({
            required: param
          }, data);
          $(element).attr("aria-required", "true");
        }
        if (data.remote) {
          param = data.remote;
          delete data.remote;
          data = $.extend(data, {
            remote: param
          });
        }
        return data;
      }
    });
    $.extend($.expr.pseudos, {
      blank: function(a) {
        return !$.trim("" + $(a).val());
      },
      filled: function(a) {
        return !!$.trim("" + $(a).val());
      },
      unchecked: function(a) {
        return !$(a).prop("checked");
      }
    });
    $.validator = function(options, form) {
      this.settings = $.extend(true, {}, $.validator.defaults, options);
      this.currentForm = form;
      this.init();
    };
    $.validator.format = function(source, params) {
      if (arguments.length === 1) {
        return function() {
          var args = $.makeArray(arguments);
          args.unshift(source);
          return $.validator.format.apply(this, args);
        };
      }
      if (arguments.length > 2 && params.constructor !== Array) {
        params = $.makeArray(arguments).slice(1);
      }
      if (params.constructor !== Array) {
        params = [ params ];
      }
      $.each(params, function(i, n) {
        source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function() {
          return n;
        });
      });
      return source;
    };
    $.extend($.validator, {
      defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: "error",
        validClass: "valid",
        errorElement: "label",
        focusCleanup: false,
        focusInvalid: true,
        errorContainer: $([]),
        errorLabelContainer: $([]),
        onsubmit: true,
        ignore: ":hidden",
        ignoreTitle: false,
        onfocusin: function(element) {
          this.lastActive = element;
          if (this.settings.focusCleanup) {
            if (this.settings.unhighlight) {
              this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
            }
            this.hideThese(this.errorsFor(element));
          }
        },
        onfocusout: function(element) {
          if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
            this.element(element);
          }
        },
        onkeyup: function(element, event) {
          if (event.which === 9 && this.elementValue(element) === "") {
            return;
          } else if (element.name in this.submitted || element === this.lastElement) {
            this.element(element);
          }
        },
        onclick: function(element) {
          if (element.name in this.submitted) {
            this.element(element);
          } else if (element.parentNode.name in this.submitted) {
            this.element(element.parentNode);
          }
        },
        highlight: function(element, errorClass, validClass) {
          if (element.type === "radio") {
            this.findByName(element.name).addClass(errorClass).removeClass(validClass);
          } else {
            $(element).addClass(errorClass).removeClass(validClass);
          }
        },
        unhighlight: function(element, errorClass, validClass) {
          if (element.type === "radio") {
            this.findByName(element.name).removeClass(errorClass).addClass(validClass);
          } else {
            $(element).removeClass(errorClass).addClass(validClass);
          }
        }
      },
      setDefaults: function(settings) {
        $.extend($.validator.defaults, settings);
      },
      messages: {
        required: "This field is required.",
        remote: "Please fix this field.",
        email: "Please enter a valid email address.",
        url: "Please enter a valid URL.",
        date: "Please enter a valid date.",
        dateISO: "Please enter a valid date ( ISO ).",
        number: "Please enter a valid number.",
        digits: "Please enter only digits.",
        creditcard: "Please enter a valid credit card number.",
        equalTo: "Please enter the same value again.",
        maxlength: $.validator.format("Please enter no more than {0} characters."),
        minlength: $.validator.format("Please enter at least {0} characters."),
        rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
        range: $.validator.format("Please enter a value between {0} and {1}."),
        max: $.validator.format("Please enter a value less than or equal to {0}."),
        min: $.validator.format("Please enter a value greater than or equal to {0}.")
      },
      autoCreateRanges: false,
      prototype: {
        init: function() {
          this.labelContainer = $(this.settings.errorLabelContainer);
          this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
          this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
          this.submitted = {};
          this.valueCache = {};
          this.pendingRequest = 0;
          this.pending = {};
          this.invalid = {};
          this.reset();
          var groups = this.groups = {}, rules;
          $.each(this.settings.groups, function(key, value) {
            if (typeof value === "string") {
              value = value.split(/\s/);
            }
            $.each(value, function(index, name) {
              groups[name] = key;
            });
          });
          rules = this.settings.rules;
          $.each(rules, function(key, value) {
            rules[key] = $.validator.normalizeRule(value);
          });
          function delegate(event) {
            var validator = $.data(this[0].form, "validator"), eventType = "on" + event.type.replace(/^validate/, ""), settings = validator.settings;
            if (settings[eventType] && !this.is(settings.ignore)) {
              settings[eventType].call(validator, this[0], event);
            }
          }
          $(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, " + "[type='number'], [type='search'] ,[type='tel'], [type='url'], " + "[type='email'], [type='datetime'], [type='date'], [type='month'], " + "[type='week'], [type='time'], [type='datetime-local'], " + "[type='range'], [type='color'], [type='radio'], [type='checkbox']", "focusin focusout keyup", delegate).validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", delegate);
          if (this.settings.invalidHandler) {
            $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
          }
          $(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true");
        },
        form: function() {
          this.checkForm();
          $.extend(this.submitted, this.errorMap);
          this.invalid = $.extend({}, this.errorMap);
          if (!this.valid()) {
            $(this.currentForm).triggerHandler("invalid-form", [ this ]);
          }
          this.showErrors();
          return this.valid();
        },
        checkForm: function() {
          this.prepareForm();
          for (var i = 0, elements = this.currentElements = this.elements(); elements[i]; i++) {
            this.check(elements[i]);
          }
          return this.valid();
        },
        element: function(element) {
          var cleanElement = this.clean(element), checkElement = this.validationTargetFor(cleanElement), result = true;
          this.lastElement = checkElement;
          if (checkElement === undefined) {
            delete this.invalid[cleanElement.name];
          } else {
            this.prepareElement(checkElement);
            this.currentElements = $(checkElement);
            result = this.check(checkElement) !== false;
            if (result) {
              delete this.invalid[checkElement.name];
            } else {
              this.invalid[checkElement.name] = true;
            }
          }
          $(element).attr("aria-invalid", !result);
          if (!this.numberOfInvalids()) {
            this.toHide = this.toHide.add(this.containers);
          }
          this.showErrors();
          return result;
        },
        showErrors: function(errors) {
          if (errors) {
            $.extend(this.errorMap, errors);
            this.errorList = [];
            for (var name in errors) {
              this.errorList.push({
                message: errors[name],
                element: this.findByName(name)[0]
              });
            }
            this.successList = $.grep(this.successList, function(element) {
              return !(element.name in errors);
            });
          }
          if (this.settings.showErrors) {
            this.settings.showErrors.call(this, this.errorMap, this.errorList);
          } else {
            this.defaultShowErrors();
          }
        },
        resetForm: function() {
          if ($.fn.resetForm) {
            $(this.currentForm).resetForm();
          }
          this.submitted = {};
          this.lastElement = null;
          this.prepareForm();
          this.hideErrors();
          var i, elements = this.elements().removeData("previousValue").removeAttr("aria-invalid");
          if (this.settings.unhighlight) {
            for (i = 0; elements[i]; i++) {
              this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, "");
            }
          } else {
            elements.removeClass(this.settings.errorClass);
          }
        },
        numberOfInvalids: function() {
          return this.objectLength(this.invalid);
        },
        objectLength: function(obj) {
          var count = 0, i;
          for (i in obj) {
            count++;
          }
          return count;
        },
        hideErrors: function() {
          this.hideThese(this.toHide);
        },
        hideThese: function(errors) {
          errors.not(this.containers).text("");
          this.addWrapper(errors).hide();
        },
        valid: function() {
          return this.size() === 0;
        },
        size: function() {
          return this.errorList.length;
        },
        focusInvalid: function() {
          if (this.settings.focusInvalid) {
            try {
              $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin");
            } catch (e) {}
          }
        },
        findLastActive: function() {
          var lastActive = this.lastActive;
          return lastActive && $.grep(this.errorList, function(n) {
            return n.element.name === lastActive.name;
          }).length === 1 && lastActive;
        },
        elements: function() {
          var validator = this, rulesCache = {};
          return $(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function() {
            if (!this.name && validator.settings.debug && window.console) {
              console.error("%o has no name assigned", this);
            }
            if (this.name in rulesCache || !validator.objectLength($(this).rules())) {
              return false;
            }
            rulesCache[this.name] = true;
            return true;
          });
        },
        clean: function(selector) {
          return $(selector)[0];
        },
        errors: function() {
          var errorClass = this.settings.errorClass.split(" ").join(".");
          return $(this.settings.errorElement + "." + errorClass, this.errorContext);
        },
        reset: function() {
          this.successList = [];
          this.errorList = [];
          this.errorMap = {};
          this.toShow = $([]);
          this.toHide = $([]);
          this.currentElements = $([]);
        },
        prepareForm: function() {
          this.reset();
          this.toHide = this.errors().add(this.containers);
        },
        prepareElement: function(element) {
          this.reset();
          this.toHide = this.errorsFor(element);
        },
        elementValue: function(element) {
          var val, $element = $(element), type = element.type;
          if (type === "radio" || type === "checkbox") {
            return this.findByName(element.name).filter(":checked").val();
          } else if (type === "number" && typeof element.validity !== "undefined") {
            return element.validity.badInput ? false : $element.val();
          }
          val = $element.val();
          if (typeof val === "string") {
            return val.replace(/\r/g, "");
          }
          return val;
        },
        check: function(element) {
          element = this.validationTargetFor(this.clean(element));
          var rules = $(element).rules(), rulesCount = $.map(rules, function(n, i) {
            return i;
          }).length, dependencyMismatch = false, val = this.elementValue(element), result, method, rule;
          for (method in rules) {
            rule = {
              method: method,
              parameters: rules[method]
            };
            try {
              result = $.validator.methods[method].call(this, val, element, rule.parameters);
              if (result === "dependency-mismatch" && rulesCount === 1) {
                dependencyMismatch = true;
                continue;
              }
              dependencyMismatch = false;
              if (result === "pending") {
                this.toHide = this.toHide.not(this.errorsFor(element));
                return;
              }
              if (!result) {
                this.formatAndAdd(element, rule);
                return false;
              }
            } catch (e) {
              if (this.settings.debug && window.console) {
                console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
              }
              if (e instanceof TypeError) {
                e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
              }
              throw e;
            }
          }
          if (dependencyMismatch) {
            return;
          }
          if (this.objectLength(rules)) {
            this.successList.push(element);
          }
          return true;
        },
        customDataMessage: function(element, method) {
          return $(element).data("msg" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data("msg");
        },
        customMessage: function(name, method) {
          var m = this.settings.messages[name];
          return m && (m.constructor === String ? m : m[method]);
        },
        findDefined: function() {
          for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) {
              return arguments[i];
            }
          }
          return undefined;
        },
        defaultMessage: function(element, method) {
          return this.findDefined(this.customMessage(element.name, method), this.customDataMessage(element, method), !this.settings.ignoreTitle && element.title || undefined, $.validator.messages[method], "<strong>Warning: No message defined for " + element.name + "</strong>");
        },
        formatAndAdd: function(element, rule) {
          var message = this.defaultMessage(element, rule.method), theregex = /\$?\{(\d+)\}/g;
          if (typeof message === "function") {
            message = message.call(this, rule.parameters, element);
          } else if (theregex.test(message)) {
            message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
          }
          this.errorList.push({
            message: message,
            element: element,
            method: rule.method
          });
          this.errorMap[element.name] = message;
          this.submitted[element.name] = message;
        },
        addWrapper: function(toToggle) {
          if (this.settings.wrapper) {
            toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
          }
          return toToggle;
        },
        defaultShowErrors: function() {
          var i, elements, error;
          for (i = 0; this.errorList[i]; i++) {
            error = this.errorList[i];
            if (this.settings.highlight) {
              this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
            }
            this.showLabel(error.element, error.message);
          }
          if (this.errorList.length) {
            this.toShow = this.toShow.add(this.containers);
          }
          if (this.settings.success) {
            for (i = 0; this.successList[i]; i++) {
              this.showLabel(this.successList[i]);
            }
          }
          if (this.settings.unhighlight) {
            for (i = 0, elements = this.validElements(); elements[i]; i++) {
              this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
            }
          }
          this.toHide = this.toHide.not(this.toShow);
          this.hideErrors();
          this.addWrapper(this.toShow).show();
        },
        validElements: function() {
          return this.currentElements.not(this.invalidElements());
        },
        invalidElements: function() {
          return $(this.errorList).map(function() {
            return this.element;
          });
        },
        showLabel: function(element, message) {
          var place, group, errorID, error = this.errorsFor(element), elementID = this.idOrName(element), describedBy = $(element).attr("aria-describedby");
          if (error.length) {
            error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
            error.html(message);
          } else {
            error = $("<" + this.settings.errorElement + ">").attr("id", elementID + "-error").addClass(this.settings.errorClass).html(message || "");
            place = error;
            if (this.settings.wrapper) {
              place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
            }
            if (this.labelContainer.length) {
              this.labelContainer.append(place);
            } else if (this.settings.errorPlacement) {
              this.settings.errorPlacement(place, $(element));
            } else {
              place.insertAfter(element);
            }
            if (error.is("label")) {
              error.attr("for", elementID);
            } else if (error.parents("label[for='" + elementID + "']").length === 0) {
              errorID = error.attr("id").replace(/(:|\.|\[|\]|\$)/g, "\\$1");
              if (!describedBy) {
                describedBy = errorID;
              } else if (!describedBy.match(new RegExp("\\b" + errorID + "\\b"))) {
                describedBy += " " + errorID;
              }
              $(element).attr("aria-describedby", describedBy);
              group = this.groups[element.name];
              if (group) {
                $.each(this.groups, function(name, testgroup) {
                  if (testgroup === group) {
                    $("[name='" + name + "']", this.currentForm).attr("aria-describedby", error.attr("id"));
                  }
                });
              }
            }
          }
          if (!message && this.settings.success) {
            error.text("");
            if (typeof this.settings.success === "string") {
              error.addClass(this.settings.success);
            } else {
              this.settings.success(error, element);
            }
          }
          this.toShow = this.toShow.add(error);
        },
        errorsFor: function(element) {
          var name = this.idOrName(element), describer = $(element).attr("aria-describedby"), selector = "label[for='" + name + "'], label[for='" + name + "'] *";
          if (describer) {
            selector = selector + ", #" + describer.replace(/\s+/g, ", #");
          }
          return this.errors().filter(selector);
        },
        idOrName: function(element) {
          return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
        },
        validationTargetFor: function(element) {
          if (this.checkable(element)) {
            element = this.findByName(element.name);
          }
          return $(element).not(this.settings.ignore)[0];
        },
        checkable: function(element) {
          return /radio|checkbox/i.test(element.type);
        },
        findByName: function(name) {
          return $(this.currentForm).find("[name='" + name + "']");
        },
        getLength: function(value, element) {
          switch (element.nodeName.toLowerCase()) {
           case "select":
            return $("option:selected", element).length;

           case "input":
            if (this.checkable(element)) {
              return this.findByName(element.name).filter(":checked").length;
            }
          }
          return value.length;
        },
        depend: function(param, element) {
          return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
        },
        dependTypes: {
          boolean: function(param) {
            return param;
          },
          string: function(param, element) {
            return !!$(param, element.form).length;
          },
          function: function(param, element) {
            return param(element);
          }
        },
        optional: function(element) {
          var val = this.elementValue(element);
          return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
        },
        startRequest: function(element) {
          if (!this.pending[element.name]) {
            this.pendingRequest++;
            this.pending[element.name] = true;
          }
        },
        stopRequest: function(element, valid) {
          this.pendingRequest--;
          if (this.pendingRequest < 0) {
            this.pendingRequest = 0;
          }
          delete this.pending[element.name];
          if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
            $(this.currentForm).submit();
            this.formSubmitted = false;
          } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
            $(this.currentForm).triggerHandler("invalid-form", [ this ]);
            this.formSubmitted = false;
          }
        },
        previousValue: function(element) {
          return $.data(element, "previousValue") || $.data(element, "previousValue", {
            old: null,
            valid: true,
            message: this.defaultMessage(element, "remote")
          });
        }
      },
      classRuleSettings: {
        required: {
          required: true
        },
        email: {
          email: true
        },
        url: {
          url: true
        },
        date: {
          date: true
        },
        dateISO: {
          dateISO: true
        },
        number: {
          number: true
        },
        digits: {
          digits: true
        },
        creditcard: {
          creditcard: true
        }
      },
      addClassRules: function(className, rules) {
        if (className.constructor === String) {
          this.classRuleSettings[className] = rules;
        } else {
          $.extend(this.classRuleSettings, className);
        }
      },
      classRules: function(element) {
        var rules = {}, classes = $(element).attr("class");
        if (classes) {
          $.each(classes.split(" "), function() {
            if (this in $.validator.classRuleSettings) {
              $.extend(rules, $.validator.classRuleSettings[this]);
            }
          });
        }
        return rules;
      },
      attributeRules: function(element) {
        var rules = {}, $element = $(element), type = element.getAttribute("type"), method, value;
        for (method in $.validator.methods) {
          if (method === "required") {
            value = element.getAttribute(method);
            if (value === "") {
              value = true;
            }
            value = !!value;
          } else {
            value = $element.attr(method);
          }
          if (/min|max/.test(method) && (type === null || /number|range|text/.test(type))) {
            value = Number(value);
          }
          if (value || value === 0) {
            rules[method] = value;
          } else if (type === method && type !== "range") {
            rules[method] = true;
          }
        }
        if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
          delete rules.maxlength;
        }
        return rules;
      },
      dataRules: function(element) {
        var method, value, rules = {}, $element = $(element);
        for (method in $.validator.methods) {
          value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
          if (value !== undefined) {
            rules[method] = value;
          }
        }
        return rules;
      },
      staticRules: function(element) {
        var rules = {}, validator = $.data(element.form, "validator");
        if (validator.settings.rules) {
          rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
        }
        return rules;
      },
      normalizeRules: function(rules, element) {
        $.each(rules, function(prop, val) {
          if (val === false) {
            delete rules[prop];
            return;
          }
          if (val.param || val.depends) {
            var keepRule = true;
            switch (typeof val.depends) {
             case "string":
              keepRule = !!$(val.depends, element.form).length;
              break;

             case "function":
              keepRule = val.depends.call(element, element);
              break;
            }
            if (keepRule) {
              rules[prop] = val.param !== undefined ? val.param : true;
            } else {
              delete rules[prop];
            }
          }
        });
        $.each(rules, function(rule, parameter) {
          rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
        });
        $.each([ "minlength", "maxlength" ], function() {
          if (rules[this]) {
            rules[this] = Number(rules[this]);
          }
        });
        $.each([ "rangelength", "range" ], function() {
          var parts;
          if (rules[this]) {
            if ($.isArray(rules[this])) {
              rules[this] = [ Number(rules[this][0]), Number(rules[this][1]) ];
            } else if (typeof rules[this] === "string") {
              parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
              rules[this] = [ Number(parts[0]), Number(parts[1]) ];
            }
          }
        });
        if ($.validator.autoCreateRanges) {
          if (rules.min != null && rules.max != null) {
            rules.range = [ rules.min, rules.max ];
            delete rules.min;
            delete rules.max;
          }
          if (rules.minlength != null && rules.maxlength != null) {
            rules.rangelength = [ rules.minlength, rules.maxlength ];
            delete rules.minlength;
            delete rules.maxlength;
          }
        }
        return rules;
      },
      normalizeRule: function(data) {
        if (typeof data === "string") {
          var transformed = {};
          $.each(data.split(/\s/), function() {
            transformed[this] = true;
          });
          data = transformed;
        }
        return data;
      },
      addMethod: function(name, method, message) {
        $.validator.methods[name] = method;
        $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
        if (method.length < 3) {
          $.validator.addClassRules(name, $.validator.normalizeRule(name));
        }
      },
      methods: {
        required: function(value, element, param) {
          if (!this.depend(param, element)) {
            return "dependency-mismatch";
          }
          if (element.nodeName.toLowerCase() === "select") {
            var val = $(element).val();
            return val && val.length > 0;
          }
          if (this.checkable(element)) {
            return this.getLength(value, element) > 0;
          }
          return $.trim(value).length > 0;
        },
        email: function(value, element) {
          return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
        },
        url: function(value, element) {
          return this.optional(element) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
        },
        date: function(value, element) {
          return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
        },
        dateISO: function(value, element) {
          return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
        },
        number: function(value, element) {
          return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
        },
        digits: function(value, element) {
          return this.optional(element) || /^\d+$/.test(value);
        },
        creditcard: function(value, element) {
          if (this.optional(element)) {
            return "dependency-mismatch";
          }
          if (/[^0-9 \-]+/.test(value)) {
            return false;
          }
          var nCheck = 0, nDigit = 0, bEven = false, n, cDigit;
          value = value.replace(/\D/g, "");
          if (value.length < 13 || value.length > 19) {
            return false;
          }
          for (n = value.length - 1; n >= 0; n--) {
            cDigit = value.charAt(n);
            nDigit = parseInt(cDigit, 10);
            if (bEven) {
              if ((nDigit *= 2) > 9) {
                nDigit -= 9;
              }
            }
            nCheck += nDigit;
            bEven = !bEven;
          }
          return nCheck % 10 === 0;
        },
        minlength: function(value, element, param) {
          var length = $.isArray(value) ? value.length : this.getLength(value, element);
          return this.optional(element) || length >= param;
        },
        maxlength: function(value, element, param) {
          var length = $.isArray(value) ? value.length : this.getLength(value, element);
          return this.optional(element) || length <= param;
        },
        rangelength: function(value, element, param) {
          var length = $.isArray(value) ? value.length : this.getLength(value, element);
          return this.optional(element) || length >= param[0] && length <= param[1];
        },
        min: function(value, element, param) {
          return this.optional(element) || value >= param;
        },
        max: function(value, element, param) {
          return this.optional(element) || value <= param;
        },
        range: function(value, element, param) {
          return this.optional(element) || value >= param[0] && value <= param[1];
        },
        equalTo: function(value, element, param) {
          var target = $(param);
          if (this.settings.onfocusout) {
            target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
              $(element).valid();
            });
          }
          return value === target.val();
        },
        remote: function(value, element, param) {
          if (this.optional(element)) {
            return "dependency-mismatch";
          }
          var previous = this.previousValue(element), validator, data;
          if (!this.settings.messages[element.name]) {
            this.settings.messages[element.name] = {};
          }
          previous.originalMessage = this.settings.messages[element.name].remote;
          this.settings.messages[element.name].remote = previous.message;
          param = typeof param === "string" && {
            url: param
          } || param;
          if (previous.old === value) {
            return previous.valid;
          }
          previous.old = value;
          validator = this;
          this.startRequest(element);
          data = {};
          data[element.name] = value;
          $.ajax($.extend(true, {
            url: param,
            mode: "abort",
            port: "validate" + element.name,
            dataType: "json",
            data: data,
            context: validator.currentForm,
            success: function(response) {
              var valid = response === true || response === "true", errors, message, submitted;
              validator.settings.messages[element.name].remote = previous.originalMessage;
              if (valid) {
                submitted = validator.formSubmitted;
                validator.prepareElement(element);
                validator.formSubmitted = submitted;
                validator.successList.push(element);
                delete validator.invalid[element.name];
                validator.showErrors();
              } else {
                errors = {};
                message = response || validator.defaultMessage(element, "remote");
                errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
                validator.invalid[element.name] = true;
                validator.showErrors(errors);
              }
              previous.valid = valid;
              validator.stopRequest(element, valid);
            }
          }, param));
          return "pending";
        }
      }
    });
    $.format = function deprecated() {
      throw "$.format has been deprecated. Please use $.validator.format instead.";
    };
    var pendingRequests = {}, ajax;
    if ($.ajaxPrefilter) {
      $.ajaxPrefilter(function(settings, _, xhr) {
        var port = settings.port;
        if (settings.mode === "abort") {
          if (pendingRequests[port]) {
            pendingRequests[port].abort();
          }
          pendingRequests[port] = xhr;
        }
      });
    } else {
      ajax = $.ajax;
      $.ajax = function(settings) {
        var mode = ("mode" in settings ? settings : $.ajaxSettings).mode, port = ("port" in settings ? settings : $.ajaxSettings).port;
        if (mode === "abort") {
          if (pendingRequests[port]) {
            pendingRequests[port].abort();
          }
          pendingRequests[port] = ajax.apply(this, arguments);
          return pendingRequests[port];
        }
        return ajax.apply(this, arguments);
      };
    }
    $.extend($.fn, {
      validateDelegate: function(delegate, type, handler) {
        return this.bind(type, function(event) {
          var target = $(event.target);
          if (target.is(delegate)) {
            return handler.apply(target, arguments);
          }
        });
      }
    });
  });
}, function(module, exports, __webpack_require__) {
  (function(_) {
    var Globalize, XRegExp, cardNumberValidationFactory, methods, moment, settings;
    settings = __webpack_require__(2);
    moment = __webpack_require__(7);
    XRegExp = __webpack_require__(19);
    Globalize = __webpack_require__(3);
    methods = {};
    methods.money = function(value) {
      return Globalize.parseFloat(value) >= 0;
    };
    methods.phone = function(value) {
      return /^\+?[ \d\-()]*$/.test(value);
    };
    methods.PHONE10 = function(value) {
      return new RegExp("^\\d{10}$").test(value);
    };
    methods.PHONERU = function(value) {
      return new RegExp("^7\\d{10}$").test(value);
    };
    methods.PHONEUA = function(value) {
      return new RegExp("^38\\d{10}$").test(value);
    };
    methods.PHONEBE = function(value) {
      return new RegExp("^32\\d{10}$").test(value);
    };
    methods.PHONEVN = function(value) {
      return new RegExp("^0\\d{9,10}$").test(value);
    };
    methods.SYMBOL30 = function(value) {
      return /^[\sA-Za-z0-9]*$/.test(value) && value.length <= 30;
    };
    methods.INN = function(value) {
      return value.length === 12;
    };
    methods.INN10 = function(value) {
      return value.length === 10;
    };
    methods.amountOrZero = function(value) {
      return Globalize.parseFloat(value) >= 0;
    };
    methods.positiveAmount = function(value) {
      return Globalize.parseFloat(value) > 0;
    };
    methods.maxAmount = function(value, maxValue) {
      return value <= maxValue;
    };
    methods.passwordChars = function(value, allowedChars) {
      return _.every(value.toLowerCase(), function(char) {
        return _.contains(allowedChars.toLowerCase(), char);
      });
    };
    methods.passwordRegex = function(value, regExp) {
      return XRegExp(regExp).test(value);
    };
    methods.postalCode = function(value) {
      console.assert(settings.POSTAL_CODE_LENGTH, "POSTAL_CODE_LENGTH setting is required");
      return /^\d+$/.test(value) && value.length === settings.POSTAL_CODE_LENGTH;
    };
    methods.number = function(value) {
      return !isNaN(Globalize.parseFloat(String(value)));
    };
    methods.IIN = function(value) {
      var c, i, j, k, mod, sum;
      if (!value.match(/\d{12}/g)) {
        return false;
      }
      if (parseInt(value.substr(2, 2)) > 12 || parseInt(value.substr(4, 2)) > 31) {
        return false;
      }
      if (parseInt(value.substr(6, 1)) === 0 || parseInt(value.substr(6, 1)) > 6) {
        return false;
      }
      sum = 0;
      for (i = j = 1; j <= 11; i = ++j) {
        sum += i * value[i - 1];
      }
      mod = sum % 11;
      if (mod === 10) {
        sum = 0;
        for (i = k = 1; k <= 11; i = ++k) {
          c = (i + 2) % 11;
          if (c === 0) {
            c = 11;
          }
          sum += c * value[i - 1];
        }
        mod = sum % 11;
        if (mod === 1) {
          return false;
        } else {
          return mod === parseInt(value[11]);
        }
      } else {
        return mod === parseInt(value[11]);
      }
    };
    methods.alphanumeric = function(value) {
      return /^[a-z0-9]+$/i.test(value);
    };
    methods.username = function(value) {
      return !settings.LOGIN_PATTERN || settings.LOGIN_PATTERN.test(value);
    };
    methods.uniqueCollectionItem = function(value, collection) {
      return collection.indexOf(value) === -1;
    };
    methods.expiryDateFormat = function(value) {
      var matches, month, validDate, year;
      matches = value.match(/^(\d{2})\/(\d{2})$/);
      if (!matches) {
        return false;
      }
      month = parseInt(matches[1], 10) - 1;
      year = parseInt("20" + matches[2], 10);
      validDate = month >= 0 && month <= 11;
      if (!validDate) {
        return false;
      }
      return moment({
        month: month,
        year: year
      });
    };
    methods.expiryDate = function(value) {
      var expiryDate;
      expiryDate = methods.expiryDateFormat(value);
      if (!expiryDate) {
        return false;
      }
      expiryDate = expiryDate.endOf("month");
      return expiryDate.isSame(moment(), "day") || expiryDate.isAfter(moment(), "day");
    };
    methods.expiryDateFrom = function(value) {
      var expiryDate;
      expiryDate = methods.expiryDateFormat(value);
      if (!expiryDate) {
        return false;
      }
      expiryDate = expiryDate.startOf("month");
      return expiryDate.isSame(moment(), "day") || expiryDate.isBefore(moment(), "day");
    };
    methods.datePast = function(value) {
      return moment(value).isBefore(moment(), "day");
    };
    methods.datePastNonIso = function(value) {
      return moment(value, [ "DD-MM-YYYY" ]).isBefore(moment(), "day");
    };
    methods.dateFuture = function(value) {
      return moment(value).isAfter(moment(), "day");
    };
    methods.embossingName = function(value) {
      value = value || "";
      return /^[A-Za-z -.']*$/.test(value.trim());
    };
    methods.greaterOrEqual = function(value, otherValue) {
      return _.isNaN(otherValue) || value >= otherValue;
    };
    methods.lessOrEqual = function(value, otherValue) {
      return _.isNaN(otherValue) || value <= otherValue;
    };
    methods.integer = function(value) {
      return Number.isInteger(Globalize.parseFloat(value));
    };
    methods.pattern = function(value, regExp) {
      return XRegExp(regExp).test(value);
    };
    methods.modulus = function(value, divider) {
      return value % divider === 0;
    };
    methods.notEqualTo = function(value, otherValue) {
      return values !== otherValue;
    };
    methods.personalizedDeviceName = function(value) {
      return !/[,.;:]/.test(value);
    };
    methods.email = function(value) {
      return /^.+@.+\.+.+$/.test(value);
    };
    cardNumberValidationFactory = function(minLength, maxLength) {
      return function(value) {
        var bEven, cDigit, nCheck, nDigit, ndx;
        if (/[^0-9 \-]+/.test(value)) {
          return false;
        }
        value = value.replace(/\D/g, "");
        if (value.length < minLength || value.length > maxLength) {
          return false;
        }
        nCheck = 0;
        bEven = false;
        ndx = value.length;
        while (ndx) {
          cDigit = value.charAt(ndx - 1);
          nDigit = parseInt(cDigit, 10);
          if (bEven && (nDigit *= 2) > 9) {
            nDigit -= 9;
          }
          nCheck += nDigit;
          bEven = !bEven;
          ndx -= 1;
        }
        return nCheck % 10 === 0;
      };
    };
    methods.cardNumber = cardNumberValidationFactory(13, 19);
    methods.cardNumber16 = cardNumberValidationFactory(16, 16);
    methods.cardNumber19 = cardNumberValidationFactory(19, 19);
    module.exports = methods;
  }).call(exports, __webpack_require__(0));
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*!
 * XRegExp 4.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2007-present MIT License
 */
  var REGEX_DATA = "xregexp";
  var features = {
    astral: false,
    namespacing: false
  };
  var nativ = {
    exec: RegExp.prototype.exec,
    test: RegExp.prototype.test,
    match: String.prototype.match,
    replace: String.prototype.replace,
    split: String.prototype.split
  };
  var fixed = {};
  var regexCache = {};
  var patternCache = {};
  var tokens = [];
  var defaultScope = "default";
  var classScope = "class";
  var nativeTokens = {
    default: /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
    class: /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
  };
  var replacementToken = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g;
  var correctExecNpcg = nativ.exec.call(/()??/, "")[1] === undefined;
  var hasFlagsProp = /x/.flags !== undefined;
  var toString = {}.toString;
  function hasNativeFlag(flag) {
    var isSupported = true;
    try {
      new RegExp("", flag);
    } catch (exception) {
      isSupported = false;
    }
    return isSupported;
  }
  var hasNativeU = hasNativeFlag("u");
  var hasNativeY = hasNativeFlag("y");
  var registeredFlags = {
    g: true,
    i: true,
    m: true,
    u: hasNativeU,
    y: hasNativeY
  };
  function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
    var p = void 0;
    regex[REGEX_DATA] = {
      captureNames: captureNames
    };
    if (isInternalOnly) {
      return regex;
    }
    if (regex.__proto__) {
      regex.__proto__ = XRegExp.prototype;
    } else {
      for (p in XRegExp.prototype) {
        regex[p] = XRegExp.prototype[p];
      }
    }
    regex[REGEX_DATA].source = xSource;
    regex[REGEX_DATA].flags = xFlags ? xFlags.split("").sort().join("") : xFlags;
    return regex;
  }
  function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, "");
  }
  function copyRegex(regex, options) {
    if (!XRegExp.isRegExp(regex)) {
      throw new TypeError("Type RegExp expected");
    }
    var xData = regex[REGEX_DATA] || {};
    var flags = getNativeFlags(regex);
    var flagsToAdd = "";
    var flagsToRemove = "";
    var xregexpSource = null;
    var xregexpFlags = null;
    options = options || {};
    if (options.removeG) {
      flagsToRemove += "g";
    }
    if (options.removeY) {
      flagsToRemove += "y";
    }
    if (flagsToRemove) {
      flags = nativ.replace.call(flags, new RegExp("[" + flagsToRemove + "]+", "g"), "");
    }
    if (options.addG) {
      flagsToAdd += "g";
    }
    if (options.addY) {
      flagsToAdd += "y";
    }
    if (flagsToAdd) {
      flags = clipDuplicates(flags + flagsToAdd);
    }
    if (!options.isInternalOnly) {
      if (xData.source !== undefined) {
        xregexpSource = xData.source;
      }
      if (xData.flags != null) {
        xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
      }
    }
    regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
    return regex;
  }
  function dec(hex) {
    return parseInt(hex, 16);
  }
  function getContextualTokenSeparator(match, scope, flags) {
    if (match.input[match.index - 1] === "(" || match.input[match.index + match[0].length] === ")" || match.input[match.index - 1] === "|" || match.input[match.index + match[0].length] === "|" || match.index < 1 || match.index + match[0].length >= match.input.length || nativ.test.call(/^\(\?[:=!]/, match.input.substr(match.index - 3, 3)) || isQuantifierNext(match.input, match.index + match[0].length, flags)) {
      return "";
    }
    return "(?:)";
  }
  function getNativeFlags(regex) {
    return hasFlagsProp ? regex.flags : nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
  }
  function hasNamedCapture(regex) {
    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
  }
  function hex(dec) {
    return parseInt(dec, 10).toString(16);
  }
  function isQuantifierNext(pattern, pos, flags) {
    var inlineCommentPattern = "\\(\\?#[^)]*\\)";
    var lineCommentPattern = "#[^#\\n]*";
    var quantifierPattern = "[?*+]|{\\d+(?:,\\d*)?}";
    return nativ.test.call(flags.indexOf("x") !== -1 ? /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos));
  }
  function isType(value, type) {
    return toString.call(value) === "[object " + type + "]";
  }
  function pad4(str) {
    while (str.length < 4) {
      str = "0" + str;
    }
    return str;
  }
  function prepareFlags(pattern, flags) {
    var i = void 0;
    if (clipDuplicates(flags) !== flags) {
      throw new SyntaxError("Invalid duplicate regex flag " + flags);
    }
    pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
      if (nativ.test.call(/[gy]/, $1)) {
        throw new SyntaxError("Cannot use flag g or y in mode modifier " + $0);
      }
      flags = clipDuplicates(flags + $1);
      return "";
    });
    for (i = 0; i < flags.length; ++i) {
      if (!registeredFlags[flags[i]]) {
        throw new SyntaxError("Unknown regex flag " + flags[i]);
      }
    }
    return {
      pattern: pattern,
      flags: flags
    };
  }
  function prepareOptions(value) {
    var options = {};
    if (isType(value, "String")) {
      XRegExp.forEach(value, /[^\s,]+/, function(match) {
        options[match] = true;
      });
      return options;
    }
    return value;
  }
  function registerFlag(flag) {
    if (!/^[\w$]$/.test(flag)) {
      throw new Error("Flag must be a single character A-Za-z0-9_$");
    }
    registeredFlags[flag] = true;
  }
  function runTokens(pattern, flags, pos, scope, context) {
    var i = tokens.length;
    var leadChar = pattern[pos];
    var result = null;
    var match = void 0;
    var t = void 0;
    while (i--) {
      t = tokens[i];
      if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && !(flags.indexOf(t.flag) !== -1)) {
        continue;
      }
      match = XRegExp.exec(pattern, t.regex, pos, "sticky");
      if (match) {
        result = {
          matchLength: match[0].length,
          output: t.handler.call(context, match, scope, flags),
          reparse: t.reparse
        };
        break;
      }
    }
    return result;
  }
  function setAstral(on) {
    features.astral = on;
  }
  function setNamespacing(on) {
    features.namespacing = on;
  }
  function toObject(value) {
    if (value == null) {
      throw new TypeError("Cannot convert null or undefined to object");
    }
    return value;
  }
  function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
      if (flags !== undefined) {
        throw new TypeError("Cannot supply flags when copying a RegExp");
      }
      return copyRegex(pattern);
    }
    pattern = pattern === undefined ? "" : String(pattern);
    flags = flags === undefined ? "" : String(flags);
    if (XRegExp.isInstalled("astral") && !(flags.indexOf("A") !== -1)) {
      flags += "A";
    }
    if (!patternCache[pattern]) {
      patternCache[pattern] = {};
    }
    if (!patternCache[pattern][flags]) {
      var context = {
        hasNamedCapture: false,
        captureNames: []
      };
      var scope = defaultScope;
      var output = "";
      var pos = 0;
      var result = void 0;
      var applied = prepareFlags(pattern, flags);
      var appliedPattern = applied.pattern;
      var appliedFlags = applied.flags;
      while (pos < appliedPattern.length) {
        do {
          result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
          if (result && result.reparse) {
            appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
          }
        } while (result && result.reparse);
        if (result) {
          output += result.output;
          pos += result.matchLength || 1;
        } else {
          var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky")[0];
          output += token;
          pos += token.length;
          if (token === "[" && scope === defaultScope) {
            scope = classScope;
          } else if (token === "]" && scope === classScope) {
            scope = defaultScope;
          }
        }
      }
      patternCache[pattern][flags] = {
        pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, "(?:)"),
        flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ""),
        captures: context.hasNamedCapture ? context.captureNames : null
      };
    }
    var generated = patternCache[pattern][flags];
    return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);
  }
  XRegExp.prototype = /(?:)/;
  XRegExp.version = "4.1.1";
  XRegExp._clipDuplicates = clipDuplicates;
  XRegExp._hasNativeFlag = hasNativeFlag;
  XRegExp._dec = dec;
  XRegExp._hex = hex;
  XRegExp._pad4 = pad4;
  XRegExp.addToken = function(regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i = void 0;
    if (options.flag) {
      registerFlag(options.flag);
    }
    if (optionalFlags) {
      optionalFlags = nativ.split.call(optionalFlags, "");
      for (i = 0; i < optionalFlags.length; ++i) {
        registerFlag(optionalFlags[i]);
      }
    }
    tokens.push({
      regex: copyRegex(regex, {
        addG: true,
        addY: hasNativeY,
        isInternalOnly: true
      }),
      handler: handler,
      scope: options.scope || defaultScope,
      flag: options.flag,
      reparse: options.reparse,
      leadChar: options.leadChar
    });
    XRegExp.cache.flush("patterns");
  };
  XRegExp.cache = function(pattern, flags) {
    if (!regexCache[pattern]) {
      regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
  };
  XRegExp.cache.flush = function(cacheName) {
    if (cacheName === "patterns") {
      patternCache = {};
    } else {
      regexCache = {};
    }
  };
  XRegExp.escape = function(str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  };
  XRegExp.exec = function(str, regex, pos, sticky) {
    var cacheKey = "g";
    var addY = false;
    var fakeY = false;
    var match = void 0;
    addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
    if (addY) {
      cacheKey += "y";
    } else if (sticky) {
      fakeY = true;
      cacheKey += "FakeY";
    }
    regex[REGEX_DATA] = regex[REGEX_DATA] || {};
    var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
      addG: true,
      addY: addY,
      source: fakeY ? regex.source + "|()" : undefined,
      removeY: sticky === false,
      isInternalOnly: true
    }));
    pos = pos || 0;
    r2.lastIndex = pos;
    match = fixed.exec.call(r2, str);
    if (fakeY && match && match.pop() === "") {
      match = null;
    }
    if (regex.global) {
      regex.lastIndex = match ? r2.lastIndex : 0;
    }
    return match;
  };
  XRegExp.forEach = function(str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match = void 0;
    while (match = XRegExp.exec(str, regex, pos)) {
      callback(match, ++i, str, regex);
      pos = match.index + (match[0].length || 1);
    }
  };
  XRegExp.globalize = function(regex) {
    return copyRegex(regex, {
      addG: true
    });
  };
  XRegExp.install = function(options) {
    options = prepareOptions(options);
    if (!features.astral && options.astral) {
      setAstral(true);
    }
    if (!features.namespacing && options.namespacing) {
      setNamespacing(true);
    }
  };
  XRegExp.isInstalled = function(feature) {
    return !!features[feature];
  };
  XRegExp.isRegExp = function(value) {
    return toString.call(value) === "[object RegExp]";
  };
  XRegExp.match = function(str, regex, scope) {
    var global = regex.global && scope !== "one" || scope === "all";
    var cacheKey = (global ? "g" : "") + (regex.sticky ? "y" : "") || "noGY";
    regex[REGEX_DATA] = regex[REGEX_DATA] || {};
    var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
      addG: !!global,
      removeG: scope === "one",
      isInternalOnly: true
    }));
    var result = nativ.match.call(toObject(str), r2);
    if (regex.global) {
      regex.lastIndex = scope === "one" && result ? result.index + result[0].length : 0;
    }
    return global ? result || [] : result && result[0];
  };
  XRegExp.matchChain = function(str, chain) {
    return function recurseChain(values, level) {
      var item = chain[level].regex ? chain[level] : {
        regex: chain[level]
      };
      var matches = [];
      function addMatch(match) {
        if (item.backref) {
          var ERR_UNDEFINED_GROUP = "Backreference to undefined group: " + item.backref;
          var isNamedBackref = isNaN(item.backref);
          if (isNamedBackref && XRegExp.isInstalled("namespacing")) {
            if (!(item.backref in match.groups)) {
              throw new ReferenceError(ERR_UNDEFINED_GROUP);
            }
          } else if (!match.hasOwnProperty(item.backref)) {
            throw new ReferenceError(ERR_UNDEFINED_GROUP);
          }
          var backrefValue = isNamedBackref && XRegExp.isInstalled("namespacing") ? match.groups[item.backref] : match[item.backref];
          matches.push(backrefValue || "");
        } else {
          matches.push(match[0]);
        }
      }
      for (var i = 0; i < values.length; ++i) {
        XRegExp.forEach(values[i], item.regex, addMatch);
      }
      return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
    }([ str ], 0);
  };
  XRegExp.replace = function(str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = search.global && scope !== "one" || scope === "all";
    var cacheKey = (global ? "g" : "") + (search.sticky ? "y" : "") || "noGY";
    var s2 = search;
    if (isRegex) {
      search[REGEX_DATA] = search[REGEX_DATA] || {};
      s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
        addG: !!global,
        removeG: scope === "one",
        isInternalOnly: true
      }));
    } else if (global) {
      s2 = new RegExp(XRegExp.escape(String(search)), "g");
    }
    var result = fixed.replace.call(toObject(str), s2, replacement);
    if (isRegex && search.global) {
      search.lastIndex = 0;
    }
    return result;
  };
  XRegExp.replaceEach = function(str, replacements) {
    var i = void 0;
    var r = void 0;
    for (i = 0; i < replacements.length; ++i) {
      r = replacements[i];
      str = XRegExp.replace(str, r[0], r[1], r[2]);
    }
    return str;
  };
  XRegExp.split = function(str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
  };
  XRegExp.test = function(str, regex, pos, sticky) {
    return !!XRegExp.exec(str, regex, pos, sticky);
  };
  XRegExp.uninstall = function(options) {
    options = prepareOptions(options);
    if (features.astral && options.astral) {
      setAstral(false);
    }
    if (features.namespacing && options.namespacing) {
      setNamespacing(false);
    }
  };
  XRegExp.union = function(patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || "or";
    var numCaptures = 0;
    var numPriorCaptures = void 0;
    var captureNames = void 0;
    function rewrite(match, paren, backref) {
      var name = captureNames[numCaptures - numPriorCaptures];
      if (paren) {
        ++numCaptures;
        if (name) {
          return "(?<" + name + ">";
        }
      } else if (backref) {
        return "\\" + (+backref + numPriorCaptures);
      }
      return match;
    }
    if (!(isType(patterns, "Array") && patterns.length)) {
      throw new TypeError("Must provide a nonempty array of patterns to merge");
    }
    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern = void 0;
    for (var i = 0; i < patterns.length; ++i) {
      pattern = patterns[i];
      if (XRegExp.isRegExp(pattern)) {
        numPriorCaptures = numCaptures;
        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];
        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
      } else {
        output.push(XRegExp.escape(pattern));
      }
    }
    var separator = conjunction === "none" ? "" : "|";
    return XRegExp(output.join(separator), flags);
  };
  fixed.exec = function(str) {
    var origLastIndex = this.lastIndex;
    var match = nativ.exec.apply(this, arguments);
    if (match) {
      if (!correctExecNpcg && match.length > 1 && match.indexOf("") !== -1) {
        var r2 = copyRegex(this, {
          removeG: true,
          isInternalOnly: true
        });
        nativ.replace.call(String(str).slice(match.index), r2, function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var len = args.length;
          for (var i = 1; i < len - 2; ++i) {
            if (args[i] === undefined) {
              match[i] = undefined;
            }
          }
        });
      }
      var groupsObject = match;
      if (XRegExp.isInstalled("namespacing")) {
        match.groups = Object.create(null);
        groupsObject = match.groups;
      }
      if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
        for (var i = 1; i < match.length; ++i) {
          var name = this[REGEX_DATA].captureNames[i - 1];
          if (name) {
            groupsObject[name] = match[i];
          }
        }
      }
      if (this.global && !match[0].length && this.lastIndex > match.index) {
        this.lastIndex = match.index;
      }
    }
    if (!this.global) {
      this.lastIndex = origLastIndex;
    }
    return match;
  };
  fixed.test = function(str) {
    return !!fixed.exec.call(this, str);
  };
  fixed.match = function(regex) {
    if (!XRegExp.isRegExp(regex)) {
      regex = new RegExp(regex);
    } else if (regex.global) {
      var result = nativ.match.apply(this, arguments);
      regex.lastIndex = 0;
      return result;
    }
    return fixed.exec.call(regex, toObject(this));
  };
  fixed.replace = function(search, replacement) {
    var isRegex = XRegExp.isRegExp(search);
    var origLastIndex = void 0;
    var captureNames = void 0;
    var result = void 0;
    if (isRegex) {
      if (search[REGEX_DATA]) {
        captureNames = search[REGEX_DATA].captureNames;
      }
      origLastIndex = search.lastIndex;
    } else {
      search += "";
    }
    if (isType(replacement, "Function")) {
      result = nativ.replace.call(String(this), search, function() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (captureNames) {
          var groupsObject = void 0;
          if (XRegExp.isInstalled("namespacing")) {
            groupsObject = Object.create(null);
            args.push(groupsObject);
          } else {
            args[0] = new String(args[0]);
            groupsObject = args[0];
          }
          for (var i = 0; i < captureNames.length; ++i) {
            if (captureNames[i]) {
              groupsObject[captureNames[i]] = args[i + 1];
            }
          }
        }
        if (isRegex && search.global) {
          search.lastIndex = args[args.length - 2] + args[0].length;
        }
        return replacement.apply(undefined, args);
      });
    } else {
      result = nativ.replace.call(this == null ? this : String(this), search, function() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return nativ.replace.call(String(replacement), replacementToken, replacer);
        function replacer($0, bracketed, angled, dollarToken) {
          bracketed = bracketed || angled;
          if (bracketed) {
            var n = +bracketed;
            if (n <= args.length - 3) {
              return args[n] || "";
            }
            n = captureNames ? captureNames.indexOf(bracketed) : -1;
            if (n < 0) {
              throw new SyntaxError("Backreference to undefined group " + $0);
            }
            return args[n + 1] || "";
          }
          if (dollarToken === "$") {
            return "$";
          }
          if (dollarToken === "&" || +dollarToken === 0) {
            return args[0];
          }
          if (dollarToken === "`") {
            return args[args.length - 1].slice(0, args[args.length - 2]);
          }
          if (dollarToken === "'") {
            return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
          }
          dollarToken = +dollarToken;
          if (!isNaN(dollarToken)) {
            if (dollarToken > args.length - 3) {
              throw new SyntaxError("Backreference to undefined group " + $0);
            }
            return args[dollarToken] || "";
          }
          throw new SyntaxError("Invalid token " + $0);
        }
      });
    }
    if (isRegex) {
      if (search.global) {
        search.lastIndex = 0;
      } else {
        search.lastIndex = origLastIndex;
      }
    }
    return result;
  };
  fixed.split = function(separator, limit) {
    if (!XRegExp.isRegExp(separator)) {
      return nativ.split.apply(this, arguments);
    }
    var str = String(this);
    var output = [];
    var origLastIndex = separator.lastIndex;
    var lastLastIndex = 0;
    var lastLength = void 0;
    limit = (limit === undefined ? -1 : limit) >>> 0;
    XRegExp.forEach(str, separator, function(match) {
      if (match.index + match[0].length > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = match.index + lastLength;
      }
    });
    if (lastLastIndex === str.length) {
      if (!nativ.test.call(separator, "") || lastLength) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    separator.lastIndex = origLastIndex;
    return output.length > limit ? output.slice(0, limit) : output;
  };
  XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
    if (match[1] === "B" && scope === defaultScope) {
      return match[0];
    }
    throw new SyntaxError("Invalid escape " + match[0]);
  }, {
    scope: "all",
    leadChar: "\\"
  });
  XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags) {
    var code = dec(match[1]);
    if (code > 1114111) {
      throw new SyntaxError("Invalid Unicode code point " + match[0]);
    }
    if (code <= 65535) {
      return "\\u" + pad4(hex(code));
    }
    if (hasNativeU && flags.indexOf("u") !== -1) {
      return match[0];
    }
    throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
  }, {
    scope: "all",
    leadChar: "\\"
  });
  XRegExp.addToken(/\[(\^?)\]/, function(match) {
    return match[1] ? "[\\s\\S]" : "\\b\\B";
  }, {
    leadChar: "["
  });
  XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, {
    leadChar: "("
  });
  XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, {
    flag: "x"
  });
  XRegExp.addToken(/\./, function() {
    return "[\\s\\S]";
  }, {
    flag: "s",
    leadChar: "."
  });
  XRegExp.addToken(/\\k<([\w$]+)>/, function(match) {
    var index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];
    var endIndex = match.index + match[0].length;
    if (!index || index > this.captureNames.length) {
      throw new SyntaxError("Backreference to undefined group " + match[0]);
    }
    return "\\" + index + (endIndex === match.input.length || isNaN(match.input[endIndex]) ? "" : "(?:)");
  }, {
    leadChar: "\\"
  });
  XRegExp.addToken(/\\(\d+)/, function(match, scope) {
    if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") {
      throw new SyntaxError("Cannot use octal escape or backreference to undefined group " + match[0]);
    }
    return match[0];
  }, {
    scope: "all",
    leadChar: "\\"
  });
  XRegExp.addToken(/\(\?P?<([\w$]+)>/, function(match) {
    if (!isNaN(match[1])) {
      throw new SyntaxError("Cannot use integer as capture name " + match[0]);
    }
    if (!XRegExp.isInstalled("namespacing") && (match[1] === "length" || match[1] === "__proto__")) {
      throw new SyntaxError("Cannot use reserved word as capture name " + match[0]);
    }
    if (this.captureNames.indexOf(match[1]) !== -1) {
      throw new SyntaxError("Cannot use same name for multiple groups " + match[0]);
    }
    this.captureNames.push(match[1]);
    this.hasNamedCapture = true;
    return "(";
  }, {
    leadChar: "("
  });
  XRegExp.addToken(/\((?!\?)/, function(match, scope, flags) {
    if (flags.indexOf("n") !== -1) {
      return "(?:";
    }
    this.captureNames.push(null);
    return "(";
  }, {
    optionalFlags: "n",
    leadChar: "("
  });
  exports.default = XRegExp;
  module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*!
 * XRegExp.build 4.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-present MIT License
 */
  exports.default = function(XRegExp) {
    var REGEX_DATA = "xregexp";
    var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var parts = XRegExp.union([ /\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts ], "g", {
      conjunction: "or"
    });
    function deanchor(pattern) {
      var leadingAnchor = /^(?:\(\?:\))*\^/;
      var trailingAnchor = /\$(?:\(\?:\))*$/;
      if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) {
        return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
      }
      return pattern;
    }
    function asXRegExp(value, addFlagX) {
      var flags = addFlagX ? "x" : "";
      return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? value : XRegExp(value.source, flags) : XRegExp(value, flags);
    }
    function interpolate(substitution) {
      return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);
    }
    function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
      subpatterns["subpattern" + subpatternIndex] = interpolated;
      return subpatterns;
    }
    function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
      var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
      return raw + (hasSubpattern ? "{{subpattern" + subpatternIndex + "}}" : "");
    }
    XRegExp.tag = function(flags) {
      return function(literals) {
        for (var _len = arguments.length, substitutions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          substitutions[_key - 1] = arguments[_key];
        }
        var subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});
        var pattern = literals.raw.map(embedSubpatternAfter).join("");
        return XRegExp.build(pattern, subpatterns, flags);
      };
    };
    XRegExp.build = function(pattern, subs, flags) {
      flags = flags || "";
      var addFlagX = flags.indexOf("x") !== -1;
      var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
      if (inlineFlags) {
        flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
      }
      var data = {};
      for (var p in subs) {
        if (subs.hasOwnProperty(p)) {
          var sub = asXRegExp(subs[p], addFlagX);
          data[p] = {
            pattern: deanchor(sub.source),
            names: sub[REGEX_DATA].captureNames || []
          };
        }
      }
      var patternAsRegex = asXRegExp(pattern, addFlagX);
      var numCaps = 0;
      var numPriorCaps = void 0;
      var numOuterCaps = 0;
      var outerCapsMap = [ 0 ];
      var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
      var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2;
        var capName = void 0;
        var intro = void 0;
        var localCapIndex = void 0;
        if (subName) {
          if (!data.hasOwnProperty(subName)) {
            throw new ReferenceError("Undefined property " + $0);
          }
          if ($1) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            intro = "(?<" + (capName || subName) + ">";
          } else {
            intro = "(?:";
          }
          numPriorCaps = numCaps;
          var rewrittenSubpattern = data[subName].pattern.replace(subParts, function(match, paren, backref) {
            if (paren) {
              capName = data[subName].names[numCaps - numPriorCaps];
              ++numCaps;
              if (capName) {
                return "(?<" + capName + ">";
              }
            } else if (backref) {
              localCapIndex = +backref - 1;
              return data[subName].names[localCapIndex] ? "\\k<" + data[subName].names[localCapIndex] + ">" : "\\" + (+backref + numPriorCaps);
            }
            return match;
          });
          return "" + intro + rewrittenSubpattern + ")";
        }
        if ($3) {
          capName = outerCapNames[numOuterCaps];
          outerCapsMap[++numOuterCaps] = ++numCaps;
          if (capName) {
            return "(?<" + capName + ">";
          }
        } else if ($4) {
          localCapIndex = +$4 - 1;
          return outerCapNames[localCapIndex] ? "\\k<" + outerCapNames[localCapIndex] + ">" : "\\" + outerCapsMap[+$4];
        }
        return $0;
      });
      return XRegExp(output, flags);
    };
  };
  module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*!
 * XRegExp.matchRecursive 4.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2009-present MIT License
 */
  exports.default = function(XRegExp) {
    function row(name, value, start, end) {
      return {
        name: name,
        value: value,
        start: start,
        end: end
      };
    }
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
      flags = flags || "";
      options = options || {};
      var global = flags.indexOf("g") !== -1;
      var sticky = flags.indexOf("y") !== -1;
      var basicFlags = flags.replace(/y/g, "");
      var escapeChar = options.escapeChar;
      var vN = options.valueNames;
      var output = [];
      var openTokens = 0;
      var delimStart = 0;
      var delimEnd = 0;
      var lastOuterEnd = 0;
      var outerStart = void 0;
      var innerStart = void 0;
      var leftMatch = void 0;
      var rightMatch = void 0;
      var esc = void 0;
      left = XRegExp(left, basicFlags);
      right = XRegExp(right, basicFlags);
      if (escapeChar) {
        if (escapeChar.length > 1) {
          throw new Error("Cannot use more than one escape character");
        }
        escapeChar = XRegExp.escape(escapeChar);
        esc = new RegExp("(?:" + escapeChar + "[\\S\\s]|(?:(?!" + XRegExp.union([ left, right ], "", {
          conjunction: "or"
        }).source + ")[^" + escapeChar + "])+)+", flags.replace(/[^imu]+/g, ""));
      }
      while (true) {
        if (escapeChar) {
          delimEnd += (XRegExp.exec(str, esc, delimEnd, "sticky") || [ "" ])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        if (leftMatch && rightMatch) {
          if (leftMatch.index <= rightMatch.index) {
            rightMatch = null;
          } else {
            leftMatch = null;
          }
        }
        if (leftMatch || rightMatch) {
          delimStart = (leftMatch || rightMatch).index;
          delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
          break;
        }
        if (sticky && !openTokens && delimStart > lastOuterEnd) {
          break;
        }
        if (leftMatch) {
          if (!openTokens) {
            outerStart = delimStart;
            innerStart = delimEnd;
          }
          ++openTokens;
        } else if (rightMatch && openTokens) {
          if (!--openTokens) {
            if (vN) {
              if (vN[0] && outerStart > lastOuterEnd) {
                output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
              }
              if (vN[1]) {
                output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
              }
              if (vN[2]) {
                output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
              }
              if (vN[3]) {
                output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
              }
            } else {
              output.push(str.slice(innerStart, delimStart));
            }
            lastOuterEnd = delimEnd;
            if (!global) {
              break;
            }
          }
        } else {
          throw new Error("Unbalanced delimiter found in string");
        }
        if (delimStart === delimEnd) {
          ++delimEnd;
        }
      }
      if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
        output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
      }
      return output;
    };
  };
  module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /*!
 * XRegExp Unicode Base 4.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2008-present MIT License
 */
  exports.default = function(XRegExp) {
    var unicode = {};
    var dec = XRegExp._dec;
    var hex = XRegExp._hex;
    var pad4 = XRegExp._pad4;
    function normalize(name) {
      return name.replace(/[- _]+/g, "").toLowerCase();
    }
    function charCode(chr) {
      var esc = /^\\[xu](.+)/.exec(chr);
      return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === "\\" ? 1 : 0);
    }
    function invertBmp(range) {
      var output = "";
      var lastEnd = -1;
      XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
        var start = charCode(m[1]);
        if (start > lastEnd + 1) {
          output += "\\u" + pad4(hex(lastEnd + 1));
          if (start > lastEnd + 2) {
            output += "-\\u" + pad4(hex(start - 1));
          }
        }
        lastEnd = charCode(m[2] || m[1]);
      });
      if (lastEnd < 65535) {
        output += "\\u" + pad4(hex(lastEnd + 1));
        if (lastEnd < 65534) {
          output += "-\\uFFFF";
        }
      }
      return output;
    }
    function cacheInvertedBmp(slug) {
      var prop = "b!";
      return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
    }
    function buildAstral(slug, isNegated) {
      var item = unicode[slug];
      var combined = "";
      if (item.bmp && !item.isBmpLast) {
        combined = "[" + item.bmp + "]" + (item.astral ? "|" : "");
      }
      if (item.astral) {
        combined += item.astral;
      }
      if (item.isBmpLast && item.bmp) {
        combined += (item.astral ? "|" : "") + "[" + item.bmp + "]";
      }
      return isNegated ? "(?:(?!" + combined + ")(?:[-][-]|[\0-]))" : "(?:" + combined + ")";
    }
    function cacheAstral(slug, isNegated) {
      var prop = isNegated ? "a!" : "a=";
      return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
    }
    XRegExp.addToken(/\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, function(match, scope, flags) {
      var ERR_DOUBLE_NEG = "Invalid double negation ";
      var ERR_UNKNOWN_NAME = "Unknown Unicode token ";
      var ERR_UNKNOWN_REF = "Unicode token missing data ";
      var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ";
      var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes";
      var isNegated = match[1] === "P" || !!match[2];
      var isAstralMode = flags.indexOf("A") !== -1;
      var slug = normalize(match[4] || match[3]);
      var item = unicode[slug];
      if (match[1] === "P" && match[2]) {
        throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
      }
      if (!unicode.hasOwnProperty(slug)) {
        throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
      }
      if (item.inverseOf) {
        slug = normalize(item.inverseOf);
        if (!unicode.hasOwnProperty(slug)) {
          throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + " -> " + item.inverseOf);
        }
        item = unicode[slug];
        isNegated = !isNegated;
      }
      if (!(item.bmp || isAstralMode)) {
        throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
      }
      if (isAstralMode) {
        if (scope === "class") {
          throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
        }
        return cacheAstral(slug, isNegated);
      }
      return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? "[^" : "[") + item.bmp + "]";
    }, {
      scope: "all",
      optionalFlags: "A",
      leadChar: "\\"
    });
    XRegExp.addUnicodeData = function(data) {
      var ERR_NO_NAME = "Unicode token requires name";
      var ERR_NO_DATA = "Unicode token has no character data ";
      var item = void 0;
      for (var i = 0; i < data.length; ++i) {
        item = data[i];
        if (!item.name) {
          throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
          throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
          unicode[normalize(item.alias)] = item;
        }
      }
      XRegExp.cache.flush("patterns");
    };
    XRegExp._getUnicodeProperty = function(name) {
      var slug = normalize(name);
      return unicode[slug];
    };
  };
  module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _blocks = __webpack_require__(59);
  var _blocks2 = _interopRequireDefault(_blocks);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = function(XRegExp) {
    if (!XRegExp.addUnicodeData) {
      throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks");
    }
    XRegExp.addUnicodeData(_blocks2.default);
  };
  /*!
    * XRegExp Unicode Blocks 4.1.1
    * <xregexp.com>
    * Steven Levithan (c) 2010-present MIT License
    * Unicode data by Mathias Bynens <mathiasbynens.be>
    */
  module.exports = exports["default"];
}, function(module, exports) {
  module.exports = [ {
    name: "InAdlam",
    astral: "[-]"
  }, {
    name: "InAegean_Numbers",
    astral: "[-]"
  }, {
    name: "InAhom",
    astral: "[-]"
  }, {
    name: "InAlchemical_Symbols",
    astral: "[-]"
  }, {
    name: "InAlphabetic_Presentation_Forms",
    bmp: "-"
  }, {
    name: "InAnatolian_Hieroglyphs",
    astral: "[-]"
  }, {
    name: "InAncient_Greek_Musical_Notation",
    astral: "[-]"
  }, {
    name: "InAncient_Greek_Numbers",
    astral: "[-]"
  }, {
    name: "InAncient_Symbols",
    astral: "[-]"
  }, {
    name: "InArabic",
    bmp: "-"
  }, {
    name: "InArabic_Extended_A",
    bmp: "-"
  }, {
    name: "InArabic_Mathematical_Alphabetic_Symbols",
    astral: "[-]"
  }, {
    name: "InArabic_Presentation_Forms_A",
    bmp: "-"
  }, {
    name: "InArabic_Presentation_Forms_B",
    bmp: "-\ufeff"
  }, {
    name: "InArabic_Supplement",
    bmp: "-"
  }, {
    name: "InArmenian",
    bmp: "-"
  }, {
    name: "InArrows",
    bmp: "-"
  }, {
    name: "InAvestan",
    astral: "[-]"
  }, {
    name: "InBalinese",
    bmp: "-"
  }, {
    name: "InBamum",
    bmp: "-"
  }, {
    name: "InBamum_Supplement",
    astral: "[-]"
  }, {
    name: "InBasic_Latin",
    bmp: "\0-"
  }, {
    name: "InBassa_Vah",
    astral: "[-]"
  }, {
    name: "InBatak",
    bmp: "-"
  }, {
    name: "InBengali",
    bmp: "-"
  }, {
    name: "InBhaiksuki",
    astral: "[-]"
  }, {
    name: "InBlock_Elements",
    bmp: "-"
  }, {
    name: "InBopomofo",
    bmp: "-"
  }, {
    name: "InBopomofo_Extended",
    bmp: "-"
  }, {
    name: "InBox_Drawing",
    bmp: "-"
  }, {
    name: "InBrahmi",
    astral: "[-]"
  }, {
    name: "InBraille_Patterns",
    bmp: "-"
  }, {
    name: "InBuginese",
    bmp: "-"
  }, {
    name: "InBuhid",
    bmp: "-"
  }, {
    name: "InByzantine_Musical_Symbols",
    astral: "[-]"
  }, {
    name: "InCJK_Compatibility",
    bmp: "-"
  }, {
    name: "InCJK_Compatibility_Forms",
    bmp: "-"
  }, {
    name: "InCJK_Compatibility_Ideographs",
    bmp: "-"
  }, {
    name: "InCJK_Compatibility_Ideographs_Supplement",
    astral: "[-]"
  }, {
    name: "InCJK_Radicals_Supplement",
    bmp: "-"
  }, {
    name: "InCJK_Strokes",
    bmp: "-"
  }, {
    name: "InCJK_Symbols_And_Punctuation",
    bmp: "-"
  }, {
    name: "InCJK_Unified_Ideographs",
    bmp: "-"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_A",
    bmp: "-"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_B",
    astral: "[-][-]|[-]"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_C",
    astral: "[-]|[-][-]|[-]"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_D",
    astral: "[-]|[-]"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_E",
    astral: "[-]|[-][-]|[-]"
  }, {
    name: "InCJK_Unified_Ideographs_Extension_F",
    astral: "[-]|[-][-]|[-]"
  }, {
    name: "InCarian",
    astral: "[-]"
  }, {
    name: "InCaucasian_Albanian",
    astral: "[-]"
  }, {
    name: "InChakma",
    astral: "[-]"
  }, {
    name: "InCham",
    bmp: "-"
  }, {
    name: "InCherokee",
    bmp: "-"
  }, {
    name: "InCherokee_Supplement",
    bmp: "-"
  }, {
    name: "InCombining_Diacritical_Marks",
    bmp: "-"
  }, {
    name: "InCombining_Diacritical_Marks_Extended",
    bmp: "-"
  }, {
    name: "InCombining_Diacritical_Marks_For_Symbols",
    bmp: "-"
  }, {
    name: "InCombining_Diacritical_Marks_Supplement",
    bmp: "-"
  }, {
    name: "InCombining_Half_Marks",
    bmp: "-"
  }, {
    name: "InCommon_Indic_Number_Forms",
    bmp: "-"
  }, {
    name: "InControl_Pictures",
    bmp: "-"
  }, {
    name: "InCoptic",
    bmp: "-"
  }, {
    name: "InCoptic_Epact_Numbers",
    astral: "[-]"
  }, {
    name: "InCounting_Rod_Numerals",
    astral: "[-]"
  }, {
    name: "InCuneiform",
    astral: "[-]"
  }, {
    name: "InCuneiform_Numbers_And_Punctuation",
    astral: "[-]"
  }, {
    name: "InCurrency_Symbols",
    bmp: "-"
  }, {
    name: "InCypriot_Syllabary",
    astral: "[-]"
  }, {
    name: "InCyrillic",
    bmp: "-"
  }, {
    name: "InCyrillic_Extended_A",
    bmp: "-"
  }, {
    name: "InCyrillic_Extended_B",
    bmp: "-"
  }, {
    name: "InCyrillic_Extended_C",
    bmp: "-"
  }, {
    name: "InCyrillic_Supplement",
    bmp: "-"
  }, {
    name: "InDeseret",
    astral: "[-]"
  }, {
    name: "InDevanagari",
    bmp: "-"
  }, {
    name: "InDevanagari_Extended",
    bmp: "-"
  }, {
    name: "InDingbats",
    bmp: "-"
  }, {
    name: "InDomino_Tiles",
    astral: "[-]"
  }, {
    name: "InDuployan",
    astral: "[-]"
  }, {
    name: "InEarly_Dynastic_Cuneiform",
    astral: "[-]"
  }, {
    name: "InEgyptian_Hieroglyphs",
    astral: "[-]|[-]"
  }, {
    name: "InElbasan",
    astral: "[-]"
  }, {
    name: "InEmoticons",
    astral: "[-]"
  }, {
    name: "InEnclosed_Alphanumeric_Supplement",
    astral: "[-]"
  }, {
    name: "InEnclosed_Alphanumerics",
    bmp: "-"
  }, {
    name: "InEnclosed_CJK_Letters_And_Months",
    bmp: "-"
  }, {
    name: "InEnclosed_Ideographic_Supplement",
    astral: "[-]"
  }, {
    name: "InEthiopic",
    bmp: "-"
  }, {
    name: "InEthiopic_Extended",
    bmp: "-"
  }, {
    name: "InEthiopic_Extended_A",
    bmp: "-"
  }, {
    name: "InEthiopic_Supplement",
    bmp: "-"
  }, {
    name: "InGeneral_Punctuation",
    bmp: "-"
  }, {
    name: "InGeometric_Shapes",
    bmp: "-"
  }, {
    name: "InGeometric_Shapes_Extended",
    astral: "[-]"
  }, {
    name: "InGeorgian",
    bmp: "-"
  }, {
    name: "InGeorgian_Supplement",
    bmp: "-"
  }, {
    name: "InGlagolitic",
    bmp: "-"
  }, {
    name: "InGlagolitic_Supplement",
    astral: "[-]"
  }, {
    name: "InGothic",
    astral: "[-]"
  }, {
    name: "InGrantha",
    astral: "[-]"
  }, {
    name: "InGreek_And_Coptic",
    bmp: "-"
  }, {
    name: "InGreek_Extended",
    bmp: "-"
  }, {
    name: "InGujarati",
    bmp: "-"
  }, {
    name: "InGurmukhi",
    bmp: "-"
  }, {
    name: "InHalfwidth_And_Fullwidth_Forms",
    bmp: "-"
  }, {
    name: "InHangul_Compatibility_Jamo",
    bmp: "-"
  }, {
    name: "InHangul_Jamo",
    bmp: "-"
  }, {
    name: "InHangul_Jamo_Extended_A",
    bmp: "-"
  }, {
    name: "InHangul_Jamo_Extended_B",
    bmp: "-"
  }, {
    name: "InHangul_Syllables",
    bmp: "-"
  }, {
    name: "InHanunoo",
    bmp: "-"
  }, {
    name: "InHatran",
    astral: "[-]"
  }, {
    name: "InHebrew",
    bmp: "-"
  }, {
    name: "InHigh_Private_Use_Surrogates",
    bmp: "-"
  }, {
    name: "InHigh_Surrogates",
    bmp: "-"
  }, {
    name: "InHiragana",
    bmp: "-"
  }, {
    name: "InIPA_Extensions",
    bmp: "-"
  }, {
    name: "InIdeographic_Description_Characters",
    bmp: "-"
  }, {
    name: "InIdeographic_Symbols_And_Punctuation",
    astral: "[-]"
  }, {
    name: "InImperial_Aramaic",
    astral: "[-]"
  }, {
    name: "InInscriptional_Pahlavi",
    astral: "[-]"
  }, {
    name: "InInscriptional_Parthian",
    astral: "[-]"
  }, {
    name: "InJavanese",
    bmp: "-"
  }, {
    name: "InKaithi",
    astral: "[-]"
  }, {
    name: "InKana_Extended_A",
    astral: "[-]"
  }, {
    name: "InKana_Supplement",
    astral: "[-]"
  }, {
    name: "InKanbun",
    bmp: "-"
  }, {
    name: "InKangxi_Radicals",
    bmp: "-"
  }, {
    name: "InKannada",
    bmp: "-"
  }, {
    name: "InKatakana",
    bmp: "-"
  }, {
    name: "InKatakana_Phonetic_Extensions",
    bmp: "-"
  }, {
    name: "InKayah_Li",
    bmp: "-"
  }, {
    name: "InKharoshthi",
    astral: "[-]"
  }, {
    name: "InKhmer",
    bmp: "-"
  }, {
    name: "InKhmer_Symbols",
    bmp: "-"
  }, {
    name: "InKhojki",
    astral: "[-]"
  }, {
    name: "InKhudawadi",
    astral: "[-]"
  }, {
    name: "InLao",
    bmp: "-"
  }, {
    name: "InLatin_1_Supplement",
    bmp: "-"
  }, {
    name: "InLatin_Extended_A",
    bmp: "-"
  }, {
    name: "InLatin_Extended_Additional",
    bmp: "-"
  }, {
    name: "InLatin_Extended_B",
    bmp: "-"
  }, {
    name: "InLatin_Extended_C",
    bmp: "-"
  }, {
    name: "InLatin_Extended_D",
    bmp: "-"
  }, {
    name: "InLatin_Extended_E",
    bmp: "-"
  }, {
    name: "InLepcha",
    bmp: "-"
  }, {
    name: "InLetterlike_Symbols",
    bmp: "-"
  }, {
    name: "InLimbu",
    bmp: "-"
  }, {
    name: "InLinear_A",
    astral: "[-]"
  }, {
    name: "InLinear_B_Ideograms",
    astral: "[-]"
  }, {
    name: "InLinear_B_Syllabary",
    astral: "[-]"
  }, {
    name: "InLisu",
    bmp: "-"
  }, {
    name: "InLow_Surrogates",
    bmp: "-"
  }, {
    name: "InLycian",
    astral: "[-]"
  }, {
    name: "InLydian",
    astral: "[-]"
  }, {
    name: "InMahajani",
    astral: "[-]"
  }, {
    name: "InMahjong_Tiles",
    astral: "[-]"
  }, {
    name: "InMalayalam",
    bmp: "-"
  }, {
    name: "InMandaic",
    bmp: "-"
  }, {
    name: "InManichaean",
    astral: "[-]"
  }, {
    name: "InMarchen",
    astral: "[-]"
  }, {
    name: "InMasaram_Gondi",
    astral: "[-]"
  }, {
    name: "InMathematical_Alphanumeric_Symbols",
    astral: "[-]"
  }, {
    name: "InMathematical_Operators",
    bmp: "-"
  }, {
    name: "InMeetei_Mayek",
    bmp: "-"
  }, {
    name: "InMeetei_Mayek_Extensions",
    bmp: "-"
  }, {
    name: "InMende_Kikakui",
    astral: "[-]"
  }, {
    name: "InMeroitic_Cursive",
    astral: "[-]"
  }, {
    name: "InMeroitic_Hieroglyphs",
    astral: "[-]"
  }, {
    name: "InMiao",
    astral: "[-]"
  }, {
    name: "InMiscellaneous_Mathematical_Symbols_A",
    bmp: "-"
  }, {
    name: "InMiscellaneous_Mathematical_Symbols_B",
    bmp: "-"
  }, {
    name: "InMiscellaneous_Symbols",
    bmp: "-"
  }, {
    name: "InMiscellaneous_Symbols_And_Arrows",
    bmp: "-"
  }, {
    name: "InMiscellaneous_Symbols_And_Pictographs",
    astral: "[-]|[-]"
  }, {
    name: "InMiscellaneous_Technical",
    bmp: "-"
  }, {
    name: "InModi",
    astral: "[-]"
  }, {
    name: "InModifier_Tone_Letters",
    bmp: "-"
  }, {
    name: "InMongolian",
    bmp: "-"
  }, {
    name: "InMongolian_Supplement",
    astral: "[-]"
  }, {
    name: "InMro",
    astral: "[-]"
  }, {
    name: "InMultani",
    astral: "[-]"
  }, {
    name: "InMusical_Symbols",
    astral: "[-]"
  }, {
    name: "InMyanmar",
    bmp: "-"
  }, {
    name: "InMyanmar_Extended_A",
    bmp: "-"
  }, {
    name: "InMyanmar_Extended_B",
    bmp: "-"
  }, {
    name: "InNKo",
    bmp: "-"
  }, {
    name: "InNabataean",
    astral: "[-]"
  }, {
    name: "InNew_Tai_Lue",
    bmp: "-"
  }, {
    name: "InNewa",
    astral: "[-]"
  }, {
    name: "InNumber_Forms",
    bmp: "-"
  }, {
    name: "InNushu",
    astral: "[-]"
  }, {
    name: "InOgham",
    bmp: "-"
  }, {
    name: "InOl_Chiki",
    bmp: "-"
  }, {
    name: "InOld_Hungarian",
    astral: "[-]"
  }, {
    name: "InOld_Italic",
    astral: "[-]"
  }, {
    name: "InOld_North_Arabian",
    astral: "[-]"
  }, {
    name: "InOld_Permic",
    astral: "[-]"
  }, {
    name: "InOld_Persian",
    astral: "[-]"
  }, {
    name: "InOld_South_Arabian",
    astral: "[-]"
  }, {
    name: "InOld_Turkic",
    astral: "[-]"
  }, {
    name: "InOptical_Character_Recognition",
    bmp: "-"
  }, {
    name: "InOriya",
    bmp: "-"
  }, {
    name: "InOrnamental_Dingbats",
    astral: "[-]"
  }, {
    name: "InOsage",
    astral: "[-]"
  }, {
    name: "InOsmanya",
    astral: "[-]"
  }, {
    name: "InPahawh_Hmong",
    astral: "[-]"
  }, {
    name: "InPalmyrene",
    astral: "[-]"
  }, {
    name: "InPau_Cin_Hau",
    astral: "[-]"
  }, {
    name: "InPhags_Pa",
    bmp: "-"
  }, {
    name: "InPhaistos_Disc",
    astral: "[-]"
  }, {
    name: "InPhoenician",
    astral: "[-]"
  }, {
    name: "InPhonetic_Extensions",
    bmp: "-"
  }, {
    name: "InPhonetic_Extensions_Supplement",
    bmp: "-"
  }, {
    name: "InPlaying_Cards",
    astral: "[-]"
  }, {
    name: "InPrivate_Use_Area",
    bmp: "-"
  }, {
    name: "InPsalter_Pahlavi",
    astral: "[-]"
  }, {
    name: "InRejang",
    bmp: "-"
  }, {
    name: "InRumi_Numeral_Symbols",
    astral: "[-]"
  }, {
    name: "InRunic",
    bmp: "-"
  }, {
    name: "InSamaritan",
    bmp: "-"
  }, {
    name: "InSaurashtra",
    bmp: "-"
  }, {
    name: "InSharada",
    astral: "[-]"
  }, {
    name: "InShavian",
    astral: "[-]"
  }, {
    name: "InShorthand_Format_Controls",
    astral: "[-]"
  }, {
    name: "InSiddham",
    astral: "[-]"
  }, {
    name: "InSinhala",
    bmp: "-"
  }, {
    name: "InSinhala_Archaic_Numbers",
    astral: "[-]"
  }, {
    name: "InSmall_Form_Variants",
    bmp: "-"
  }, {
    name: "InSora_Sompeng",
    astral: "[-]"
  }, {
    name: "InSoyombo",
    astral: "[-]"
  }, {
    name: "InSpacing_Modifier_Letters",
    bmp: "-"
  }, {
    name: "InSpecials",
    bmp: "-"
  }, {
    name: "InSundanese",
    bmp: "-"
  }, {
    name: "InSundanese_Supplement",
    bmp: "-"
  }, {
    name: "InSuperscripts_And_Subscripts",
    bmp: "-"
  }, {
    name: "InSupplemental_Arrows_A",
    bmp: "-"
  }, {
    name: "InSupplemental_Arrows_B",
    bmp: "-"
  }, {
    name: "InSupplemental_Arrows_C",
    astral: "[-]"
  }, {
    name: "InSupplemental_Mathematical_Operators",
    bmp: "-"
  }, {
    name: "InSupplemental_Punctuation",
    bmp: "-"
  }, {
    name: "InSupplemental_Symbols_And_Pictographs",
    astral: "[-]"
  }, {
    name: "InSupplementary_Private_Use_Area_A",
    astral: "[-][-]"
  }, {
    name: "InSupplementary_Private_Use_Area_B",
    astral: "[-][-]"
  }, {
    name: "InSutton_SignWriting",
    astral: "[-]"
  }, {
    name: "InSyloti_Nagri",
    bmp: "-"
  }, {
    name: "InSyriac",
    bmp: "-"
  }, {
    name: "InSyriac_Supplement",
    bmp: "-"
  }, {
    name: "InTagalog",
    bmp: "-"
  }, {
    name: "InTagbanwa",
    bmp: "-"
  }, {
    name: "InTags",
    astral: "[-]"
  }, {
    name: "InTai_Le",
    bmp: "-"
  }, {
    name: "InTai_Tham",
    bmp: "-"
  }, {
    name: "InTai_Viet",
    bmp: "-"
  }, {
    name: "InTai_Xuan_Jing_Symbols",
    astral: "[-]"
  }, {
    name: "InTakri",
    astral: "[-]"
  }, {
    name: "InTamil",
    bmp: "-"
  }, {
    name: "InTangut",
    astral: "[-][-]"
  }, {
    name: "InTangut_Components",
    astral: "[-]"
  }, {
    name: "InTelugu",
    bmp: "-"
  }, {
    name: "InThaana",
    bmp: "-"
  }, {
    name: "InThai",
    bmp: "-"
  }, {
    name: "InTibetan",
    bmp: "-"
  }, {
    name: "InTifinagh",
    bmp: "-"
  }, {
    name: "InTirhuta",
    astral: "[-]"
  }, {
    name: "InTransport_And_Map_Symbols",
    astral: "[-]"
  }, {
    name: "InUgaritic",
    astral: "[-]"
  }, {
    name: "InUnified_Canadian_Aboriginal_Syllabics",
    bmp: "-"
  }, {
    name: "InUnified_Canadian_Aboriginal_Syllabics_Extended",
    bmp: "-"
  }, {
    name: "InVai",
    bmp: "-"
  }, {
    name: "InVariation_Selectors",
    bmp: "-"
  }, {
    name: "InVariation_Selectors_Supplement",
    astral: "[-]"
  }, {
    name: "InVedic_Extensions",
    bmp: "-"
  }, {
    name: "InVertical_Forms",
    bmp: "-"
  }, {
    name: "InWarang_Citi",
    astral: "[-]"
  }, {
    name: "InYi_Radicals",
    bmp: "-"
  }, {
    name: "InYi_Syllables",
    bmp: "-"
  }, {
    name: "InYijing_Hexagram_Symbols",
    bmp: "-"
  }, {
    name: "InZanabazar_Square",
    astral: "[-]"
  } ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _categories = __webpack_require__(61);
  var _categories2 = _interopRequireDefault(_categories);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = function(XRegExp) {
    if (!XRegExp.addUnicodeData) {
      throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
    }
    XRegExp.addUnicodeData(_categories2.default);
  };
  /*!
    * XRegExp Unicode Categories 4.1.1
    * <xregexp.com>
    * Steven Levithan (c) 2010-present MIT License
    * Unicode data by Mathias Bynens <mathiasbynens.be>
    */
  module.exports = exports["default"];
}, function(module, exports) {
  module.exports = [ {
    name: "C",
    alias: "Other",
    isBmpLast: true,
    bmp: "\0---------------------------------------------------------------------------------------------------------------------------------------------------",
    astral: "[---------------]|[---------]|[---------------------]|[-----]|[----------------]|[------------]|[------]|[------]|[-]|[--]|[-------][-]|[-]|[-]|[-------]|[-----]|[-]|[-]|[--]|[----]|[------]|[-]|[--]|[-]|[----]|[------]|[-----------]|[-----]|[-----------]|[-]|[-]|[]|[-]|[-]|[-]|[--]"
  }, {
    name: "Cc",
    alias: "Control",
    bmp: "\0--"
  }, {
    name: "Cf",
    alias: "Format",
    bmp: "-----\ufeff-",
    astral: "|[-]|[-]|[-]"
  }, {
    name: "Cn",
    alias: "Unassigned",
    bmp: "---------------------------------------------------------------------------------------------------------------------------------------------",
    astral: "[---------------]|[---------]|[---------------------]|[-----]|[----------------]|[------------]|[------]|[------]|[-]|[--]|[-------][-]|[-]|[-]|[-------]|[-----]|[-]|[-]|[--]|[----]|[-----]|[-]|[--]|[-]|[----]|[------]|[-----------]|[-----]|[-----------]|[-]|[-]|[]|[-]|[-]|[-]|[---]|[][]"
  }, {
    name: "Co",
    alias: "Private_Use",
    bmp: "-",
    astral: "[--][-]|[][-]"
  }, {
    name: "Cs",
    alias: "Surrogate",
    bmp: "-"
  }, {
    name: "L",
    alias: "Letter",
    bmp: "A-Za-z------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
    astral: "[---------------]|[--------]|[--------------------]|[---]|[-------------------]|[--------]|[-----]|[-----]|[-]|[-]|[-----][-]|[-]|[-]|[-------]|[--]|[-]|[-]|[--]|[----]|[-------------------------]|[--]|[--------------]|[--]|[--]|[--]|[--]|[-]|[-]"
  }, {
    name: "LC",
    alias: "Cased_Letter",
    bmp: "A-Za-z---------------------------------------------------------------",
    astral: "[---]|[--]|[-]|[-------------------------]|[-]"
  }, {
    name: "Ll",
    alias: "Lowercase_Letter",
    bmp: "a-z-------------------------------------------------",
    astral: "[--]|[-]|[-]|[--------------------------]|[-]"
  }, {
    name: "Lm",
    alias: "Modifier_Letter",
    bmp: "------------",
    astral: "[-]|[-]"
  }, {
    name: "Lo",
    alias: "Other_Letter",
    bmp: "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
    astral: "[---------------]|[------]|[--------------------]|[-]|[-------------------]|[--------]|[----]|[-----]|[-]|[-]|[-----][-]|[-]|[-]|[------]|[-]|[-]|[-]|[--]|[----]|[-]|[--------------]|[--]|[--]|[--]|[--]|[-]|[-]"
  }, {
    name: "Lt",
    alias: "Titlecase_Letter",
    bmp: "---"
  }, {
    name: "Lu",
    alias: "Uppercase_Letter",
    bmp: "A-Z---------------------------------------",
    astral: "[--]|[-]|[-]|[-----------------------]|[-]"
  }, {
    name: "M",
    alias: "Mark",
    bmp: "---------------------------------------------------------------------------------------------------------------",
    astral: "[-]|[---]|[----------------]|[-------]|[-----]|[------]|[--]|[--]|[]|[------]|[----]|[----]|[--]|[-]"
  }, {
    name: "Mc",
    alias: "Spacing_Mark",
    bmp: "-----------------------------",
    astral: "[------]|[------]|[]|[]|[-]|[-]"
  }, {
    name: "Me",
    alias: "Enclosing_Mark",
    bmp: "---"
  }, {
    name: "Mn",
    alias: "Nonspacing_Mark",
    bmp: "---------------------------------------------------------------------------------",
    astral: "[-]|[---]|[------------]|[---------]|[------]|[------]|[--]|[-]|[]|[-----]|[----]|[----]|[--]|[-]"
  }, {
    name: "N",
    alias: "Number",
    bmp: "0-9-------------------------------------------------------------",
    astral: "[-----]|[-]|[-------------]|[--]|[------]|[-----]|[-]|[--]|[-]|[---]|[-]|[-]|[--]|[-]"
  }, {
    name: "Nd",
    alias: "Decimal_Number",
    bmp: "0-9------------------------------------",
    astral: "[-]|[-----]|[-----]|[-]|[--]|[--]|[-]|[-]"
  }, {
    name: "Nl",
    alias: "Letter_Number",
    bmp: "------",
    astral: "[--]|[-]"
  }, {
    name: "No",
    alias: "Other_Number",
    bmp: "-----------------------",
    astral: "[----]|[-------------]|[--]|[--]|[]|[-]|[-]|[-]|[-]|[-]|[-]"
  }, {
    name: "P",
    alias: "Punctuation",
    bmp: "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}-------------------------------------------------",
    astral: "[-]||[----]|[------]|[-----]|[---]|[-]|[-]|[-]||[-]|[]"
  }, {
    name: "Pc",
    alias: "Connector_Punctuation",
    bmp: "_-"
  }, {
    name: "Pd",
    alias: "Dash_Punctuation",
    bmp: "\\--"
  }, {
    name: "Pe",
    alias: "Close_Punctuation",
    bmp: "\\)\\]\\}"
  }, {
    name: "Pf",
    alias: "Final_Punctuation",
    bmp: ""
  }, {
    name: "Pi",
    alias: "Initial_Punctuation",
    bmp: ""
  }, {
    name: "Po",
    alias: "Other_Punctuation",
    bmp: "!-#%-'\\*,\\.\\/:;\\?@\\-----------------------------------------------",
    astral: "[-]||[----]|[------]|[-----]|[---]|[-]|[-]|[-]||[-]|[]"
  }, {
    name: "Ps",
    alias: "Open_Punctuation",
    bmp: "\\(\\[\\{"
  }, {
    name: "S",
    alias: "Symbol",
    bmp: "\\$\\+<->\\^`\\|~------------------------------------------------------------------------",
    astral: "[-----]|[]||[-]||[--------]|[]|[----]|[]|[--------------]|[-----]|[-----------]"
  }, {
    name: "Sc",
    alias: "Currency_Symbol",
    bmp: "\\$--"
  }, {
    name: "Sk",
    alias: "Modifier_Symbol",
    bmp: "\\^`----------",
    astral: "[-]"
  }, {
    name: "Sm",
    alias: "Math_Symbol",
    bmp: "\\+<->\\|~---------------------",
    astral: "[]|[]"
  }, {
    name: "So",
    alias: "Other_Symbol",
    bmp: "----------------------------------------------------------",
    astral: "[-----]|[]||[-]||[--------]|[----]|[--------------]|[-----]|[-----------]"
  }, {
    name: "Z",
    alias: "Separator",
    bmp: " -\u2028\u2029"
  }, {
    name: "Zl",
    alias: "Line_Separator",
    bmp: "\u2028"
  }, {
    name: "Zp",
    alias: "Paragraph_Separator",
    bmp: "\u2029"
  }, {
    name: "Zs",
    alias: "Space_Separator",
    bmp: " -"
  } ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _properties = __webpack_require__(63);
  var _properties2 = _interopRequireDefault(_properties);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = function(XRegExp) {
    if (!XRegExp.addUnicodeData) {
      throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
    }
    var unicodeData = _properties2.default;
    unicodeData.push({
      name: "Assigned",
      inverseOf: "Cn"
    });
    XRegExp.addUnicodeData(unicodeData);
  };
  /*!
    * XRegExp Unicode Properties 4.1.1
    * <xregexp.com>
    * Steven Levithan (c) 2012-present MIT License
    * Unicode data by Mathias Bynens <mathiasbynens.be>
    */
  module.exports = exports["default"];
}, function(module, exports) {
  module.exports = [ {
    name: "ASCII",
    bmp: "\0-"
  }, {
    name: "Alphabetic",
    bmp: "A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
    astral: "[----------------]|[--------]|[---------------------]|[---]|[---------------------]|[-----------]|[------]|[---------]|[-]|[--]|[-----][-]|[-]|[-]|[-------]|[---]|[-]|[-]|[--]|[----]|[-------------------------]|[----]|[--]|[--------------]|[---]|[--]|[--]|[--]|[--]|[-]|[-]"
  }, {
    name: "Any",
    isBmpLast: true,
    bmp: "\0-",
    astral: "[-][-]"
  }, {
    name: "Default_Ignorable_Code_Point",
    bmp: "-----\ufeff-",
    astral: "[-]|[-]|[-][-]"
  }, {
    name: "Lowercase",
    bmp: "a-z-----------------------------------------------------",
    astral: "[--]|[-]|[-]|[--------------------------]|[-]"
  }, {
    name: "Noncharacter_Code_Point",
    bmp: "-",
    astral: "[][]"
  }, {
    name: "Uppercase",
    bmp: "A-Z-----------------------------------------",
    astral: "[--]|[-]|[-]|[-----------------------]|[-]|[---]"
  }, {
    name: "White_Space",
    bmp: "\t-\r -\u2028\u2029"
  } ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _scripts = __webpack_require__(65);
  var _scripts2 = _interopRequireDefault(_scripts);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = function(XRegExp) {
    if (!XRegExp.addUnicodeData) {
      throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
    }
    XRegExp.addUnicodeData(_scripts2.default);
  };
  /*!
    * XRegExp Unicode Scripts 4.1.1
    * <xregexp.com>
    * Steven Levithan (c) 2010-present MIT License
    * Unicode data by Mathias Bynens <mathiasbynens.be>
    */
  module.exports = exports["default"];
}, function(module, exports) {
  module.exports = [ {
    name: "Adlam",
    astral: "[--]"
  }, {
    name: "Ahom",
    astral: "[---]"
  }, {
    name: "Anatolian_Hieroglyphs",
    astral: "[-]"
  }, {
    name: "Arabic",
    bmp: "--------------------",
    astral: "[-]|[--------------]"
  }, {
    name: "Armenian",
    bmp: "-----"
  }, {
    name: "Avestan",
    astral: "[--]"
  }, {
    name: "Balinese",
    bmp: "--"
  }, {
    name: "Bamum",
    bmp: "-",
    astral: "[-]"
  }, {
    name: "Bassa_Vah",
    astral: "[--]"
  }, {
    name: "Batak",
    bmp: "--"
  }, {
    name: "Bengali",
    bmp: "---------"
  }, {
    name: "Bhaiksuki",
    astral: "[----]"
  }, {
    name: "Bopomofo",
    bmp: "--"
  }, {
    name: "Brahmi",
    astral: "[--]"
  }, {
    name: "Braille",
    bmp: "-"
  }, {
    name: "Buginese",
    bmp: "-"
  }, {
    name: "Buhid",
    bmp: "-"
  }, {
    name: "Canadian_Aboriginal",
    bmp: "--"
  }, {
    name: "Carian",
    astral: "[-]"
  }, {
    name: "Caucasian_Albanian",
    astral: "[-]"
  }, {
    name: "Chakma",
    astral: "[--]"
  }, {
    name: "Cham",
    bmp: "----"
  }, {
    name: "Cherokee",
    bmp: "---"
  }, {
    name: "Common",
    bmp: "\0-@\\[-`\\{---------------------------------------------------\ufeff------",
    astral: "[------]|[-]|[--------]|[----------------]|[---------------]|[-----]|[-----------]|[-]"
  }, {
    name: "Coptic",
    bmp: "---"
  }, {
    name: "Cuneiform",
    astral: "[-]|[---]"
  }, {
    name: "Cypriot",
    astral: "[--]"
  }, {
    name: "Cyrillic",
    bmp: "-----"
  }, {
    name: "Deseret",
    astral: "[-]"
  }, {
    name: "Devanagari",
    bmp: "----"
  }, {
    name: "Duployan",
    astral: "[-----]"
  }, {
    name: "Egyptian_Hieroglyphs",
    astral: "[-]|[-]"
  }, {
    name: "Elbasan",
    astral: "[-]"
  }, {
    name: "Ethiopic",
    bmp: "------------------------------"
  }, {
    name: "Georgian",
    bmp: "----"
  }, {
    name: "Glagolitic",
    bmp: "--",
    astral: "[----]"
  }, {
    name: "Gothic",
    astral: "[-]"
  }, {
    name: "Grantha",
    astral: "[----------]"
  }, {
    name: "Greek",
    bmp: "-----------------------",
    astral: "[-]|[-]"
  }, {
    name: "Gujarati",
    bmp: "------------"
  }, {
    name: "Gurmukhi",
    bmp: "--------"
  }, {
    name: "Han",
    bmp: "---------",
    astral: "[----][-]|[--]|[--]|[--]|[--]|[-]|[-]"
  }, {
    name: "Hangul",
    bmp: "-------------"
  }, {
    name: "Hanunoo",
    bmp: "-"
  }, {
    name: "Hatran",
    astral: "[--]"
  }, {
    name: "Hebrew",
    bmp: "------"
  }, {
    name: "Hiragana",
    bmp: "--",
    astral: "[-]|"
  }, {
    name: "Imperial_Aramaic",
    astral: "[--]"
  }, {
    name: "Inherited",
    bmp: "------------",
    astral: "[]|[----]|[-]"
  }, {
    name: "Inscriptional_Pahlavi",
    astral: "[--]"
  }, {
    name: "Inscriptional_Parthian",
    astral: "[--]"
  }, {
    name: "Javanese",
    bmp: "--"
  }, {
    name: "Kaithi",
    astral: "[-]"
  }, {
    name: "Kannada",
    bmp: "-----------"
  }, {
    name: "Katakana",
    bmp: "-------",
    astral: ""
  }, {
    name: "Kayah_Li",
    bmp: "-"
  }, {
    name: "Kharoshthi",
    astral: "[-------]"
  }, {
    name: "Khmer",
    bmp: "----"
  }, {
    name: "Khojki",
    astral: "[--]"
  }, {
    name: "Khudawadi",
    astral: "[--]"
  }, {
    name: "Lao",
    bmp: "---------"
  }, {
    name: "Latin",
    bmp: "A-Za-z----------------------"
  }, {
    name: "Lepcha",
    bmp: "---"
  }, {
    name: "Limbu",
    bmp: "----"
  }, {
    name: "Linear_A",
    astral: "[---]"
  }, {
    name: "Linear_B",
    astral: "[------]"
  }, {
    name: "Lisu",
    bmp: "-"
  }, {
    name: "Lycian",
    astral: "[-]"
  }, {
    name: "Lydian",
    astral: "[-]"
  }, {
    name: "Mahajani",
    astral: "[-]"
  }, {
    name: "Malayalam",
    bmp: "--------"
  }, {
    name: "Mandaic",
    bmp: "-"
  }, {
    name: "Manichaean",
    astral: "[--]"
  }, {
    name: "Marchen",
    astral: "[---]"
  }, {
    name: "Masaram_Gondi",
    astral: "[----]"
  }, {
    name: "Meetei_Mayek",
    bmp: "---"
  }, {
    name: "Mende_Kikakui",
    astral: "[--]"
  }, {
    name: "Meroitic_Cursive",
    astral: "[---]"
  }, {
    name: "Meroitic_Hieroglyphs",
    astral: "[-]"
  }, {
    name: "Miao",
    astral: "[---]"
  }, {
    name: "Modi",
    astral: "[--]"
  }, {
    name: "Mongolian",
    bmp: "----",
    astral: "[-]"
  }, {
    name: "Mro",
    astral: "[--]"
  }, {
    name: "Multani",
    astral: "[----]"
  }, {
    name: "Myanmar",
    bmp: "---"
  }, {
    name: "Nabataean",
    astral: "[--]"
  }, {
    name: "New_Tai_Lue",
    bmp: "---"
  }, {
    name: "Newa",
    astral: "[-]"
  }, {
    name: "Nko",
    bmp: "-"
  }, {
    name: "Nushu",
    astral: "|[-]"
  }, {
    name: "Ogham",
    bmp: "-"
  }, {
    name: "Ol_Chiki",
    bmp: "-"
  }, {
    name: "Old_Hungarian",
    astral: "[---]"
  }, {
    name: "Old_Italic",
    astral: "[--]"
  }, {
    name: "Old_North_Arabian",
    astral: "[-]"
  }, {
    name: "Old_Permic",
    astral: "[-]"
  }, {
    name: "Old_Persian",
    astral: "[--]"
  }, {
    name: "Old_South_Arabian",
    astral: "[-]"
  }, {
    name: "Old_Turkic",
    astral: "[-]"
  }, {
    name: "Oriya",
    bmp: "---------"
  }, {
    name: "Osage",
    astral: "[--]"
  }, {
    name: "Osmanya",
    astral: "[--]"
  }, {
    name: "Pahawh_Hmong",
    astral: "[-----]"
  }, {
    name: "Palmyrene",
    astral: "[-]"
  }, {
    name: "Pau_Cin_Hau",
    astral: "[-]"
  }, {
    name: "Phags_Pa",
    bmp: "-"
  }, {
    name: "Phoenician",
    astral: "[-]"
  }, {
    name: "Psalter_Pahlavi",
    astral: "[---]"
  }, {
    name: "Rejang",
    bmp: "-"
  }, {
    name: "Runic",
    bmp: "--"
  }, {
    name: "Samaritan",
    bmp: "--"
  }, {
    name: "Saurashtra",
    bmp: "--"
  }, {
    name: "Sharada",
    astral: "[--]"
  }, {
    name: "Shavian",
    astral: "[-]"
  }, {
    name: "Siddham",
    astral: "[--]"
  }, {
    name: "SignWriting",
    astral: "[---]"
  }, {
    name: "Sinhala",
    bmp: "--------",
    astral: "[-]"
  }, {
    name: "Sora_Sompeng",
    astral: "[--]"
  }, {
    name: "Soyombo",
    astral: "[---]"
  }, {
    name: "Sundanese",
    bmp: "--"
  }, {
    name: "Syloti_Nagri",
    bmp: "-"
  }, {
    name: "Syriac",
    bmp: "----"
  }, {
    name: "Tagalog",
    bmp: "--"
  }, {
    name: "Tagbanwa",
    bmp: "--"
  }, {
    name: "Tai_Le",
    bmp: "--"
  }, {
    name: "Tai_Tham",
    bmp: "-----"
  }, {
    name: "Tai_Viet",
    bmp: "--"
  }, {
    name: "Takri",
    astral: "[--]"
  }, {
    name: "Tamil",
    bmp: "---------"
  }, {
    name: "Tangut",
    astral: "|[-][-]|[-]|[-]"
  }, {
    name: "Telugu",
    bmp: "------------"
  }, {
    name: "Thaana",
    bmp: "-"
  }, {
    name: "Thai",
    bmp: "--"
  }, {
    name: "Tibetan",
    bmp: "------"
  }, {
    name: "Tifinagh",
    bmp: "-"
  }, {
    name: "Tirhuta",
    astral: "[--]"
  }, {
    name: "Ugaritic",
    astral: "[-]"
  }, {
    name: "Vai",
    bmp: "-"
  }, {
    name: "Warang_Citi",
    astral: "[-]"
  }, {
    name: "Yi",
    bmp: "--"
  }, {
    name: "Zanabazar_Square",
    astral: "[-]"
  } ];
} ]);